













Software testing - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Software_testing";
		var wgTitle = "Software testing";
		var wgAction = "view";
		var wgArticleId = "29090";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 282280085;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
<!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Software testing

From Wikipedia, the free encyclopedia

Jump to: navigation, search 


Software development process


Activities and steps


Requirements · Specification
Architecture · Design
Implementation · Testing
Deployment · Maintenance


Models


Agile · Cleanroom · DSDM
Iterative · RAD  · RUP  · Spiral
Waterfall · XP · Scrum  · V-Model
FDD


Supporting disciplines


Configuration management
Documentation
Quality assurance (SQA)
Project management
User experience design


Tools


Compiler  · Debugger  · Profiler
GUI designer
Integrated development environment



This box: view • talk







Software Testing portal



Software Testing is an empirical investigation conducted to provide stakeholders with information about the quality of the product or service under test[1] , with respect to the context in which it is intended to operate. This includes, but is not limited to, the process of executing a program or application with the intent of finding software bugs. It can also be stated as the process of validating and verifying that a software program/application/product meets the business and technical requirements that guided its design and development, so that it works as expected and can be implemented with the same characteristics.




Contents


1 Overview
2 History
3 Software testing topics

3.1 Scope
3.2 Defects and failures
3.3 Compatibility
3.4 Input combinations and preconditions
3.5 Static vs. dynamic testing
3.6 Software verification and validation
3.7 The software testing team
3.8 Software Quality Assurance (SQA)


4 Testing methods

4.1 Black box testing
4.2 White box testing
4.3 Grey Box Testing
4.4 Acceptance testing
4.5 Regression Testing
4.6 Non Functional Software Testing


5 Testing process

5.1 Regression testing


6 Finding faults

6.1 Finding faults early
6.2 Testing Tools
6.3 Measuring software testing
6.4 Testing artifacts
6.5 A sample testing cycle


7 Certification
8 Controversy
9 See also
10 References
11 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Overview
Testing can never completely establish the correctness of computer software. Instead, it furnishes a criticism or comparison that compares the state and behavior of the product against oracles—principles or mechanisms by which someone might recognize a problem. These oracles may include (but are not limited to) specifications, comparable products, past versions of the same product, inferences about intended or expected purpose, user or customer expectations, relevant standards, applicable laws, or other criteria.
Over its existence, computer software has continued to grow in complexity and size. Every software product has a target audience. For example, the audience for video game software is completely different from banking software. Therefore, when an organization develops or otherwise invests in a software product, it presumably must assess whether the software product will be acceptable to its end users, its target audience, its purchasers, and other stakeholders. Software testing is the process of attempting to make this assessment.
A study conducted by NIST in 2002 reports that software bugs cost the U.S. economy $59.5 billion annually. More than a third of this cost could be avoided if better software testing was performed.[2]

[edit] History
The separation of debugging from testing was initially introduced by Glenford J. Myers in 1979.[3] Although his attention was on breakage testing ("a successful test is one that finds a bug"[citation needed]), it illustrated the desire of the software engineering community to separate fundamental development activities, such as debugging, from that of verification. Dave Gelperin and William C. Hetzel classified in 1988 the phases and goals in software testing in the following stages:[4]

Until 1956 - Debugging oriented[5]
1957-1978 - Demonstration oriented[6]
1979-1982 - Destruction oriented[7]
1983-1987 - Evaluation oriented[8]
1988-2000 - Prevention oriented[9]


[edit] Software testing topics

[edit] Scope
A primary purpose for testing is to detect software failures so that defects may be uncovered and corrected. This is a non-trivial pursuit. Testing cannot establish that a product functions properly under all conditions but can only establish that it does not function properly under specific conditions.[10] The scope of software testing often includes examination of code as well as execution of that code in various environments and conditions as well as examining the aspects of code: does it do what it is supposed to do and do what it needs to do. In the current culture of software development, a testing organization may be separate from the development team. There are various roles for testing team members. Information derived from software testing may be used to correct the process by which software is developed.

[edit] Defects and failures
Not all software defects are caused by coding errors. One common source of expensive defects is caused by requirements gaps, e.g., unrecognized requirements, that result in errors of omission by the program designer. A common source of requirements gaps is non-functional requirements such as testability, scalability, maintainability, usability, performance, and security.
Software faults occur through the following processes. A programmer makes an error (mistake), which results in a defect (fault, bug) in the software source code. If this defect is executed, in certain situations the system will produce wrong results, causing a failure.[11] Not all defects will necessarily result in failures. For example, defects in dead code will never result in failures. A defect can turn into a failure when the environment is changed. Examples of these changes in environment include the software being run on a new hardware platform, alterations in source data or interacting with different software.[11] A single defect may result in a wide range of failure symptoms.

[edit] Compatibility
A frequent cause of software failure is compatibility with another application, a new operating system, or, increasingly, web browser version. In the case of lack of backward compatibility, this can occur (for example...) because the programmers have only considered coding their programs for, or testing the software upon, "the latest version of" this-or-that operating system. The unintended consequence of this fact is that: their latest work might not be fully compatible with earlier mixtures of software/hardware, or it might not be fully compatible with another important operating system. In any case, these differences, whatever they might be, may have resulted in (unintended...) software failures, as witnessed by some significant population of computer users.
This could be considered a "prevention oriented strategy" that fits well with the latest testing phase suggested by Dave Gelperin and William C. Hetzel, as cited below [12].

[edit] Input combinations and preconditions
A very fundamental problem with software testing is that testing under all combinations of inputs and preconditions (initial state) is not feasible, even with a simple product.[10][13] This means that the number of defects in a software product can be very large and defects that occur infrequently are difficult to find in testing. More significantly, non-functional dimensions of quality (how it is supposed to be versus what it is supposed to do) -- for example, usability, scalability, performance, compatibility, reliability -- can be highly subjective; something that constitutes sufficient value to one person may be intolerable to another.

[edit] Static vs. dynamic testing
There are many approaches to software testing. Reviews, walkthroughs or inspections are considered as static testing, whereas actually executing programmed code with a given set of test cases is referred to as dynamic testing. The former can be, (and unfortunately in practice often is...) omitted, whereas the latter takes place when programs begin to be used for the first time - which is normally considered the beginning of the testing stage. This may actually begin before the program is 100% complete in order to test particular sections of code (modules or discrete functions). For example, Spreadsheet programs are, by their very nature, tested to a large extent "on the fly" during the build process as the result of some calculation or text manipulation is shown interactively immediately after each formula is entered.

[edit] Software verification and validation
Software testing is used in association with verification and validation:[14]

Verification: Have we built the software right (i.e., does it match the specification?)? It is process based.
Validation: Have we built the right software (i.e., is this what the customer wants?)? It is product based.


[edit] The software testing team
Software testing can be done by software testers. Until the 1950s the term "software tester" was used generally, but later it was also seen as a separate profession. Regarding the periods and the different goals in software testing[15], there have been established different roles: test lead/manager, test designer, tester, test automater/automation developer, and test administrator.

[edit] Software Quality Assurance (SQA)
Though controversial[10], software testing may be viewed as an important part of the software quality assurance (SQA) process.[citation needed] In SQA, software process specialists and auditors take a broader view on software and its development. They examine and change the software engineering process itself to reduce the amount of faults that end up in the delivered software: the so-called defect rate.
What constitutes an "acceptable defect rate" depends on the nature of the software. For example, an arcade video game designed to simulate flying an airplane would presumably have a much higher tolerance for defects than mission critical software such as that used to control the functions of an airliner that really is flying!
Although there are close links with SQA, testing departments often exist independently, and there may be no SQA function in some companies.
Software Testing is a task intended to detect defects in software by contrasting a computer program's expected results with its actual results for a given set of inputs. By contrast, QA (Quality Assurance) is the implementation of policies and procedures intended to prevent defects from occurring in the first place.

[edit] Testing methods
Software testing methods are traditionally divided into black box testing and white box testing. These two approaches are used to describe the point of view that a test engineer takes when designing test cases.

[edit] Black box testing
Black box testing treats the software as a "black box," without any knowledge of internal implementation. Black box testing methods include: equivalence partitioning, boundary value analysis, all-pairs testing, fuzz testing, model-based testing, traceability matrix, exploratory testing and specification-based testing.

Specification-based testing 
Specification-based testing aims to test the functionality of software according to the applicable requirements.[16] Thus, the tester inputs data into, and only sees the output from, the test object. This level of testing usually requires thorough test cases to be provided to the tester, who then can simply verify that for a given input, the output value (or behavior), either "is" or "is not" the same as the expected value specified in the test case.


Specification-based testing is necessary, but it is insufficient to guard against certain risks.[17]


Advantages and disadvantages 
The black box tester has no "bonds" with the code, and a tester's perception is very simple: a code must have bugs. Using the principle, "Ask and you shall receive," black box testers find bugs where programmers don't. But, on the other hand, black box testing has been said to be "like a walk in a dark labyrinth without a flashlight," because the tester doesn't know how the software being tested was actually constructed. That's why there are situations when (1) a black box tester writes many test cases to check something that can be tested by only one test case, and/or (2) some parts of the back end are not tested at all.

Therefore, black box testing has the advantage of "an unaffiliated opinion," on the one hand, and the disadvantage of "blind exploring," on the other. [18]

[edit] White box testing
White box testing, by contrast to black box testing, is when the tester has access to the internal data structures and algorithms (and the code that implement these)

Types of white box testing
The following types of white box testing exist:

api testing - Testing of the application using Public and Private APIs.
code coverage - creating tests to satisfy some criteria of code coverage. For example, the test designer can create tests to cause all statements in the program to be executed at least once.
fault injection methods.
mutation testing methods.
static testing - White box testing includes all static testing.




Code completeness evaluation
White box testing methods can also be used to evaluate the completeness of a test suite that was created with black box testing methods. This allows the software team to examine parts of a system that are rarely tested and ensures that the most important function points have been tested.[19]


Two common forms of code coverage are:

function coverage, which reports on functions executed
and statement coverage, which reports on the number of lines executed to complete the test.



They both return a coverage metric, measured as a percentage.

[edit] Grey Box Testing
In recent years the term grey box testing has come into common usage. This involves having access to internal data structures and algorithms for purposes of designing the test cases, but testing at the user, or black-box level. Manipulating input data and formatting output do not qualify as "grey-box," because the input and output are clearly outside of the "black-box" that we are calling "the software under test." (This distinction is particularly important when conducting integration testing between two modules of code written by two different developers, where only the interfaces are exposed for test.) Grey box testing may also include reverse engineering to determine, for instance, boundary values or error messages.

[edit] Acceptance testing
Main article: acceptance testing
Acceptance testing can mean one of two things:

A smoke test is used as an acceptance test prior to introducing a build to the main testing process.
Acceptance testing performed by the customer is known as user acceptance testing (UAT).


[edit] Regression Testing
Main article: Regression testing
Regression testing is any type of software testing that seeks to uncover software regressions. Such regressions occur whenever software functionality that was previously working correctly stops working as intended. Typically regressions occur as an unintended consequence of program changes. Common methods of regression testing include re-running previously run tests and checking whether previously fixed faults have re-emerged.

[edit] Non Functional Software Testing
Special methods exist to test non-functional aspects of software.

Performance testing checks to see if the software can handle large quantities of data or users. This is generally referred to as software scalability. This activity of Non Functional Software Testing is often times referred to as Load Testing.
Usability testing is needed to check if the user interface is easy to use and understand.
Security testing is essential for software which processes confidential data and to prevent system intrusion by hackers.
Internationalization and localization is needed to test these aspects of software, for which a pseudolocalization method can be used.

In contrast to functional testing, which establishes the correct operation of the software (correct in that it matches the expected behavior defined in the design requirements), non-functional testing verifies that the software functions properly even when it receives invalid or unexpected inputs. Software fault injection, in the form of fuzzing, is an example of non-functional testing. Non-functional testing, especially for software, is designed to establish whether the device under test can tolerate invalid or unexpected inputs, thereby establishing the robustness of input validation routines as well as error-handling routines. Various commercial non-functional testing tools are linked from the Software fault injection page; there are also numerous open-source and free software tools available that perform non-functional testing.

[edit] Testing process
A common practice of software testing is performed by an independent group of testers after the functionality is developed before it is shipped to the customer.[20] This practice often results in the testing phase being used as project buffer to compensate for project delays, thereby compromising the time devoted to testing.[21] Another practice is to start software testing at the same moment the project starts and it is a continuous process until the project finishes.[22]
In counterpoint, some emerging software disciplines such as extreme programming and the agile software development movement, adhere to a "test-driven software development" model. In this process, unit tests are written first, by the software engineers (often with pair programming in the extreme programming methodology). Of course these tests fail initially; as they are expected to. Then as code is written it passes incrementally larger portions of the test suites. The test suites are continuously updated as new failure conditions and corner cases are discovered, and they are integrated with any regression tests that are developed. Unit tests are maintained along with the rest of the software source code and generally integrated into the build process (with inherently interactive tests being relegated to a partially manual build acceptance process).
Testing can be done on the following levels:

Unit testing tests the minimal software component, or module. Each unit (basic component) of the software is tested to verify that the detailed design for the unit has been correctly implemented. In an object-oriented environment, this is usually at the class level, and the minimal unit tests include the constructors and destructors.[23]
Integration testing exposes defects in the interfaces and interaction between integrated components (modules). Progressively larger groups of tested software components corresponding to elements of the architectural design are integrated and tested until the software works as a system. [24]
System testing tests a completely integrated system to verify that it meets its requirements.[25]
System integration testing verifies that a system is integrated to any external or third party systems defined in the system requirements.[citation needed]

Before shipping the final version of software, alpha and beta testing are often done additionally:

Alpha testing is simulated or actual operational testing by potential users/customers or an independent test team at the developers' site. Alpha testing is often employed for off-the-shelf software as a form of internal acceptance testing, before the software goes to beta testing.[citation needed]
Beta testing comes after alpha testing. Versions of the software, known as beta versions, are released to a limited audience outside of the programming team. The software is released to groups of people so that further testing can ensure the product has few faults or bugs. Sometimes, beta versions are made available to the open public to increase the feedback field to a maximal number of future users.[citation needed]

Finally, acceptance testing can be conducted by the end-user, customer, or client to validate whether or not to accept the product. Acceptance testing may be performed as part of the hand-off process between any two phases of development.[citation needed]

[edit] Regression testing
Main article: Regression testing
After modifying software, either for a change in functionality or to fix defects, a regression test re-runs previously passing tests on the modified software to ensure that the modifications haven't unintentionally caused a regression of previous functionality. Regression testing can be performed at any or all of the above test levels. These regression tests are often automated.
More specific forms of regression testing are known as sanity testing, when quickly checking for bizarre behavior, and smoke testing when testing for basic functionality.
Benchmarks may be employed during regression testing to ensure that the performance of the newly modified software will be at least as acceptable as the earlier version or, in the case of code optimization, that some real improvement has been achieved.

[edit] Finding faults

[edit] Finding faults early
It is commonly believed that the earlier a defect is found the cheaper it is to fix it.[26] The following table shows the cost of fixing the defect depending on the stage it was found.[27] For example, if a problem in the requirements is found only post-release, then it would cost 10–100 times more to fix than if it had already been found by the requirements review.





Time Detected


Requirements
Architecture
Construction
System Test
Post-Release


Time Introduced
Requirements
1×
3×
5–10×
10×
10–100×


Architecture
-
1×
10×
15×
25–100×


Construction
-
-
1×
10×
10–25×





[edit] Testing Tools
Program testing and fault detection can be aided significantly by testing tools and debuggers. Types of testing/debug tools include features such as:

Program monitors, permitting full or partial monitoring of program code including:

Instruction Set Simulator, permitting complete instruction level monitoring and trace facilities
Program animation, permitting step-by-step execution and conditional breakpoint at source level or in machine code
code coverage reports


Formatted dump or Symbolic debugging, tools allowing inspection of program variables on error or at chosen points
Benchmarks, allowing run-time performance comparisons to be made
Performance analysis, or profiling tools that can help to highlight hot spots and resource usage

Some of these features may be incorporated into an Integrated development environment (IDE).

[edit] Measuring software testing
Usually, quality is constrained to such topics as correctness, completeness, security,[citation needed] but can also include more technical requirements as described under the ISO standard ISO 9126, such as capability, reliability, efficiency, portability, maintainability, compatibility, and usability.
There are a number of common software measures, often called "metrics", which are used to measure the state of the software or the adequacy of the testing.

[edit] Testing artifacts
Software testing process can produce several artifacts.

Test case 
A test case in software engineering normally consists of a unique identifier, requirement references from a design specification, preconditions, events, a series of steps (also known as actions) to follow, input, output, expected result, and actual result. Clinically defined a test case is an input and an expected result.[28] This can be as pragmatic as 'for condition x your derived result is y', whereas other test cases described in more detail the input scenario and what results might be expected. It can occasionally be a series of steps (but often steps are contained in a separate test procedure that can be exercised against multiple test cases, as a matter of economy) but with one expected result or expected outcome. The optional fields are a test case ID, test step or order of execution number, related requirement(s), depth, test category, author, and check boxes for whether the test is automatable and has been automated. Larger test cases may also contain prerequisite states or steps, and descriptions. A test case should also contain a place for the actual result. These steps can be stored in a word processor document, spreadsheet, database, or other common repository. In a database system, you may also be able to see past test results and who generated the results and the system configuration used to generate those results. These past results would usually be stored in a separate table.


Test script 
The test script is the combination of a test case, test procedure, and test data. Initially the term was derived from the product of work created by automated regression test tools. Today, test scripts can be manual, automated, or a combination of both.


Test data 
The most common test manually or in automation is retesting and regression testing[29], In most cases, multiple sets of values or data are used to test the same functionality of a particular feature. All the test values and changeable environmental components are collected in separate files and stored as test data. It is also useful to provide this data to the client and with the product or a project.


Test suite 
The most common term for a collection of test cases is a test suite. The test suite often also contains more detailed instructions or goals for each collection of test cases. It definitely contains a section where the tester identifies the system configuration used during testing. A group of test cases may also contain prerequisite states or steps, and descriptions of the following tests.


Test plan 
A test specification is called a test plan. The developers are well aware what test plans will be executed and this information is made available to the developers. This makes the developers more cautious when developing their code. This ensures that the developers code is not passed through any surprise test case or test plans.


Test harness 
The software, tools, samples of data input and output, and configurations are all referred to collectively as a test harness.


[edit] A sample testing cycle
Although variations exist between organizations, there is a typical cycle for testing[30]:

Requirements analysis: Testing should begin in the requirements phase of the software development life cycle. During the design phase, testers work with developers in determining what aspects of a design are testable and with what parameters those tests work.
Test planning: Test strategy, test plan, testbed creation. A lot of activities will be carried out during testing, so that a plan is needed.
Test development: Test procedures, test scenarios, test cases, test datasets, test scripts to use in testing software.
Test execution: Testers execute the software based on the plans and tests and report any errors found to the development team.
Test reporting: Once testing is completed, testers generate metrics and make final reports on their test effort and whether or not the software tested is ready for release.
Test result analysis: Or Defect Analysis, is done by the development team usually along with the client, in order to decide what defects should be treated, fixed, rejected (i.e. found software working properly) or deferred to be dealt with at a later time.
Retesting the resolved defects. Once a defect has been dealt with by the development team, it is retested by the testing team.
Regression testing: It is common to have a small test program built of a subset of tests, for each integration of new, modified or fixed software, in order to ensure that the latest delivery has not ruined anything, and that the software product as a whole is still working correctly.
Test Closure:Once the test meets the exit criteria, the activities such as capturing the key outputs, lessons learned, results, logs, documents related to the project are archived and used as a reference for future projects.


[edit] Certification
Several certification programs exist to support the professional aspirations of software testers and quality assurance specialists. No certification currently offered actually requires the applicant to demonstrate the ability to test software. No certification is based on a widely accepted body of knowledge. This has led some to declare that the testing field is not ready for certification.[31] Certification itself cannot measure an individual's productivity, their skill, or practical knowledge, and cannot guarantee their competence, or professionalism as a tester.[32]

Software testing certification types
Certifications can be grouped into: exam-based and education-based.

Exam-based certifications: For these there is the need to pass an exam, which can also be learned by self-study: e.g. for ISTQB or QAI.
Education-based certifications: Education based software testing certifications are instructor-led sessions, where each course has to be passed, e.g. IIST (International Institute for Software Testing).




Testing certifications


CATe offered by the International Institute for Software Testing[33]
CBTS offered by the Brazilian Certification of Software Testing (ALATS)[34]
Certified Software Tester (CSTE) offered by the Quality Assurance Institute (QAI)[35]
Certified Software Test Professional (CSTP) offered by the International Institute for Software Testing[33]
CSTP (TM) (Australian Version) offered by K. J. Ross & Associates[36]
ISEB offered by the Information Systems Examinations Board
ISTQB Certified Tester, Foundation Level (CTFL) offered by the International Software Testing Qualification Board [37][38]
ISTQB Certified Tester, Advanced Level (CTAL) offered by the International Software Testing Qualification Board [37][38]
CBTS offered by the Brazilian Certification of Software Testing (ALATS)[34]
TMPF TMap®[dubious – discuss] Next Foundation offered by theExamination Institute for Information Science[39]




Quality assurance certifications


CSQE offered by the American Society for Quality (ASQ)[40]
CSQA offered by the Quality Assurance Institute (QAI)[35]
CQIA offered by the American Society for Quality (ASQ)[40]
CMSQ offered by the Quality Assurance Institute (QAI)</ref>[41]




[edit] Controversy
Some of the major software testing controversies include:

What constitutes responsible software testing 
Members of the "context-driven" school of testing[42] believe that there are no "best practices" of testing, but rather that testing is a set of skills that allow the tester to select or invent testing practices to suit each unique situation. [43]


Agile vs. traditional 
Should testers learn to work under conditions of uncertainty and constant change or should they aim at process "maturity"? The agile testing movement has received growing popularity since 2006 mainly in commercial circles [44], whereas government and military software providers are slow to embrace this methodology[neutrality disputed], and mostly still hold to CMMI.[45]


Exploratory test vs. scripted[46] 
Should tests be designed at the same time as they are executed or should they be designed beforehand?


Manual testing vs. automated 
Some writers believe that test automation is so expensive relative to its value that it should be used sparingly.[47] Others, such as advocates of agile development, recommend automating 100% of all tests.[citation needed] More in particular, test-driven development states that developers should write unit-tests of the x-unit type before coding the functionality. The tests then can be considered as a way to capture and implement the requirements.


Software design vs. software implementation[48] 
Should testing be carried out only at the end or throughout the whole process?


Who watches the watchmen? 
The idea is that any form of observation is also an interaction, that the act of testing can also affect that which is being tested[49].


[edit] See also




Software Testing portal




Dynamic program analysis
Formal verification
Reverse semantic traceability
Static code analysis
GUI software testing
Web testing
Pair Testing
Wikipedia:Books/Software testing


[edit] References


^ Exploratory Testing, Cem Kaner, Florida Institute of Technology, Quality Assurance Institute Worldwide Annual Software Testing Conference, Orlando, FL, November 2006
^ Software errors cost U.S. economy $59.5 billion annually, NIST report
^ Myers, Glenford J. (1979). The Art of Software Testing. John Wiley and Sons. ISBN 0-471-04328-1. 
^ Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ until 1956 it was the debugging oriented period, when testing was often associated to debugging: there was no clear difference between testing and debugging. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ From 1957-1978 there was the demonstration oriented period where debugging and testing was distinguished now - in this period it was shown, that software satisfies the requirements. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ The time between 1979-1982 is announced as the destruction oriented period, where the goal was to find errors. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ 1983-1987 is classified as the evaluation oriented period: intention here is that during the software lifecycle a product evaluation is provided and measuring quality. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ From 1988 on it was seen as prevention oriented period where tests were to demonstrate that software satisfies its specification, to detect faults and to prevent faults. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ a b c Kaner, Cem; Falk, Jack and Nguyen, Hung Quoc (1999). Testing Computer Software, 2nd Ed.. New York, et al: John Wiley and Sons, Inc.. pp. 480 pages. ISBN 0-471-35846-0. 
^ a b Section 1.1.2, Certified Tester Foundation Level Syllabus, International Software Testing Qualifications Board
^ From 1988 on it was seen as prevention oriented period where tests were to demonstrate that software satisfies its specification, to detect faults and to prevent faults. Gelperin, D.; B. Hetzel (1988). "The Growth of Software Testing". CACM 31 (6). ISSN 0001-0782. 
^ Principle 2, Section 1.3, Certified Tester Foundation Level Syllabus, International Software Testing Qualifications Board
^ Tran, Eushiuan (1999). "Verification/Validation/Certification". in Koopman, P.. Topics in Dependable Embedded Systems. USA: Carnegie Mellon University. 
^ see D. Gelperin and W.C. Hetzel
^ Laycock, G. T. (1993) (PostScript). The Theory and Practice of Specification Based Software Testing. Dept of Computer Science, Sheffield University, UK. http://www.mcs.le.ac.uk/people/gtl1/thesis.ps.gz. Retrieved on 2008-02-13. 
^ Bach, James (June 1999). "Risk and Requirements-Based Testing" (PDF). Computer 32 (6): 113–114. http://www.satisfice.com/articles/requirements_based_testing.pdf. Retrieved on 2008-08-19. 
^ Savenkov, Roman (2008). How to Become a Software Tester. Roman Savenkov Consulting. p. 168. ISBN 978-0-615-23372-7. 
^ Introduction, Code Coverage Analysis, Steve Cornett
^ e)Testing Phase in Software Testing:-
^ Myers, Glenford J. (1979). The Art of Software Testing. John Wiley and Sons. p. 145-146. ISBN 0-471-04328-1. 
^ Dustin, Elfriede (2002). Effective Software Testing. Addison Wesley. p. 3. ISBN 0-20179-429-2. 
^ Binder, Robert V. (1999). Testing Object-Oriented Systems: Objects, Patterns, and Tools. Addison-Wesley Professional. p. 45. ISBN 0-201-80938-9. 
^ Beizer, Boris (1990). Software Testing Techniques (Second Edition ed.). pp. pp.21,430. ISBN 0-442-20672-0. 
^ IEEE (1990). IEEE Standard Computer Dictionary: A Compilation of IEEE Standard Computer Glossaries. New York: IEEE. ISBN 1559370793. 
^ Kaner, Cem; James Bach, Bret Pettichord (2001). Lessons Learned in Software Testing: A Context-Driven Approach. Wiley. p. 4. ISBN 0-471-08112-4. 
^ McConnell, Steve (2004). Code Complete (2nd edition ed.). Microsoft Press. pp. 960. ISBN 0-7356-1967-0. 
^ IEEE (1998). IEEE standard for software test documentation. New York: IEEE. ISBN 0-7381-1443-X. 
^ Rao, Vinayak (Spring 2008), "Software Testing, Interview based theory", Topics in Software testing Interview based theory, SDLC, Software testing educationer, MBA Magadh university, http://knol.google.com/k/vinayak-rao/software-testing-complete-interview/2q3y6fz7t2jis/2?domain=knol.google.com&locale=en# 
^ Pan, Jiantao (Spring 1999), "Software Testing (18-849b Dependable Embedded Systems)", Topics in Dependable Embedded Systems, Electrical and Computer Engineering Department, Carnegie Mellon University, http://www.ece.cmu.edu/~koopman/des_s99/sw_testing/ 
^ Kaner, Cem (2001). "NSF grant proposal to "lay a foundation for significant improvements in the quality of academic and commercial courses in software testing"" (pdf). http://www.testingeducation.org/general/nsf_grant.pdf. 
^ Kaner, Cem (2003). "Measuring the Effectiveness of Software Testers" (pdf). http://www.testingeducation.org/a/mest.pdf. 
^ a b International Institute for Software Testing
^ a b ALATS
^ a b Quality Assurance Institute
^ K. J. Ross & Associates
^ a b "ISTQB". http://www.istqb.org/. 
^ a b "ISTQB in the U.S.". http://www.astqb.org/. 
^ EXIN: Examination Institute for Information Science
^ a b American Society for Quality
^ "Software Certifications (QAI)". http://www.softwarecertifications.org/. 
^ context-driven-testing.com
^ Article on taking agile traits without the agile method.
^ IEEE article about differences in adoption of agile trends between experienced managers vs. young students of the Project Management Institute. See also Agile adoption study from 2007
^ Agile software development practices slowly entering the military
^ IEEE article on Exploratory vs. Non Exploratory testing
^ An example is Mark Fewster, Dorothy Graham: Software Test Automation. Addison Wesley, 1999, ISBN 0-201-33140-3.
^ Article referring to other links questioning the necessity of unit testing
^ Microsoft Development Network Discussion on exactly this topic



[edit] External links



At Wikiversity you can learn more and teach others about Software testing at:
The Department of Software testing




Software testing tools and products at the Open Directory Project
"Software that makes Software better" Economist.com








v • d • e

Major fields of computer science





Theory of computation

Automata · Computability · Computational complexity · Quantum Computing






Algorithms and data structures

Analysis of algorithms · Algorithm design · Computational geometry · Interface






Programming languages

Theory · Compilers / Parsers / Interpreters · Programming paradigms (Declarative · Imperative · Logic · Procedural) · SDLC · Software Distribution






Types of Computation

Cloud computing · Cluster Computing · Distributed computing · Grid computing · Parallel computing






System architecture

Computer architecture · Computer organization · Operating systems · Management information system · Information systems






Telecomm & Networking

Broadcasting · Network topology · OSI model · Cryptography · World Wide Web · Semantic Web · Internetworking · PSTN / SONET · IEEE 802






Security

Intelligence · Encryption · Protocols · Spam · VPN · Online predator · Identity theft · Internet privacy · Trusted Computing · Advertising Ethics · Computer forensics · Computer surveillance · DoD






Databases

Database theory · Data mining · Data modeling · OLAP · Geographic information system






Computer graphics

CGI  · Visualization · Image processing






Scientific computing

Artificial life · Bioinformatics · Cognitive Science · Computational chemistry · Computational neuroscience · Computational physics · Numerical algorithms · Symbolic mathematics






Artificial intelligence

Automated reasoning · Computational linguistics · Computer vision · Evolutionary computation · Machine learning · Natural language processing · Robotics · Cybernetics






BCI / HCI / MMI

Computer accessibility · User interfaces · Wearable computing · Ubiquitous computing · Mixed reality






NOTE: Computer science can also be split up into different topics or fields according to the ACM Computing Classification System.












v • d • e

Software engineering





Fields

Requirements analysis • Software design • Computer programming • Formal methods • Software testing • Software deployment • Software maintenance






Concepts

Data modeling • Enterprise architecture • Functional specification • Modeling language • Programming paradigm • Software • Software architecture • Software development methodology • Software development process • Software quality • Software quality assurance • Structured analysis






Orientations

Agile • Aspect-oriented • Object orientation • Ontology • Service orientation • SDLC






Models

Development models: Agile • Iterative model • RUP • Scrum • Spiral model • Waterfall model • XP • V-Model
Other models: CMMI • Data model • Function model • IDEF • Information model • Metamodeling • Object model • View model • UML






Software
engineers

Kent Beck • Grady Booch • Fred Brooks • Barry Boehm • Ward Cunningham • Ole-Johan Dahl • Tom DeMarco • Edsger W. Dijkstra • Martin Fowler • C. A. R. Hoare • Watts Humphrey • Michael A. Jackson • Ivar Jacobson • Craig Larman • James Martin • Bertrand Meyer • David Parnas • Winston W. Royce • James Rumbaugh • Niklaus Wirth • Edward Yourdon






Related fields

Computer science • Computer engineering • Enterprise engineering • History • Management • Mathematics • Project management • Quality management • Software ergonomics • Systems engineering









Retrieved from "http://en.wikipedia.org/wiki/Software_testing"
Categories: Software development process | Software testingHidden categories: All articles with unsourced statements | Articles with unsourced statements since August 2008 | Articles with unsourced statements since December 2007 | Articles with unsourced statements since January 2008 | Articles with unsourced statements since March 2008 | All pages needing cleanup | Articles with disputed statements from December 2008 | Articles with minor POV problems from February 2009 | Articles with unsourced statements since March 2009 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


العربية
Беларуская (тарашкевіца)
Česky
Deutsch
Eesti
Español
فارسی
Français
한국어
Italiano
עברית
Magyar
Bahasa Melayu
Nederlands
日本語
‪Norsk (bokmål)‬
Polski
Português
Română
Русский
Slovenčina
Svenska
தமிழ்
ไทย
Українська
中文









 This page was last modified on 7 April 2009, at 05:33.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
