













Breadth-first search - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Breadth-first_search";
		var wgTitle = "Breadth-first search";
		var wgAction = "view";
		var wgArticleId = "97026";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 279189359;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Breadth-first search

From Wikipedia, the free encyclopedia

Jump to: navigation, search 

Breadth-first search




Order in which the nodes are expanded


Class
Search Algorithm


Data structure
Graph


Worst case performance
O( | V | + | E | ) = O(bd)


Worst case space complexity
O( | V | + | E | ) = O(bd)


Optimal
yes (for unweighted graphs)



This box: view • talk





Graph search algorithms


Search

A*
B*
Bellman-Ford algorithm
Best-first search
Bidirectional search
Breadth-first search
D*
Depth-first search
Depth-limited search
Dijkstra's algorithm
Floyd–Warshall algorithm
Hill climbing
Iterative deepening depth-first search
Johnson's algorithm
Uniform-cost search




In graph theory, breadth-first search (BFS) is a graph search algorithm that begins at the root node and explores all the neighboring nodes. Then for each of those nearest nodes, it explores their unexplored neighbor nodes, and so on, until it finds the goal.




Contents


1 How it works
2 Algorithm (informal)
3 Implementation

3.1 Python
3.2 C
3.3 C++
3.4 C# and Java


4 Features

4.1 Space Complexity
4.2 Time Complexity
4.3 Completeness
4.4 Optimality


5 Applications of BFS

5.1 Finding connected Components
5.2 Testing bipartiteness


6 Literature
7 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] How it works
BFS is an uninformed search method that aims to expand and examine all nodes of a graph or combinations of sequence by systematically searching through every solution. In other words, it exhaustively searches the entire graph or sequence without considering the goal until it finds it. It does not use a heuristic.
From the standpoint of the algorithm, all child nodes obtained by expanding a node are added to a FIFO queue. In typical implementations, nodes that have not yet been examined for their neighbors are placed in some container (such as a queue or linked list) called "open" and then once examined are placed in the container "closed".







An example map of Germany with some connections between cities.









The breadth-first tree obtained when running BFS on the given map and starting in Frankfurt.









Animated example of a breadth-first search






[edit] Algorithm (informal)

Enqueue the root node.
Dequeue a node and examine it.

If the element sought is found in this node, quit the search and return a result.
Otherwise enqueue any successors (the direct child nodes) that have not yet been examined.


If the queue is empty, every node on the graph has been examined -- quit the search and return "not found".
Repeat from Step 2.

Note: Using a stack instead of a queue to store the nodes yet to be visited would turn this algorithm into a depth-first search.

[edit] Implementation

[edit] Python
Assume we have a graph made up of Node objects, each containing a value and a list of child Node objects:


class Node:
    """Simple structure for nodes in a graph."""
    def __init__(self, value, neighbors = None):
        if neighbors is None: neighbors = []
        self.value = value
        self.neighbors = neighbors

Then this function performs a breadth-first search on that graph whenIn graph theory, breadth-first search (BFS) is a graph search algorithm that begins at the root node and explores all the neighboring nodes. Then for each of those nearest nodes, it explores their unexplored neighbor nodes, and so on, until it finds the goal.


from collections import deque
def bfs(top_node,
        visit_function = lambda x: None,
        visited = None):
    """Breadth-first search on a graph, starting at top_node.
    Given the graph's root node (a Node instance) and a function
    to apply to each node in the graph.
    """
    if visited is None: visited = set()
    queue = deque([top_node])
    while queue:
        curr_node = queue.popleft()          # Dequeue
        if curr_node not in visited:         # Skip visited nodes
            visit_function(curr_node)        # Visit the node
            visited.add(curr_node)
            queue.extend(curr_node.neighbors) # Enqueue the neighbors

For example, this script finds the sum of the integer values of each node in the graph:


# Build an example graph
the_graph = Node(1, [Node(1, [Node(2), Node(3)]),
                     Node(5, [Node(8, [Node(13)]),
                              Node(21, [Node(34), Node(55)])])])
 
# Define a "visit" function
total = 0
def sum_graph(node):
    global total
    total += node.value
 
# Visit the whole graph
bfs(the_graph, sum_graph)
print total


[edit] C
Algorithm of Breadth-first search：


 void BFS(VLink G[], int v) { 
   int w;
   VISIT(v);                    /*visit vertex v*/
   visited[v] = 1;              /*mark v as visited : 1 */
   ADDQ(Q,v);
   while(!EMPTYQ(Q)) { 
     v = DELQ(Q);               /*Dequeue v*/
     w = FIRSTADJ(G,v);         /*Find first neighbor, return -1 if no neighbor*/
     while(w != -1) { 
       if(visited[w] == 0) { 
         VISIT(w);              /*visit vertex w*/
         ADDQ(Q,w);             /*Enqueue current visited vertex w*/
         visited[w] = 1;        /*mark w as visited*/
       }
       w = NEXTADJ(G,v);        /*Find next neighbor, return -1 if no neighbor*/
     }
   }  
 }

Main Algorithm of apply Breadth-first search to graph G=(V,E)：


 void TRAVEL_BFS(VLink G[], int visited[], int n) { 
   int i;
   for(i = 0; i < n; i ++) {
     visited[i] = 0;            /* Mark initial value as 0 */
   }
   for(i = 0; i < n; i ++)
     if(visited[i] == 0)
       BFS(G,i);
 }


[edit] C++
This is the implementation of the above informal algorithm, where the "so-far-unexamined" is handled by the parent array. For actual C++ applications, see the Boost Graph Library.

Suppose we have a struct:



struct Vertex {
 	/* Some code */
 	std::vector<int> out;
 	/* Some more code */
 };


and an array of vertices: (the algorithm will use the indices of this array, to handle the vertices)



std::vector<Vertex> graph(vertices);


the algorithm starts from start and returns true if there is a directed path from start to end:



 bool BFS(const std::vector<Vertex>& graph, int start, int end) {
   std::queue<int> next;
   std::vector<int> parent(graph.size(), -1) ;
   next.push(start);
   parent[start] = start;
   while (!next.empty()) {
     int u = next.front();
     next.pop();
     // Here is the point where you can examine the u th vertex of graph
     // For example:
     if (u == end) return true;
     for (std::vector<int>::const_iterator j = graph[u].out.begin(); j != graph[u].out.end(); ++j) {
       // Look through neighbors.
       int v = *j;
       if (parent[v] == -1) {
         // If v is unvisited.
         parent[v] = u;
         next.push(v);
       }
     }
   }
   return false;
 }


it also stores the parents of each node, from which you can get the path.


[edit] C# and Java


class Node {
 
	Node[] Children;
 
}
 
/// <summary>Prints out all the children of graph fragment <paramref name="n" /> to Console in breadth-first order</summary>
public static void BreadthFirstSearch(Node n) {
 
	// 'Queue' can be any Queue-like structure that implements Enqueue, Dequeue, and exposes a Count (Length) property
	Queue q = new Queue();
	q.Enqueue( n );
 
	while( q.Count > 0 ) {
		Node m = q.Dequeue();
 
		// Perform task on m here. For example, printing it out to the console:
		Console.WriteLine( m + ", " );
 
		foreach(Node child in m.Children) {
			q.Enqueue( child );
		}
	}
 
}



[edit] Features


Graph search algorithms


Search

A*
B*
Bellman-Ford algorithm
Best-first search
Bidirectional search
Breadth-first search
D*
Depth-first search
Depth-limited search
Dijkstra's algorithm
Floyd–Warshall algorithm
Hill climbing
Iterative deepening depth-first search
Johnson's algorithm
Uniform-cost search





[edit] Space Complexity
Since all of the nodes of a level must be saved until their child nodes in the next level have been generated, the space complexity is proportional to the number of nodes at the deepest level. Given a branching factor b and graph depth d the asymptotic space complexity is the number of nodes at the deepest level, O(bd). When the number of vertices and edges in the graph are known ahead of time, the space complexity can also be expressed as O( | E | + | V | ) where | E | is the cardinality of the set of edges (the number of edges), and | V | is the cardinality of the set of vertices. In the worst case the graph has a depth of 1 and all vertices must be stored. Since it is exponential in the depth of the graph, breadth-first search is often impractical for large problems on systems with bounded space.

[edit] Time Complexity
Since in the worst case breadth-first search has to consider all paths to all possible nodes the time complexity of breadth-first search is b + b2 + b3 + ... + bd which asymptotically approaches O(bd). The time complexity can also be expressed as O( | E | + | V | ) since every vertex and every edge will be explored in the worst case.

[edit] Completeness
Breadth-first search is complete. This means that if there is a solution breadth-first search will find it regardless of the kind of graph. However, if the graph is infinite and there is no solution breadth-first search will diverge.

[edit] Optimality
For unit-step cost, breadth-first search is optimal. In general breadth-first search is not optimal since it always returns the result with the fewest edges between the start node and the goal node. If the graph is a weighted graph, and therefore has costs associated with each step, a goal next to the start does not have to be the cheapest goal available. This problem is solved by improving breadth-first search to uniform-cost search which considers the path costs. Nevertheless, if the graph is not weighted, and therefore all step costs are equal, breadth-first search will find the nearest and the best solution.

[edit] Applications of BFS
Breadth-first search can be used to solve many problems in graph theory, for example:

Finding all connected components in a graph.
Finding all nodes within one connected component
Copying Collection, Cheney's algorithm
Finding the shortest path between two nodes u and v (in an unweighted graph)
Finding the shortest path between two nodes u and v (in a weighted graph: see talk page)
Testing a graph for bipartiteness
(Reverse) Cuthill–McKee mesh numbering


[edit] Finding connected Components
The set of nodes reached by a BFS (breadth-first search) form the largest connected component containing the starting node.

[edit] Testing bipartiteness
BFS can be used to test bipartiteness, by starting the search at any vertex and giving alternating labels to the vertices visited during the search. That is, give label 0 to the starting vertex, 1 to all its neighbours, 0 to those neighbours' neighbours, and so on. If at any step a vertex has (visited) neighbours with the same label as itself, then the graph is not bipartite. If the search ends without such a situation occurring, then the graph is bipartite.

[edit] Literature
Knuth, Donald E. (1997), The Art Of Computer Programming Vol 1. 3rd ed., Boston: Addison-Wesley, ISBN 0-201-89683-4, http://www-cs-faculty.stanford.edu/~knuth/taocp.html 

[edit] External links





This article's external links may not follow Wikipedia's content policies or guidelines. Please improve this article by removing excessive or inappropriate external links.



Breadth-First shortest-route search implemented in T-SQL by Martin Withaar




Retrieved from "http://en.wikipedia.org/wiki/Breadth-first_search"
Categories: Graph algorithms | Search algorithmsHidden categories: Wikipedia external links cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Česky
Deutsch
Español
فارسی
Français
Italiano
עברית
Lietuvių
Nederlands
日本語
Polski
Português
Русский
Українська
中文









 This page was last modified on 23 March 2009, at 17:39.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
