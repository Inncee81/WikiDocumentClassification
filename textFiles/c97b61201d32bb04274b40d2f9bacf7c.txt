













Resource Acquisition Is Initialization - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Resource_Acquisition_Is_Initialization";
		var wgTitle = "Resource Acquisition Is Initialization";
		var wgAction = "view";
		var wgArticleId = "693532";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 282839483;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ruby {line-height: normal;}
.source-ruby li, .source-ruby pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ruby
 * CSS class: source-ruby, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ruby .de1, .source-ruby .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ruby  {}
.source-ruby .head {}
.source-ruby .foot {}
.source-ruby .imp {font-weight: bold; color: red;}
.source-ruby .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ruby li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ruby li.li2 {font-weight: bold;}
.source-ruby .kw1 {color:#9966CC; font-weight:bold;}
.source-ruby .kw2 {color:#0000FF; font-weight:bold;}
.source-ruby .kw3 {color:#CC0066; font-weight:bold;}
.source-ruby .kw4 {color:#CC00FF; font-weight:bold;}
.source-ruby .co1 {color:#008000; font-style:italic;}
.source-ruby .coMULTI {color:#000080; font-style:italic;}
.source-ruby .es0 {color:#000099;}
.source-ruby .br0 {color:#006600; font-weight:bold;}
.source-ruby .st0 {color:#996600;}
.source-ruby .nu0 {color:#006666;}
.source-ruby .me1 {color:#9900CC;}
.source-ruby .sc0 {}
.source-ruby .sc1 {}
.source-ruby .sc2 {}
.source-ruby .re0 {color:#ff6633; font-weight:bold;}
.source-ruby .re1 {color:#0066ff; font-weight:bold;}
.source-ruby .re2 {color:#6666ff; font-weight:bold;}
.source-ruby .re3 {color:#ff3333; font-weight:bold;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Resource Acquisition Is Initialization

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article may require cleanup to meet Wikipedia's quality standards. Please improve this article if you can. (March 2007)


Resource Acquisition Is Initialization, often referred to by the acronym RAII, is a popular design pattern in several object oriented programming languages like C++, D and Ada. The technique, invented by Bjarne Stroustrup[1], ensures that when resources are acquired they are properly released by tying them to the lifespan of suitable objects: resources are acquired during the initialization of objects, when there is no chance of using them before the resource is available, and released with the destruction of the same objects, which is guaranteed to take place even in case of errors.
In C++, objects residing on the stack are automatically destroyed when the enclosing scope is exited, including the case of exceptions [2]; their destructor is called before the exception propagates.
RAII helps in writing exception-safe code: to release resources before permitting exceptions to propagate (in order to avoid resource leaks) one can write appropriate destructors once rather than dispersing and duplicating cleanup logic between exception handling blocks.




Contents


1 Language Support
2 Typical uses
3 Mutability (C++)
4 C++ example
5 Resource management without RAII
6 References
7 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Language Support
C++ and D allow objects to be allocated on the stack and their scoping rules ensure that destructors are called when a local object's scope ends. By putting the resource release logic in the destructor, C++'s and D's scoping provide direct support for RAII.

[edit] Typical uses
The RAII technique is often used for controlling thread locks in multi-threaded applications. In that use, the object releases the lock, if held, when destroyed. Another typical example is file management, wherein the file class closes the associated file, if open, when destroyed.
The ownership of dynamically allocated memory (such as memory allocated with new in C++ code) can be controlled with RAII, such that the memory is released when the RAII object is destroyed. For this purpose, the C++ Standard Library defines the smart pointer class std::auto_ptr. Furthermore, smart pointer with shared-ownership semantics such as boost::shared_ptr (defined in C++ by Boost and marked for inclusion in the new C++0x standard), or policy based smart pointers such as Loki::SmartPtr (from Loki), can also be used to manage lifetime of shared objects.

[edit] Mutability (C++)
In C++, an important consideration of classes that implement RAII is their mutability[3]. A class exhibiting mutable RAII provides facilities for instances to be assigned a new resource; one that exhibits immutable RAII does not. An example of the former is std::auto_ptr; examples of the latter are the STLSoft library's stlsoft::scoped_handle and Boost.SmartPtr's boost::scoped_ptr.
Classes exhibiting immutable RAII are considerably easier to implement in C++, since the design need not account for assignment (including copy-assignment), except to explicitly prohibit it. Consider the following RAII class template that illustrates the simplicity of implementing immutable RAII. Compare this with the implementation of std::auto_ptr or another mutable RAII smart pointer, which will have many more member functions and logic to handle premature release in cases of self-assignment.


template <typename T>
class immutable_scoped_ptr
{
public:
    explicit immutable_scoped_ptr(T* t) throw()
        : t_(t)
    { }
 
    ~immutable_scoped_ptr() throw() { delete t_; }
 
    T& operator *() const throw() { return *t_; }
 
    T* operator ->() const throw() { return t_; }
 
private:
    T* const t_;
 
    // prevent copying and assignment; not implemented
    immutable_scoped_ptr(const immutable_scoped_ptr&);
    immutable_scoped_ptr& operator= (const immutable_scoped_ptr&);
};


[edit] C++ example
The following RAII class is a lightweight wrapper of the C standard library file system calls.


#include <cstdio>
#include <stdexcept> // std::runtime_error
class file
{
public:
    file (const char* filename)
        : file_(std::fopen(filename, "w+"))
    {
        if (!file_)
            throw std::runtime_error("file open failure");
    }
 
    ~file()
    {
        if (0 != std::fclose(file_)) // failed to flush latest changes?
        {
            // handle it
        }
    }
 
    void write (const char* str)
    {
        if (EOF == std::fputs(str, file_))
            throw std::runtime_error("file write failure");
    }
 
private:
    std::FILE* file_;
 
    // prevent copying and assignment; not implemented
    file (const file &);
    file & operator= (const file &);
};

Class file can then be used as follows:


void example_usage()
{
    file logfile("logfile.txt"); // open file (acquire resource)
    logfile.write("hello logfile!");
    // continue using logfile ...
    // throw exceptions or return without worrying about closing the log;
    // it is closed automatically when logfile goes out of scope
}

This works because the class file encapsulates the management of the FILE* file handle. When objects file are local to a function, C++ guarantees that they are destroyed at the end of the enclosing scope (the function in the example), and the file destructor releases the file by calling std::fclose(file_). Furthermore, file instances guarantee that a file is available by throwing an exception if the file could not be opened when creating the object.
Local variables easily manage multiple resources within a single function: They are destroyed in the reverse order of their construction, and an object is only destroyed if fully constructed. That is, if no exception propagates from its constructor.
Using RAII-enabled resources simplifies and reduces overall code size and helps ensure program correctness.

[edit] Resource management without RAII
In Java, objects are not allocated on the stack and must be accessed through references; hence you cannot have automatic variables of objects that "go out of scope." Instead, all objects are dynamically allocated. In principle, dynamic allocation does not make RAII unfeasible per se; it could still be feasible if there were a guarantee that a "destructor" ("finalize") method would be called as soon as an object were pointed to by no references (i.e., if the object lifetime management were performed according to reference counting).
However, Java objects have indefinite lifetimes which cannot be controlled by the programmer, because, according to the Java Virtual Machine specification, it is unpredictable when the garbage collector will act. Indeed, the garbage collector may even never act at all to collect objects pointed to by no references. Hence the "finalize" method of an unreferenced object might be never called or called only long after the object became unreferenced. Resources must thus be closed manually by the programmer.
The preceding example would be written like this:


void java_example() {
    // open file (acquire resource)
    final LogFile logfile = new LogFile("logfile.txt");
 
    try {
        logfile.write("hello logfile!");
 
        // continue using logfile ...
        // throw exceptions or return without worrying about closing the log;
        // it is closed automatically when exiting this block
    } finally {
        // explicitly release the resource
        logfile.close();
    }
}

The burden of releasing resources falls on the programmer each time a resource is used.
Ruby and Smalltalk do not support RAII, but have a simpler and more flexible pattern that makes use of methods that pass resources to closure blocks. Here is an example in Ruby:


File.open("logfile.txt", "w+") do |logfile|
   logfile.write("hello logfile!")
end

The open method ensures that the file handle is closed without special precautions by the code writing to the file. This is similar to Common Lisp's 'unwind-protect'-based macros.
Python's 'with' statement and the 'using' statement in C# and Visual Basic 2005 provide deterministic resource management within a block and do away with the requirement for explicit finally-based cleanup and release.
Perl manages object lifetime by reference counting, making it possible to use RAII in a limited form. Objects that are no longer referenced are immediately released, so a destructor can release the resource at that time. However, object lifetime isn't necessarily bound to any lexical scope. One can store a reference to an object in a global variable, for example, thus keeping the object (and resource) alive indeterminately long. This makes it possible to accidentally leak resources that should have been released at the end of some scope.
C requires significant administrative code since it doesn't support exceptions, try-finally blocks or RAII of any kind. A typical approach is to separate releasing of resources at the end of the function and jump there with gotos in the case of error. This way the cleanup code need not be duplicated.


int c_example() {
    int retval = 0; // return value 0 is success
    FILE *f = fopen("logfile.txt", "w+");
    if (!f) {
        retval = -1;
        goto bailout1;
    }
    if (fputs("hello logfile!", f) == EOF) {
        retval = -2;
        goto bailout2;
    }
 
    // continue using the file resource
 
    // Releasing resources (in reverse order)
  bailout2:
    if (fclose(f) == EOF) {
        retval = -3;
    }
 
  bailout1:
    return retval;
}

Variations exist, but the example illustrates the general approach.

[edit] References


^ Stroustrup, Bjarne (1994). The Design and Evolution of C++. Addison-Wesley. ISBN 0-201-54330-3. 
^ Bjarne Stroustrup (April 2001) (PDF). Exception Safety: Concepts and Techniques. http://www.research.att.com/~bs/except.pdf. Retrieved on 2007-09-02. 
^ Wilson, Matthew (2004). Imperfect C++. Addison-Wesley. ISBN 0-321-22877-4. 



[edit] External links



The Wikibook Visual Basic has a page on the topic of
RAII in VB6






The Wikibook More C++ Idioms has a page on the topic of
Resource Acquisition Is Initialization




Article "The RAII Programming Idiom" by Wikipedia editor Jon Hanna (Talliesin)
Wiki "Resource Acquisition Is Initialization" from the Portland Pattern Repository
Sample Chapter "Gotcha #67: Failure to Employ Resource Acquisition Is Initialization" by Stephen Dewhurst
Interview "A Conversation with Bjarne Stroustrup" by Bill Venners
Article "The Law of The Big Two" by Bjorn Karlsson and Matthew Wilson
Blog Entry "RAII in C++" by Jonathan Dodds
Article "Implementing the 'Resource Acquisition is Initialization' Idiom" by Danny Kalev
Article "RAII" by Mike Nordell
Article "RAII, Dynamic Objects, and Factories in C++" by Roland Pibinger
Article "Managing Dynamic Objects in C++" by Tom Cargill
Blog "tombarta RAII"
Blog Entry "RAII C++ Anti-Pattern"
Article "Smart pointers in C++" by Julio M. Merino Vidal
Blog Entry "Resource Management: A Critical Look at RAII" by Michael Feathers




Retrieved from "http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"
Categories: Object-oriented programming | Articles with example C++ codeHidden categories: Cleanup from March 2007 | All pages needing cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Deutsch
Français
日本語
Polski
Português
Русский









 This page was last modified on 9 April 2009, at 20:30 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
