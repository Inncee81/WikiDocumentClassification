













C (programming language) - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "C_(programming_language)";
		var wgTitle = "C (programming language)";
		var wgAction = "view";
		var wgArticleId = "6021";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 281986988;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [""];
		var wgRestrictionMove = [""];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-text .de1, .source-text .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-text  {}
.source-text .head {}
.source-text .foot {}
.source-text .imp {font-weight: bold; color: red;}
.source-text .ln-xtra {color: #cc0; background-color: #ffc;}
.source-text li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-text li.li2 {font-weight: bold;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); C (programming language)

From Wikipedia, the free encyclopedia

Jump to: navigation, search 

C


The C Programming Language (aka "K&R") is the seminal book on C.


Paradigm
imperative (procedural), structured


Appeared in
1972


Designed by
Dennis Ritchie


Developer
Dennis Ritchie & Bell Labs


Typing discipline
static, weak, manifest


Major implementations
GCC, MSVC, Borland C, Watcom C


Influenced by
B (BCPL,CPL), ALGOL 68,[1] Assembly, PL/I, FORTRAN


Influenced
awk, csh, C++, C#, Objective-C, BitC, D, Java, JavaScript, Limbo, Perl, PHP


C is a general-purpose computer programming language developed in 1972 by Dennis Ritchie at the Bell Telephone Laboratories to implement the Unix operating system.[2]
Although C was designed for writing architecturally independent system software,[3] it is also widely used for developing application software.
Worldwide, C is the first or second most popular language in terms of number of developer positions or publicly available code.[4][5] It is widely used on many different software platforms, and there are few computer architectures for which a C compiler does not exist. C has greatly influenced many other popular programming languages, most notably C++, which originally began as an extension to C, and Java and C# which borrow C lexical conventions and operators.




Contents


1 Philosophy

1.1 Minimalism


2 Characteristics

2.1 Absent features
2.2 Undefined behavior


3 History

3.1 Early developments
3.2 K&R C
3.3 ANSI C and ISO C
3.4 C99


4 Uses
5 Syntax

5.1 Operators


6 "Hello, world" example
7 Data structures

7.1 Pointers
7.2 Arrays
7.3 Array-pointer interchangeability


8 Memory management
9 Libraries
10 Deficiencies
11 Language tools
12 Related languages
13 See also
14 Footnotes
15 References
16 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Philosophy
C is an imperative (procedural) systems implementation language. It was designed to be compiled using a relatively straightforward compiler, to provide low-level access to memory, to provide language constructs that map efficiently to machine instructions, and to require minimal run-time support. C was therefore useful for many applications that had formerly been coded in assembly language.
Despite its low-level capabilities, the language was designed to encourage machine-independent programming. A standards-compliant and portably written C program can be compiled for a very wide variety of computer platforms and operating systems with little or no change to its source code, while approaching highest performance. The language has become available on a very wide range of platforms, from embedded microcontrollers to supercomputers.

[edit] Minimalism
C is designed to provide high-level abstracts for all the native features of a general-purpose CPU, while at the same time allowing modularization, structure, and code re-use. Features specific to a particular program's function (features that are not general to all platforms) are not included in the language or library definitions. However any such specific functions are implementable and accessible as external reusable libraries, in order to encourage module dissemination and re-use. C is somewhat strongly typed (emitting warnings or errors) but allows programmers to override types in the interests of flexibility, simplicity or performance; while being natural and well-defined in its interpretation of type overrides.
C's design is tied to its intended use as a portable systems implementation language. Consequently, it does not require run-time checks for conditions that would never occur in correct programs, it provides simple, direct access to any addressable object (for example, memory-mapped device control registers), and its source-code expressions can be translated in a straightforward manner to primitive machine operations in the executable code. Some early C compilers were comfortably implemented (as a few distinct passes communicating via intermediate files) on PDP-11 processors having only 16 address bits; however, C99 assumes a 512 KB minimum compilation platform.

[edit] Characteristics
Like most imperative languages in the ALGOL tradition, C has facilities for structured programming and allows lexical variable scope and recursion, while a static type system prevents many unintended operations. In C, all executable code is contained within functions. Function parameters are always passed by value. Pass-by-reference is achieved in C by explicitly passing pointer values. Heterogeneous aggregate data types (struct) allow related data elements to be combined and manipulated as a unit. C program source text is free-format, using the semicolon as a statement terminator (not a delimiter).
C also exhibits the following more specific characteristics:

non-nestable function definitions
variables may be hidden in nested blocks
partially weak typing; for instance, characters can be used as integers
low-level access to computer memory by converting machine addresses to typed pointers
function and data pointers supporting ad hoc run-time polymorphism
array indexing as a secondary notion, defined in terms of pointer arithmetic
a preprocessor for macro definition, source code file inclusion, and conditional compilation
complex functionality such as I/O, string manipulation, and mathematical functions consistently delegated to library routines
A relatively small set of reserved keywords (37 in C99; only 28 were listed in the original, printed "Reference Manual"[6])
A lexical structure that resembles B more than ALGOL, for example

{ ... } rather than ALGOL's begin ... end
the equal-sign is for assignment (copying), much like Fortran
two consecutive equal-signs are to test for equality (compare to .EQ. in Fortran or the equal-sign in BASIC)
&& and || in place of ALGOL's and and or (these are semantically distinct from the bit-wise operators & and | because they will never evaluate the right operand if the result can be determined from the left alone (short-circuit evaluation)).
a large number of compound operators, such as +=, ++, etc.




[edit] Absent features
The relatively low-level nature of the language affords the programmer close control over what the computer does, while allowing special tailoring and aggressive optimization for a particular platform. This allows the code to run efficiently on very limited hardware, such as embedded systems.
C does not have some features that are available in some other programming languages:

No assignment of arrays or strings (copying can be done via standard functions; assignment of objects having struct or union type is supported)
No automatic garbage collection
No requirement for bounds checking of arrays
No operations on whole arrays
No syntax for ranges, such as the A..B notation used in several languages
Prior to C99, no separate Boolean type (zero/nonzero is used instead)[7]
No formal closures or functions as parameters (only function and variable pointers)
No generators or coroutines; intra-thread control flow consists of nested function calls, except for the use of the longjmp or setcontext library functions
No exception handling; standard library functions signify error conditions with the global errno variable and/or special return values
Only rudimentary support for modular programming
No compile-time polymorphism in the form of function or operator overloading
Only rudimentary support for generic programming
Very limited support for object-oriented programming with regard to polymorphism and inheritance
Limited support for encapsulation
No native support for multithreading and networking
No standard libraries for computer graphics and several other application programming needs

A number of these features are available as extensions in some compilers, or can be supplied by third-party libraries, or can be simulated by adopting certain coding disciplines.

[edit] Undefined behavior
Many operations in C that have undefined behavior are not required to be diagnosed at compile time. In the case of C, "undefined behavior" means that the exact behavior which arises is not specified by the standard, and exactly what will happen does not have to be documented by the C implementation. A famous, although misleading, expression in the newsgroups comp.std.c and comp.lang.c is that the program could cause "demons to fly out of your nose".[8] Sometimes in practice what happens for an instance of undefined behavior is a bug that is hard to track down and which may corrupt the contents of memory. Sometimes a particular compiler generates reasonable and well-behaved actions that are completely different from those that would be obtained using a different C compiler. The reason some behavior has been left undefined is to allow compilers for a wide variety of instruction set architectures to generate more efficient executable code for well-defined behavior, which was deemed important for C's primary role as a systems implementation language; thus C makes it the programmer's responsibility to avoid undefined behavior. Examples of undefined behavior are:

accessing outside the bounds of an array
overflowing a signed integer
reaching the end of a non-void function without finding a return statement, when the return value is used
reading the value of a variable before initializing it

These operations are all programming errors that could occur using many programming languages; C draws criticism because its standard explicitly identifies numerous cases of undefined behavior, including some where the behavior could have been made well defined, and does not specify any run-time error handling mechanism.
Invoking fflush() on a stream opened for input is an example of a different kind of undefined behavior, not necessarily a programming error but a case for which some conforming implementations may provide well-defined, useful semantics (in this example, presumably discarding input through the next new-line) as an allowed extension. Use of such nonstandard extensions generally limits software portability.

[edit] History

[edit] Early developments
The initial development of C occurred at AT&T Bell Labs between 1969 and 1973; according to Ritchie, the most creative period occurred in 1972. It was named "C" because many of its features were derived from an earlier language called "B", which according to Ken Thompson was a stripped-down version of the BCPL programming language.
The origin of C is closely tied to the development of the Unix operating system, originally implemented in assembly language on a PDP-7 by Ritchie and Thompson, incorporating several ideas from colleagues. Eventually they decided to port the operating system to a PDP-11. B's lack of functionality to take advantage of some of the PDP-11's features, notably byte addressability, led to the development of an early version of the C programming language.
The original PDP-11 version of the Unix system was developed in assembly language. By 1973, with the addition of struct types, the C language had become powerful enough that most of the Unix kernel was rewritten in C. This was one of the first operating system kernels implemented in a language other than assembly. (Earlier instances include the Multics system (written in PL/I), and MCP (Master Control Program) for the Burroughs B5000 written in ALGOL in 1961.)

[edit] K&R C
In 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language. This book, known to C programmers as "K&R", served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as "K&R C". The second edition of the book covers the later ANSI C standard.
K&R introduced several language features:

standard I/O library
long int data type
unsigned int data type
compound assignment operators =op were changed to op= to remove the semantic ambiguity created by the construct i=-10, which had been interpreted as i =- 10 instead of the possibly intended i = -10

Even after the publication of the 1989 C standard, for many years K&R C was still considered the "lowest common denominator" to which C programmers restricted themselves when maximum portability was desired, since many older compilers were still in use, and because carefully written K&R C code can be legal Standard C as well.
In early versions of C, only functions that returned a non-integer value needed to be declared if used before the function definition; a function used without any previous declaration was assumed to return an integer, if its value was used.
For example:


long int SomeFunction();
/* int OtherFunction(); */
 
/* int */ CallingFunction()
{
    long int test1;
    register /* int */ test2;
 
    test1 = SomeFunction();
    if (test1 > 0) 
          test2 = 0;
    else 
          test2 = OtherFunction();
 
    return test2;
}

All the above commented-out int declarations could be omitted in K&R C.
Since K&R function declarations did not include any information about function arguments, function parameter type checks were not performed, although some compilers would issue a warning message if a local function was called with the wrong number of arguments, or if multiple calls to an external function used different numbers or types of arguments. Separate tools such as Unix's lint utility were developed that (among other things) could check for consistency of function use across multiple source files.
In the years following the publication of K&R C, several unofficial features were added to the language, supported by compilers from AT&T and some other vendors. These included:

void functions
functions returning struct or union types (rather than pointers)
assignment for struct data types
enumerated types

The large number of extensions and lack of agreement on a standard library, together with the language popularity and the fact that not even the Unix compilers precisely implemented the K&R specification, led to the necessity of standardization.

[edit] ANSI C and ISO C
Main article: ANSI C
During the late 1970s and 1980s, versions of C were implemented for a wide variety of mainframe computers, minicomputers, and microcomputers, including the IBM PC, as its popularity began to increase significantly.
In 1983, the American National Standards Institute (ANSI) formed a committee, X3J11, to establish a standard specification of C. In 1989, the standard was ratified as ANSI X3.159-1989 "Programming Language C." This version of the language is often referred to as ANSI C, Standard C, or sometimes C89.
In 1990, the ANSI C standard (with formatting changes) was adopted by the International Organization for Standardization (ISO) as ISO/IEC 9899:1990, which is sometimes called C90. Therefore, the terms "C89" and "C90" refer to the same programming language.
ANSI, like other national standards bodies, no longer develops the C standard independently, but defers to the ISO C standard. National adoption of updates to the international standard typically occurs within a year of ISO publication.
One of the aims of the C standardization process was to produce a superset of K&R C, incorporating many of the unofficial features subsequently introduced. The standards committee also included several additional features such as function prototypes (borrowed from C++), void pointers, support for international character sets and locales, and preprocessor enhancements. The syntax for parameter declarations was also augmented to include the style used in C++, although the K&R interface continued to be permitted, for compatibility with existing source code.
C89 is supported by current C compilers, and most C code being written nowadays is based on it. Any program written only in Standard C and without any hardware-dependent assumptions will run correctly on any platform with a conforming C implementation, within its resource limits. Without such precautions, programs may compile only on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries, such as GUI libraries, or to a reliance on compiler- or platform-specific attributes such as the exact size of data types and byte endianness.
In cases where code must be compilable by either standard-conforming or K&R C-based compilers, the __STDC__ macro can be used to split the code into Standard and K&R sections to take advantage of features available only in Standard C.

[edit] C99
Main article: C99
After the ANSI/ISO standardization process, the C language specification remained relatively static for some time, whereas C++ continued to evolve, largely during its own standardization effort. In 1995 Normative Amendment 1 to the 1990 C standard was published, to correct some details and to add more extensive support for international character sets. The C standard was further revised in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which is commonly referred to as "C99." It has since been amended three times by Technical Corrigenda. The international C standard is maintained by the working group ISO/IEC JTC1/SC22/WG14.
C99 introduced several new features, including inline functions, several new data types (including long long int and a complex type to represent complex numbers), variable-length arrays, support for variadic macros (macros of variable arity) and support for one-line comments beginning with //, as in BCPL or C++. Many of these had already been implemented as extensions in several C compilers.
C99 is for the most part backward compatible with C90, but is stricter in some ways; in particular, a declaration that lacks a type specifier no longer has int implicitly assumed. A standard macro __STDC_VERSION__ is defined with value 199901L to indicate that C99 support is available. GCC, Sun Studio and other C compilers now support many or all of the new features of C99.
As of 2007, work has begun in anticipation of another revision of the C standard, informally called "C1x". The C standards committee has adopted guidelines to limit the adoption of new features that have not been tested by existing implementations.

[edit] Uses
C's primary use is for "system programming", including implementing operating systems and embedded system applications, due to a combination of desirable characteristics such as code portability and efficiency, ability to access specific hardware addresses, ability to "pun" types to match externally imposed data access requirements, and low runtime demand on system resources.
One consequence of C's wide acceptance and efficiency is that C is used for other programs that are not directly used by end-users (compilers, libraries, interpreters, etc).
C is sometimes used as an intermediate language by implementations of other languages. This approach may be used for convenience; by using C as an intermediate language, it is not necessary to develop machine-specific code generators. Some compilers which use C this way are BitC, Gambit, the Glasgow Haskell Compiler, Squeak, and Vala.
Unfortunately, C was designed as a programming language, not as a compiler target language, and is thus less than ideal for use as an intermediate language. This has led to development of C-based intermediate languages such as C--.
C has also been widely used to implement end-user applications, but as applications became larger, much of that development shifted to other languages.

[edit] Syntax
Main article: C syntax
See also: C variable types and declarations
Unlike languages such as FORTRAN 77, C source code is free-form which allows arbitrary use of whitespace to format code, rather than column-based or text-line-based restrictions. Comments may appear either between the delimiters /* and */, or (in C99) following // until the end of the line.
Each source file contains declarations and function definitions. Function definitions, in turn, contain declarations and statements. Declarations either define new types using keywords such as struct, union, and enum, or assign types to and perhaps reserve storage for new variables, usually by writing the type followed by the variable name. Keywords such as char and int specify built-in types. Sections of code are enclosed in braces ({ and }, sometimes called "curly brackets") to limit the scope of declarations and to act as a single statement for control structures.
As an imperative language, C uses statements to specify actions. The most common statement is an expression statement, consisting of an expression to be evaluated, followed by a semicolon; as a side effect of the evaluation, functions may be called and variables may be assigned new values. To modify the normal sequential execution of statements, C provides several control-flow statements identified by reserved keywords. Structured programming is supported by if(-else) conditional execution and by do-while, while, and for iterative execution (looping). The for statement has separate initialization, testing, and reinitialization expressions, any or all of which can be omitted. break and continue can be used to leave the innermost enclosing loop statement or skip to its reinitialization. There is also a non-structured goto statement which branches directly to the designated label within the function. switch selects a case to be executed based on the value of an integer expression.
Expressions can use a variety of built-in operators (see below) and may contain function calls. The order in which operands to most operators, as well as the arguments to functions, are evaluated is unspecified; the evaluations may even be interleaved. However, all side effects (including storage to variables) will occur before the next "sequence point"; sequence points include the end of each expression statement and the entry to and return from each function call. This permits a high degree of object code optimization by the compiler, but requires C programmers to exert more care to obtain reliable results than is needed for other programming languages.
Although mimicked by many languages because of its widespread familiarity, C's syntax has often been criticized. For example, Kernighan and Ritchie say in the second edition of The C Programming Language, "C, like any other language, has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be better."
Some specific problems worth noting are:

Not checking number and types of arguments when the function declaration has an empty parameter list. (This provides backward compatibility with K&R C, which lacked prototypes.)
Some questionable choices of operator precedence, as mentioned by Kernighan and Ritchie above, such as == binding more tightly than & and | in expressions like x & 1 == 0.
The use of the = operator, used in mathematics for equality, to indicate assignment, following the precedent of Fortran, PL/I, and BASIC, but unlike ALGOL and its derivatives. Ritchie made this syntax design decision consciously, based primarily on the argument that assignment occurs more often than comparison.
Similarity of the assignment and equality operators (= and ==), making it easy to accidentally substitute one for the other. C's weak type system permits each to be used in the context of the other without a compilation error (although some compilers produce warnings). For example, the conditional expression in if (a=b) is only true if a is not zero after the assignment.[9]
A lack of infix operators for complex objects, particularly for string operations, making programs which rely heavily on these operations (implemented as functions instead) somewhat difficult to read.
A declaration syntax that some find unintuitive, particularly for function pointers. (Ritchie's idea was to declare identifiers in contexts resembling their use: "declaration reflects use".)


[edit] Operators
Main article: Operators in C and C++
C supports a rich set of operators, which are symbols used within an expression to specify the manipulations to be performed while evaluating that expression. C has operators for:

arithmetic (+, -, *, /, %)
equality testing (==, !=)
order relations (<, <=, >, >=)
boolean logic (!, &&, ||)
bitwise logic (~, &, |, ^)
bitwise shifts (<<, >>)
assignment (=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=)
increment and decrement (++, --)
reference and dereference (&, *, [ ])
conditional evaluation (? :)
member selection (., ->)
type conversion (( ))
object size (sizeof)
function argument collection (( ))
sequencing (,)
subexpression grouping (( ))

C has a formal grammar, specified by the C standard.

[edit] "Hello, world" example
The "hello, world" example which appeared in the first edition of K&R has become the model for an introductory program in most programming textbooks, regardless of programming language. The program prints "hello, world" to the standard output, which is usually a terminal or screen display. A standard-conforming "hello, world" program is:[10]


#include <stdio.h>
 
int main(void)
{
    printf("hello, world\n");
    return 0;
}

The first line of the program contains a preprocessing directive, indicated by #include. This causes the preprocessor — the first tool to examine source code as it is compiled — to substitute the line with the entire text of the stdio.h standard header, which contains declarations for standard input and output functions such as printf. The angle brackets surrounding stdio.h indicate that stdio.h is located using a search strategy that prefers standard headers to other headers having the same name. Double quotes may also be used to include local or project-specific header files.
The next line indicates that a function named main is being defined. The main function serves a special purpose in C programs: The run-time environment calls the main function to begin program execution. The type specifier int indicates that the return value, the value that is returned to the invoker (in this case the run-time environment) as a result of evaluating the main function, is an integer. The keyword void as a parameter list indicates that the main function takes no arguments.[11]
The opening curly brace indicates the beginning of the definition of the main function.
The next line calls (executes the code for) a function named printf, which was declared in stdio.h and is supplied from a system library. In this call, the printf function is passed (provided with) a single argument, the address of the first character in the string literal "hello, world\n". The string literal is an unnamed array with elements of type char, set up automatically by the compiler with a final 0-valued character to mark the end of the array (printf needs to know this). The \n is an escape sequence that C translates to a newline character, which on output signifies the end of the current line. The return value of the printf function is of type int, but it is silently discarded since it is not used. (A more careful program might test the return value to determine whether or not the printf function succeeded.) The semicolon ; terminates the statement.
The return statement terminates the execution of the main function and causes it to return the integer value 0, which is interpreted by the run-time system as an exit code indicating successful execution.
The closing curly brace indicates the end of the code for the main function.
The original version of the "hello world" program (as printed in "Chapter 0" of K&R) was somewhat simpler:


main()
{
    printf("hello, world\n");
}

There were no arguments needed for main, its "int" type was implicit, and no return was required. (A value of zero or false was returned to the the "status" shell variable, which the system interpreted as successful completion.)

[edit] Data structures
C has a static weak typing type system that shares some similarities with that of other ALGOL descendants such as Pascal. There are built-in types for integers of various sizes, both signed and unsigned, floating-point numbers, characters, and enumerated types (enum). C99 added a boolean datatype. There are also derived types including arrays, pointers, records (struct), and untagged unions (union).
C is often used in low-level systems programming where escapes from the type system may be necessary. The compiler attempts to ensure type correctness of most expressions, but the programmer can override the checks in various ways, either by using a type cast to explicitly convert a value from one type to another, or by using pointers or unions to reinterpret the underlying bits of a value in some other way.

[edit] Pointers
C supports the use of pointers, a very simple type of reference that records, in effect, the address or location of an object or function in memory. Pointers can be dereferenced to access data stored at the address pointed to, or to invoke a pointed-to function. Pointers can be manipulated using assignment and also pointer arithmetic. The run-time representation of a pointer value is typically a raw memory address (perhaps augmented by an offset-within-word field), but since a pointer's type includes the type of the thing pointed to, expressions including pointers can be type-checked at compile time. Pointer arithmetic is automatically scaled by the size of the pointed-to data type. (See Array-pointer interchangeability below.) Pointers are used for many different purposes in C. Text strings are commonly manipulated using pointers into arrays of characters. Dynamic memory allocation, which is described below, is performed using pointers. Many data types, such as trees, are commonly implemented as dynamically allocated struct objects linked together using pointers. Pointers to functions are useful for callbacks from event handlers.
A null pointer is a pointer value that points to no valid location (it is often represented by address zero). Dereferencing a null pointer is therefore meaningless, typically resulting in a run-time error. Null pointers are useful for indicating special cases such as no next pointer in the final node of a linked list, or as an error indication from functions returning pointers.
Void pointers (void *) point to objects of unknown type, and can therefore be used as "generic" data pointers. Since the size and type of the pointed-to object is not known, void pointers cannot be dereferenced, nor is pointer arithmetic on them allowed, although they can easily be (and in many contexts implicitly are) converted to and from any other object pointer type.
Careless use of pointers is potentially dangerous. Because they are typically unchecked, a pointer variable can be made to point to any arbitrary location, which can cause undesirable effects. Although properly-used pointers point to safe places, they can be made to point to unsafe places by using invalid pointer arithmetic; the objects they point to may be deallocated and reused (dangling pointers); they may be used without having been initialized (wild pointers); or they may be directly assigned an unsafe value using a cast, union, or through another corrupt pointer. In general, C is permissive in allowing manipulation of and conversion between pointer types, although compilers typically provide options for various levels of checking. Some other programming languages address these problems by using more restrictive reference types.

[edit] Arrays
Array types in C are traditionally of a fixed, static size specified at compile time. (The more recent C99 standard also allows a form of variable-length arrays.) However, it is also possible to allocate a block of memory (of arbitrary size) at run-time, using the standard library's malloc function, and treat it as an array. C's unification of arrays and pointers (see below) means that true arrays and these dynamically-allocated, simulated arrays are virtually interchangeable. Since arrays are always accessed (in effect) via pointers, array accesses are typically not checked against the underlying array size, although the compiler may provide bounds checking as an option. Array bounds violations are therefore possible and rather common in carelessly written code, and can lead to various repercussions, including illegal memory accesses, corruption of data, buffer overruns, and run-time exceptions.
C does not have a special provision for declaring multidimensional arrays, but rather relies on recursion within the type system to declare arrays of arrays, which effectively accomplishes the same thing. The index values of the resulting "multidimensional array" can be thought of as increasing in row-major order.
Although C supports static arrays, it is not required that array indices be validated (bounds checking). For example, one can try to write to the sixth element of an array with five elements, generally yielding undesirable results. This type of bug, called a buffer overflow or buffer overrun, is notorious for causing a number of security problems. On the other hand, since bounds checking elimination technology was largely nonexistent when C was defined, bounds checking came with a severe performance penalty, particularly in numerical computation. A few years earlier, some Fortran compilers had a switch to toggle bounds checking on or off; however, this would have been much less useful for C, where array arguments are passed as simple pointers.
Multidimensional arrays are commonly used in numerical algorithms (mainly from applied linear algebra) to store matrices. The structure of the C array is well suited to this particular task. However, since arrays are passed merely as pointers, the bounds of the array must be known fixed values or else explicitly passed to any subroutine that requires them, and dynamically sized arrays of arrays cannot be accessed using double indexing. (A workaround for this is to allocate the array with an additional "row vector" of pointers to the columns.)
C99 introduced "variable-length arrays" which address some, but not all, of the issues with ordinary C arrays.
See also: C string

[edit] Array-pointer interchangeability
A distinctive (but potentially confusing) feature of C is its treatment of arrays and pointers. The array-subscript notation x[i] can also be used when x is a pointer; the interpretation (using pointer arithmetic) is to access the (i+1)th of several adjacent data objects pointed to by x, counting the object that x points to (which is x[0]) as the first element of the array.
Formally, x[i] is equivalent to *(x + i). Since the type of the pointer involved is known to the compiler at compile time, the address that x + i points to is not the address pointed to by x incremented by i bytes, but rather incremented by i multiplied by the size of an element that x points to. The size of these elements can be determined with the operator sizeof by applying it to any dereferenced element of x, as in n = sizeof *x or n = sizeof x[0].
Furthermore, in most expression contexts (a notable exception is sizeof array), the name of an array is automatically converted to a pointer to the array's first element; this implies that an array is never copied as a whole when named as an argument to a function, but rather only the address of its first element is passed. Therefore, although C's function calls use pass-by-value semantics, arrays are in effect passed by reference.
The number of elements in a declared array a can be determined as sizeof a / sizeof a[0].
An interesting demonstration of the interchangeability of pointers and arrays is shown below. The four assignments are equivalent and each is valid C code. Note how the last line contains the strange code i[x] = 1;, which has the index variable i apparently interchanged with the array variable x. This last line might be found in obfuscated C code.


/* x designates an array */
x[i] = 1;
*(x + i) = 1;
*(i + x) = 1;
i[x] = 1; /* strange, but correct: i[x] is equivalent to *(i + x) */

However, there is a distinction to be made between arrays and pointer variables. Even though the name of an array is in most expression contexts converted to a pointer (to its first element), this pointer does not itself occupy any storage. Consequently, you cannot change what an array "points to", and it is impossible to assign to an array. (Arrays may however be copied using the memcpy function, for example.)

[edit] Memory management
One of the most important functions of a programming language is to provide facilities for managing memory and the objects that are stored in memory. C provides three distinct ways to allocate memory for objects:

Static memory allocation: space for the object is provided in the binary at compile-time; these objects have an extent (or lifetime) as long as the binary which contains them is loaded into memory
Automatic memory allocation: temporary objects can be stored on the stack, and this space is automatically freed and reusable after the block in which they are declared is exited
Dynamic memory allocation: blocks of memory of arbitrary size can be requested at run-time using library functions such as malloc from a region of memory called the heap; these blocks persist until subsequently freed for reuse by calling the library function free

These three approaches are appropriate in different situations and have various tradeoffs. For example, static memory allocation has no allocation overhead, automatic allocation may involve a small amount of overhead, and dynamic memory allocation can potentially have a great deal of overhead for both allocation and deallocation. On the other hand, stack space is typically much more limited and transient than either static memory or heap space, and dynamic memory allocation allows allocation of objects whose size is known only at run-time. Most C programs make extensive use of all three.
Where possible, automatic or static allocation is usually preferred because the storage is managed by the compiler, freeing the programmer of the potentially error-prone chore of manually allocating and releasing storage. However, many data structures can grow in size at runtime, and since static allocations (and automatic allocations in C89 and C90) must have a fixed size at compile-time, there are many situations in which dynamic allocation must be used. Prior to the C99 standard, variable-sized arrays were a common example of this (see "malloc" for an example of dynamically allocated arrays).
Automatically and dynamically allocated objects are only initialized if an initialized is explicitly specified; otherwise they initially have indeterminate values (typically, whatever bit pattern happens to be present in the storage, which might not even represent a valid value for that type). If the program attempts to access an uninitialized value, the results are undefined. Many modern compilers try to detect and warn about this problem, but both false positives and false negatives occur.
Another issue is that heap memory allocation has to be manually synchronized with its actual usage in any program in order for it to be reused as much as possible. For example, if the only pointer to a heap memory allocation goes out of scope or has its value overwritten before free() has been called, then that memory cannot be recovered for later reuse and is essentially lost to the program, a phenomenon known as a memory leak. Conversely, it is possible to release memory too soon and continue to access it; however, since the allocation system can re-allocate or itself use the freed memory, unpredictable behavior is likely to occur when the multiple users corrupt each other's data. Typically, the symptoms will appear in a portion of the program far removed from the actual error. Such issues are ameliorated in languages with automatic garbage collection or RAII.

[edit] Libraries
The C programming language uses libraries as its primary method of extension. In C, a library is a set of functions contained within a single "archive" file. Each library typically has a header file, which contains the prototypes of the functions contained within the library that may be used by a program, and declarations of special data types and macro symbols used with these functions. In order for a program to use a library, it must include the library's header file, and the library must be linked with the program, which in many cases requires compiler flags (e.g., -lm, shorthand for "math library").
The most common C library is the C standard library, which is specified by the ISO and ANSI C standards and comes with every C implementation. ("Freestanding" [embedded] C implementations may provide only a subset of the standard library.) This library supports stream input and output, memory allocation, mathematics, character strings, and time values.
Another common set of C library functions are those used by applications specifically targeted for Unix and Unix-like systems, especially functions which provide an interface to the kernel. These functions are detailed in various standards such as POSIX and the Single UNIX Specification.
Since many programs have been written in C, there are a wide variety of other libraries available. Libraries are often written in C because C compilers generate efficient object code; programmers then create interfaces to the library so that the routines can be used from higher-level languages like Java, Perl, and Python.

[edit] Deficiencies
Although the C language is extremely concise, C is subtle, and expert competency in C is not common—taking more than ten years to achieve.[12] C programs are also notorious for security vulnerabilities due to the unconstrained direct access to memory of many of the standard C library function calls.
In spite of its popularity and elegance, real-world C programs commonly suffer from instability and memory leaks, to the extent that any appreciable C programming project will have to adopt specialized practices and tools to mitigate spiraling damage. Indeed, an entire industry has been born merely out of the need to stabilize large source-code bases.
Although C was developed for Unix, Microsoft adopted C as the core language of its operating systems. Although all standard C library calls are supported by Windows, there is only ad-hoc support for Unix functionality side-by-side with many Windows-specific API calls.
C did not choose to limit the size or endianness of its types—for example, each compiler is free to choose the size of an int type as anything over 16 bits according to what is efficient on the current platform. Many programmers work based on size and endianness assumptions, leading to code that is not portable.
The C standard defines only a very limited gamut of functionality, excluding anything related to network communications, user interaction, or process/thread creation. Its parent document, the POSIX standard, includes such a wide array of functionality that no operating system appears to support it exactly, and only Unix systems have even attempted to support substantial parts of it.
Therefore the kinds of programs that can be portably written are extremely restricted, unless specialized programming practices are adopted.

[edit] Language tools
Tools have been created to help C programmers avoid some of the problems inherent in the language, such as statements with undefined behavior or statements that are not a good practice because they are more likely to result in unintended behavior or run-time errors.
Automated source code checking and auditing are beneficial in any language, and for C many such tools exist, such as Lint. A common practice is to use Lint to detect questionable code when a program is first written. Once a program passes Lint, it is then compiled using the C compiler. Also, many compilers can optionally warn about syntactically valid constructs that are likely to actually be errors. MISRA C is a proprietary set of guidelines to avoid such questionable code, developed for embedded systems.
There are also compilers, libraries and operating system level mechanisms for performing array bounds checking, buffer overflow detection, serialization and automatic garbage collection, that are not a standard part of C.
Tools such as Purify, Valgrind, and linking with libraries containing special versions of the memory allocation functions can help uncover runtime memory errors.

[edit] Related languages
C has directly or indirectly influenced many later languages such as Java, C#, Perl, PHP, JavaScript, LPC, and Unix's C Shell. The most pervasive influence has been syntactical: all of the languages mentioned combine the statement and (more or less recognizably) expression syntax of C with type systems, data models and/or large-scale program structures that differ from those of C, sometimes radically.
When object-oriented languages became popular, C++ and Objective-C were two different extensions of C that provided object-oriented capabilities. Both languages were originally implemented as source-to-source compilers -- source code was translated into C, and then compiled with a C compiler.
Bjarne Stroustrup devised the C++ programming language as one approach to providing object-oriented functionality with C-like syntax. C++ adds greater typing strength, scoping and other tools useful in object-oriented programming and permits generic programming via templates. Nearly a superset of C, C++ now supports most of C, with a few exceptions (see Compatibility of C and C++ for an exhaustive list of differences).
Unlike C++, which maintains nearly complete backwards compatibility with C, the D language makes a clean break with C while maintaining the same general syntax. It abandons a number of features of C which Walter Bright (the designer of D) considered undesirable, including the C preprocessor and trigraphs. Some, but not all, of D's extensions to C overlap with those of C++.
Objective-C was originally a very "thin" layer on top of, and remains a strict superset of, C that permits object-oriented programming using a hybrid dynamic/static typing paradigm. Objective-C derives its syntax from both C and Smalltalk: syntax that involves preprocessing, expressions, function declarations and function calls is inherited from C, while the syntax for object-oriented features was originally taken from Smalltalk.
Limbo is a language developed by the same team at Bell Labs that was responsible for C and Unix, and while retaining some of the syntax and the general style, introduced garbage collection, CSP based concurrency and other major innovations.[citation needed]

[edit] See also

C99, new standard for the C programming language
Comparison of programming languages
International Obfuscated C Code Contest
List of articles with C programs
List of compilers
Comparison of Pascal and C


[edit] Footnotes


^ Dennis M. Ritchie (January 1993). "The Development of the C Language". http://cm.bell-labs.com/cm/cs/who/dmr/chist.html. Retrieved on Jan 1 2008.  "The scheme of type composition adopted by C owes considerable debt to Algol 68, although it did not, perhaps, emerge in a form that Algol's adherents would approve of." 
^ Stewart, Bill (January 7, 2000). "History of the C Programming Language". Living Internet. http://www.livinginternet.com/i/iw_unix_c.htm. Retrieved on 2006-10-31. 
^ Patricia K. Lawlis, c.j. kemp systems, inc. (1997). "Guidelines for Choosing a Computer Language: Support for the Visionary Organization". Ada Information Clearinghouse. http://archive.adaic.com/docs/reports/lawlis/k.htm. Retrieved on 2006-07-18. 
^ "Programming Language Popularity". 2009. http://www.langpop.com/. Retrieved on 2009-01-16. 
^ "TIOBE Programming Community Index". 2009. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html. Retrieved on 2009-01-16. 
^ The C Programming Language, 1st edition, Prentice Hall 1978; ISBN 0-13-110163-3. See page 180.
^ C99 added a _Bool type, but it was not retrofitted into the language's existing Boolean contexts. One can simulate a Boolean datatype, e.g. with enum { false, true } bool;, but this does not provide all of the features of a separate Boolean datatype.
^ "Jargon File entry for nasal demons". http://www.catb.org/jargon/html/N/nasal-demons.html. 
^ http://www.cs.ucr.edu/~nxiao/cs10/errors.htm 10 Common Programming Mistakes in C
^ The original example code will compile on most modern compilers that are not in strict standard compliance mode, but it does not fully conform to the requirements of either C89 or C99. In fact, C99 requires that a diagnostic message be produced.
^ The main function actually has two arguments, int argc and char *argv[], respectively, which can be used to handle command line arguments. The C standard requires that both forms of main be supported, which is special treatment not afforded any other function.
^ Derek M. Jones. "The New C Standard: An Economic and Cultural Commentary". http://www.knosof.co.uk/cbook/cbook.html. Retrieved on 2009-01-16. 



[edit] References


Brian Kernighan, Dennis Ritchie: The C Programming Language. Also known as K&R — The original book on C.

1st, Prentice Hall 1978; ISBN 0-13-110163-3. Pre-ANSI C.
2nd, Prentice Hall 1988; ISBN 0-13-110362-8. ANSI C.


ISO/IEC 9899. Official C99 documents, including technical corrigenda and a rationale. As of 2007 the latest version of the standard is ISO/IEC 9899:TC3PDF (3.61 MB).
Samuel P. Harbison, Guy L. Steele: C: A Reference Manual. This book is excellent as a definitive reference manual, and for those working on C compilers. The book contains a BNF grammar for C.

5th, Prentice Hall 2002; ISBN 0-13-089592-X.


Derek M. Jones: The New C Standard: A Cultural and Economic Commentary, Addison-Wesley, ISBN 0-201-70917-1, online material
Robert Sedgewick: Algorithms in C, Addison-Wesley, ISBN 0-201-31452-5 (Part 1–4) and ISBN 0-201-31663-3 (Part 5)
William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery: Numerical Recipes in C (The Art of Scientific Computing), ISBN 0-521-43108-5



[edit] External links



Wikibooks has a book on the topic of
C Programming






Wikiversity has learning materials about Topic:C



The current Standard (C99 with Technical corrigenda TC1, TC2, and TC3 included)PDF (3.61 MB)
Draft ANSI C Standard (ANSI X3J11/88-090), Third Public Review (May 13, 1988)
ISO C Working Group (official Web site)
The Development of the C Language by Dennis M. Ritchie
comp.lang.c Frequently Asked Questions
The C Book by M.Banahan-D.Brady-M.Doran (Addison-Wesley, 2nd ed.) — book for beginning and intermediate students, now out of print and free to download.
The New C Standard: An economic and cultural commentaryPDF (10.0 MB) — An unpublished book about "detailed analysis of the International Standard for the C language."








v • d • e

Integrated development environments for C/C++





Open source

Anjuta · Code::Blocks · CodeLite · Dev-C++ · Eclipse · Geany · GNAT Programming Studio · KDevelop · MonoDevelop · NetBeans · wxDev-C++






Freeware

Visual Studio Express · Pelles C · Sun Studio · Turbo C++ Explorer · Xcode






Retail

C++ Builder · Visual Studio · Turbo C++ Professional






Category  • Comparison












v • d • e

C programming language





Libraries

C standard library · glibc · Dietlibc · uClibc · Newlib · more






Features

String · Syntax · Preprocessor · Variable types and declarations · Functions






Descendants

C++ · Objective-C · D · C#






C and Other Languages

C and C++ (Compatibility · Operators) · Comparison of Pascal and C · C to Java byte-code compiler






Category








Retrieved from "http://en.wikipedia.org/wiki/C_(programming_language)"
Categories: C programming language | Curly bracket programming languages | Procedural programming languages | American inventionsHidden categories: All articles with unsourced statements | Articles with unsourced statements since September 2008 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Afrikaans
Alemannisch
አማርኛ
العربية
Aragonés
Asturianu
Azərbaycan
বাংলা
Bân-lâm-gú
Беларуская
Беларуская (тарашкевіца)
Bosanski
Brezhoneg
Български
Català
Česky
Corsu
Cymraeg
Dansk
Deutsch
Eesti
Ελληνικά
Español
Esperanto
Euskara
فارسی
Français
Gaeilge
Galego
한국어
हिन्दी
Hrvatski
Bahasa Indonesia
Interlingua
Íslenska
Italiano
עברית
Kurdî / كوردی
Latina
Latviešu
Lietuvių
Magyar
Македонски
മലയാളം
Bahasa Melayu
Mìng-dĕ̤ng-ngṳ̄
Монгол
Nederlands
日本語
‪Norsk (bokmål)‬
‪Norsk (nynorsk)‬
ភាសាខ្មែរ
Occitan
Polski
Português
Română
Русский
Shqip
Simple English
Slovenčina
Slovenščina
Српски / Srpski
Srpskohrvatski / Српскохрватски
Suomi
Svenska
தமிழ்
Taqbaylit
తెలుగు
ไทย
Tiếng Việt
Türkçe
ᨅᨔ ᨕᨘᨁᨗ
Українська
吴语
ייִדיש
粵語
Žemaitėška
中文









 This page was last modified on 5 April 2009, at 23:18.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
