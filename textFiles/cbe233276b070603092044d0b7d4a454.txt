













x86 calling conventions - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "X86_calling_conventions";
		var wgTitle = "X86 calling conventions";
		var wgAction = "view";
		var wgArticleId = "6817415";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 286037116;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-asm {line-height: normal;}
.source-asm li, .source-asm pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for asm
 * CSS class: source-asm, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-asm .de1, .source-asm .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-asm  {}
.source-asm .head {}
.source-asm .foot {}
.source-asm .imp {font-weight: bold; color: red;}
.source-asm .ln-xtra {color: #cc0; background-color: #ffc;}
.source-asm li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-asm li.li2 {font-weight: bold;}
.source-asm .kw1 {color: #00007f;}
.source-asm .kw2 {color: #0000ff;}
.source-asm .kw3 {color: #46aa03; font-weight:bold;}
.source-asm .kw4 {color: #0000ff;}
.source-asm .kw5 {color: #0000ff;}
.source-asm .co1 {color: #adadad; font-style: italic;}
.source-asm .es0 {color: #000099; font-weight: bold;}
.source-asm .br0 {color: #66cc66;}
.source-asm .st0 {color: #7f007f;}
.source-asm .nu0 {color: #ff0000;}
.source-asm .re0 {color: #ff0000;}
.source-asm .re1 {color: #ff0000;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-pascal {line-height: normal;}
.source-pascal li, .source-pascal pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for pascal
 * CSS class: source-pascal, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-pascal .de1, .source-pascal .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-pascal  {}
.source-pascal .head {}
.source-pascal .foot {}
.source-pascal .imp {font-weight: bold; color: red;}
.source-pascal .ln-xtra {color: #cc0; background-color: #ffc;}
.source-pascal li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-pascal li.li2 {font-weight: bold;}
.source-pascal .kw1 {color: #b1b100;}
.source-pascal .kw2 {color: #000000; font-weight: bold;}
.source-pascal .kw3 {}
.source-pascal .kw4 {color: #993333;}
.source-pascal .co1 {color: #808080; font-style: italic;}
.source-pascal .co2 {color: #339933;}
.source-pascal .coMULTI {color: #808080; font-style: italic;}
.source-pascal .es0 {color: #000099; font-weight: bold;}
.source-pascal .br0 {color: #66cc66;}
.source-pascal .st0 {color: #ff0000;}
.source-pascal .nu0 {color: #cc66cc;}
.source-pascal .me1 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); x86 calling conventions

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article includes a list of references or external links, but its sources remain unclear because it lacks inline citations. Please improve this article by introducing more precise citations where appropriate. (February 2008)


This article describes, in computing, the calling conventions used on the x86 architecture.
Calling conventions describe the interface of called code:

The order in which parameters are allocated
Where parameters are placed (pushed on the stack or placed in registers)
Which registers may be used by the function
Whether the caller or the callee is responsible for unwinding the stack on return

A closely related topic is name mangling, which determines how symbol names in the code map to symbol names used by the linker.
It should be noted that there are often subtle differences in how various compilers implement these conventions, so it is often difficult to interface code which is compiled by different compilers. On the other hand, conventions which are used as an API standard (like stdcall) are necessarily very uniformly implemented.




Contents


1 Historical background
2 Caller clean-up

2.1 cdecl
2.2 syscall
2.3 optlink


3 Callee clean-up

3.1 pascal
3.2 register
3.3 stdcall
3.4 fastcall

3.4.1 Microsoft fastcall
3.4.2 Borland fastcall
3.4.3 Watcom register based calling convention
3.4.4 TopSpeed / Clarion / JPI


3.5 safecall


4 Either caller or callee clean-up

4.1 thiscall


5 Intel ABI
6 Microsoft x64 calling convention
7 AMD64 ABI convention
8 Standard exit and entry sequences for C code
9 References





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Historical background
In the times of minicomputers, the machine manufacturer also used to provide an OS for it and most of (if not all) of the software, including compilers for various languages. So there used to be only one calling convention per language: the one implemented by the manufacturer's compilers.
The IBM PC case was totally different. One firm (IBM) provided the hardware, another (Intel) made the processor, the third (Microsoft) was responsible for the OS (MS-DOS), and many others wrote compilers for quite a number of programming languages. Different mutually exclusive calling schemes were thus designed to satisfy their different requirements.

[edit] Caller clean-up
In these conventions the caller cleans the arguments from the stack, which allows for variable argument lists, eg. printf().

[edit] cdecl
The cdecl calling convention is used by many C systems for the x86 architecture. In cdecl, function parameters are pushed on the stack in a right-to-left order. Function return values are returned in the EAX register (except for floating point values, which are returned in the x87 register ST0). Registers EAX, ECX, and EDX are available for use in the function.
For instance, the following C code function prototype and function call:


int function_name(int, int, int);
int a, b, c, x;
...
x = function_name(a, b, c);

will produce the following x86 Assembly code (written in MASM syntax, with destination first):


push c
push b
push a
call function_name
add esp, 12 ;Stack clearing
mov x, eax

The calling function cleans the stack after the function call returns.
There are some variations in the interpretation of cdecl, particularly in how to return values. As a result, x86 programs compiled for different operating system platforms and/or by different compilers can be incompatible, even if they both use the "cdecl" convention and do not call out to the underlying environment. Some compilers return simple data structures with the length of 2 registers or less in EAX:EDX, and larger structures and class objects requiring special treatment by the exception handler (e.g., a defined constructor, destructor, or assignment) are returned in memory. To pass "in memory", the caller allocates memory and passes a pointer to it as a hidden first parameter; the callee populates the memory and returns the pointer, popping the hidden pointer when returning.
In Linux/gcc double/floating point values should be pushed on the stack via the x87 pseudo-stack. Like so:


sub esp,8;    make room for the double
fld [ebp+x]; load our double onto the floating point stack
fstp [esp];  push our double onto the stack
call func;
add esp,8;

Using this method ensures it is pushed on the stack in the correct format.
The cdecl calling convention is usually the default calling convention for x86 C compilers, although many compilers provide options to automatically change the calling conventions used. To manually define a function to be cdecl, some support the following syntax:


void _cdecl function_name(params);

The _cdecl modifier must be included in the function prototype, and in the function declaration to override any other settings that might be in place.

[edit] syscall
This is similar to cdecl in that arguments are pushed right to left. EAX, ECX, and EDX are not preserved. The size of the parameter list in doublewords is passed in AL.
Syscall is the standard calling convention for 32 bit OS/2 API.

[edit] optlink
Arguments are pushed right to left. The three lexically first (leftmost) arguments are passed in EAX, EDX, and ECX and up to four floating-point arguments are passed in ST(0) through ST(3), although space for them is reserved in the argument list on the stack. Results are returned in EAX or ST(0). Registers EBP, EBX, ESI, and EDI are preserved.
Optlink is used by the IBM VisualAge compilers.

[edit] Callee clean-up
When the callee cleans the arguments from the stack it needs to be known at compile time how many bytes the stack needs to be adjusted. Therefore, these calling conventions are not compatible with variable argument lists, eg. printf(). They may be, however, slightly more efficient as the code needed to unwind the stack does not need to be generated by the calling code.
Functions which utilize these conventions are easy to recognize in ASM code because they will unwind the stack prior to returning. The x86 ret instruction allows an optional byte parameter that specifies the number of stack locations to unwind before returning to the caller. Such code looks like this:


 ret 12


[edit] pascal
The parameters are pushed on the stack in left-to-right order (opposite of cdecl), and the callee is responsible for balancing the stack before return.
This calling convention was common in the following 16 bit APIs: OS/2 1.x , Microsoft Windows 3.x, and Borland Delphi version 1.x.

[edit] register
An alias for Borland fastcall.

[edit] stdcall
The stdcall[1] calling convention is a variation on the pascal calling convention in which parameters are passed on the stack, pushed right-to-left. Registers EAX, ECX, and EDX are designated for use within the function. Return values are stored in the EAX register. The callee is responsible for cleanup of the stack.
Stdcall is the standard calling convention for the Microsoft Win32 API.

[edit] fastcall
Conventions entitled fastcall have not been standardized, and have been implemented differently, depending on the compiler vendor.

[edit] Microsoft fastcall

Microsoft or GCC [2] __fastcall[3] convention (aka __msfastcall) passes the first two arguments (evaluated left to right) that fit into ECX and EDX. Remaining arguments are pushed onto the stack from right to left.


[edit] Borland fastcall
Evaluating arguments from left to right, it passes three arguments via EAX, EDX, ECX. Remaining arguments are pushed onto the stack, also left to right.
It is the default calling convention of Borland Delphi, where it is known as register.

[edit] Watcom register based calling convention
Watcom does not support the __fastcall keyword except to alias it to null. The register calling convention may be selected by command line switch. (However, IDA uses __fastcall anyway for uniformity)
Up to 4 registers are assigned to arguments in the order eax, edx, ebx, ecx. Arguments are assigned to registers from left to right. If any argument cannot be assigned to a register (say it is too large) it, and all subsequent arguments, are assigned to the stack. Arguments assigned to the stack are pushed from right to left. Names are mangled by adding a suffixed underscore.
Variadic functions fall back to the Watcom stack based calling convention.
The Watcom C/C++ compiler also uses the #pragma aux[4] directive that allows the user to specify his own calling convention. As its manual states, "Very few users are likely to need this method, but if it is needed, it can be a lifesaver".

[edit] TopSpeed / Clarion / JPI
The first four integer parameters are passed in registers eax, ebx, ecx and edx. Floating point parameters are passed on the floating point stack – registers st0, st1, st2, st3, st4, st5 and st6. Structure parameters are always passed on the stack. Additional parameters are passed on the stack after registers are exhausted. Integer values are returned in eax, pointers in edx and floating point types in st0.

[edit] safecall
In Borland Delphi on Microsoft Windows, the safecall calling convention encapsulates COM (Component Object Model) error handling, so that exceptions aren't leaked out to the caller, but are reported in the HRESULT return value, as required by COM/OLE. When calling a safecall function from Delphi code, Delphi also automatically checks the returned HRESULT and raises an exception if necessary. Together with language-level support for COM interfaces and automatic IUnknown handling (implicit AddRef/Release/QueryInterface calls), the safecall calling convention makes COM/OLE programming in Delphi easy and elegant.
The safecall calling convention is the same as the stdcall calling convention, except that exceptions are passed back to the caller in EAX as a HResult (instead of in FS:[0]), while the function result is passed by reference on the stack as though it were a final "out" parameter. When calling a Delphi function from Delphi this calling convention will appear just like any other calling convention, because although exceptions are passed back in EAX, they are automatically converted back to proper exceptions by the caller. When using COM objects created in other languages, the HResults will be automatically raised as exceptions, and the result for Get functions is in the result rather than a parameter. When creating COM objects in Delphi with safecall, there is no need to worry about HResults, as exceptions can be raised as normal but will be seen as HResults in other languages.


function function_name(a: DWORD): DWORD; safecall;

Returns a result and raises exceptions like a normal Delphi function, but it passes values and exceptions as though it was:


function function_name(a: DWORD; out Result: DWORD): HResult; stdcall;




This section requires expansion.




[edit] Either caller or callee clean-up

[edit] thiscall
This calling convention is used for calling C++ non-static member functions. There are two primary versions of thiscall used depending on the compiler and whether or not the function uses variable arguments.
For the GCC compiler, thiscall is almost identical to cdecl: the calling function cleans the stack, and the parameters are passed in right-to-left order. The difference is the addition of the this pointer, which is pushed onto the stack last, as if it were the first parameter in the function prototype.
On the Microsoft Visual C++ compiler, the this pointer is passed in ECX and it is the callee that cleans the stack, mirroring the stdcall convention used in C for this compiler and in Windows API functions. When functions use a variable number of arguments, it is the caller that cleans the stack (cf. cdecl).
The thiscall calling convention can only be explicitly specified on Microsoft Visual C++ 2005 and later. On any other compiler thiscall is not a keyword. (Disassemblers like IDA, however, have to specify it anyway. So IDA uses keyword __thiscall for this)

[edit] Intel ABI
The Intel Application Binary Interface is a computer programming standard that most compilers and languages follow. According to the Intel ABI, the EAX, EDX, and ECX are to be free for use within a procedure or function, and need not be preserved.

[edit] Microsoft x64 calling convention
The x64 calling convention (for long mode on x86-64) takes advantage of additional register space in the AMD64/Intel 64 platform. The registers RCX, RDX, R8, R9 are used for integer and pointer arguments, and XMM0, XMM1, XMM2, XMM3 are used for floating point arguments. Additional arguments are pushed onto the stack. The return value is stored in RAX.
Note that when compiling for the x64 architecture using Microsoft tools, there is only one calling convention — the one described here, so that stdcall, thiscall, cdecl, fastcall, etc., are now all one and the same.
On x86, one could create thunks that convert any function call from stdcall to thiscall by placing the 'this' pointer in ECX and jumping to the member function address. In x64 a universal stdcall-to-thiscall thunk cannot be written, except for functions that take no arguments. Putting the implicit 'this' in place requires shifting all the arguments, whose number and sizes are unknown.
In the Microsoft x64 calling convention, it's the caller's responsibility to allocate 32 bytes of "shadow space" on the stack right before calling the function (regardless of the actual number of parameters used), and to pop the stack after the call. The shadow space is used to spill RCX, RDX, R8, and R9.
In x86-64, Visual Studio 2007 stores floating point numbers in XMM6 and XMM7 (as well as XMM8 through XMM15); consequently, for x86-64, user-written assembly language routines must preserve XMM6 and XMM7 (as compared to x86 wherein user-written assembly language routines did not need to preserve XMM6 and XMM7). In other words, user-written assembly language routines must be updated to save/restore XMM6 and XMM7 before/after the function when being ported from x86 to x86-64.

[edit] AMD64 ABI convention
The calling convention of the AMD64 application binary interface is followed on Linux and other non-Microsoft operating systems. The registers RDI, RSI, RDX, RCX, R8 and R9 are used for integer and pointer arguments while XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6 and XMM7 are used for floating point arguments. As in the Microsoft x64 calling convention, additional arguments are pushed onto the stack and the return value is stored in RAX.

[edit] Standard exit and entry sequences for C code
The Standard Entry Sequence to a function is as follows:


_function:
    push ebp       ;store the old base pointer
    mov ebp, esp   ;make the base pointer point to the current
                   ;stack location – at the top of the stack is the 
                   ;old ebp, followed by the return address and then
                   ;the parameters.
    sub esp, x     ;x is the size, in bytes, of all
                   ;"automatic variables" in the function

This sequence preserves the original base pointer EBP; points EBP to the current stack pointer (which points at the old EBP, followed by the return address and then the function parameters); and then creates space for automatic variables on the stack. Local variables are created on the stack with each call to the function, and are cleaned up at the end of each function. This behaviour allows for functions to be called recursively. In C and C++, variables declared "automatic" are created in this way.
The Standard Exit Sequence goes as follows:


mov esp, ebp   ;reset the stack to "clean" away the local variables
pop ebp        ;restore the original base pointer
ret            ;return from the function


Recovering the previous frame is an action so common that there's an opcode just to do that, called 'leave'. Thus, the exit sequence can also be written as follows:


leave          ;reset the stack and restore the original base pointer
ret            ;return from the function

Note that while functions tend to have only one entry point, they may have multiple exit points, and thus may well have more than one standard exit sequence, or a jump to the standard exit sequence in the function body.

The following C function:


int _cdecl MyFunction(int i){ 
    int k;
    return i + k;
}

would produce the equivalent asm code:


;entry sequence
push ebp
mov ebp, esp
sub esp, 4     ;create function stack frame
 
;function code
mov eax, [ebp + 8] 
               ;move parameter i to accumulator
add eax, [ebp - 4]
               ;add k to i
               ;result is returned in eax
 
;exit sequence
mov esp, ebp
pop ebp
ret

Note that many compilers can optimize these standard sequences away when not needed (often called "no stackframe generation"). If you require them for e.g. interlanguage interfacing, you probably need to search your compiler manual for a compiler directive (or pragma) to turn this kind of optimization locally off.

[edit] References

System V Application Binary Interface Intel386 Architecture Processor Supplement
The Code Project—Calling Conventions Demystified
Intel x86 Function-call Conventions – Assembly View
Microsoft x64 Calling Convention
Calling Conventions
Calling Conventions on x86 by Agner Fog (pdf)
AMD64 ABI (pdf)
The Old New Thing — the history of calling conventions (by Raymond Chen) — Part1, Part2, Part3, Part4(ia64), Part5(amd64)




Retrieved from "http://en.wikipedia.org/wiki/X86_calling_conventions"
Categories: X86 architectureHidden categories: Articles lacking in-text citations from February 2008 | Articles to be expanded since June 2008 | All articles to be expanded 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Deutsch









 This page was last modified on 25 April 2009, at 13:17 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
