













Generic programming - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Generic_programming";
		var wgTitle = "Generic programming";
		var wgAction = "view";
		var wgArticleId = "105837";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 281479428;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ada {line-height: normal;}
.source-ada li, .source-ada pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ada
 * CSS class: source-ada, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ada .de1, .source-ada .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ada  {}
.source-ada .head {}
.source-ada .foot {}
.source-ada .imp {font-weight: bold; color: red;}
.source-ada .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ada li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ada li.li2 {font-weight: bold;}
.source-ada .kw1 {color: #00007f;}
.source-ada .kw2 {color: #0000ff;}
.source-ada .kw3 {color: #46aa03; font-weight:bold;}
.source-ada .co1 {color: #adadad; font-style: italic;}
.source-ada .coMULTI {color: #808080; font-style: italic;}
.source-ada .es0 {color: #000099; font-weight: bold;}
.source-ada .br0 {color: #66cc66;}
.source-ada .st0 {color: #7f007f;}
.source-ada .nu0 {color: #ff0000;}
.source-ada .me1 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-scheme {line-height: normal;}
.source-scheme li, .source-scheme pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for scheme
 * CSS class: source-scheme, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-scheme .de1, .source-scheme .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-scheme  {}
.source-scheme .head {}
.source-scheme .foot {}
.source-scheme .imp {font-weight: bold; color: red;}
.source-scheme .ln-xtra {color: #cc0; background-color: #ffc;}
.source-scheme li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-scheme li.li2 {font-weight: bold;}
.source-scheme .kw1 {color: #b1b100;}
.source-scheme .co1 {color: #808080; font-style: italic;}
.source-scheme .coMULTI {color: #808080; font-style: italic;}
.source-scheme .es0 {color: #000099; font-weight: bold;}
.source-scheme .br0 {color: #66cc66;}
.source-scheme .st0 {color: #ff0000;}
.source-scheme .nu0 {color: #cc66cc;}
.source-scheme .me0 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Generic programming

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
Template:AaPOV


Programming paradigms




Agent-oriented
Component-based

Flow-based
Pipeline


Concatenative
Concurrent computing
Context-oriented
Declarative (Contrast: Imperative)

Functional

Dataflow

Cell-oriented (spreadsheets)
Reactive




Goal-directed

Constraint
Constraint logic
Logic

Abductive logic
Inductive logic






Event-driven
Feature-oriented
Function-level (Contrast: Value-level)
Imperative (Contrast: Declarative)

Advanced separation of concerns

Aspect-oriented
Subject-oriented


Array (Contrast: Scalar)
Automata-based
Object-oriented

Class-based
Prototype-based


Procedural

Structured


Role-oriented
Scalar (Contrast: Array)


Iterative (Contrast: Recursive)
Metaprogramming

Attribute-oriented
Automatic

Generic

Template

Policy-based




Language-oriented

Grammar-oriented

Dialecting


Intentional




Reflective


Modular
Nondeterministic
Parallel computing

Process-oriented


Programming in the large and programming in the small
Recursive (Contrast: Iterative)
Tree
Value-level (Contrast: Function-level)


This box: view • talk • edit



Generic programming is a style of computer programming in which algorithms are written in terms of to-be-specified-later types that are then instantiated when needed for specific types provided as parameters and was pioneered by Ada which appeared in 1983. This approach permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplication. Software entities created using generic programming are known as generics in Ada, Eiffel, Java, C#, Visual Basic .NET and Haskell; templates in C++; and parameterized types in the influential 1994 book Design Patterns. The authors of Design Patterns note that this technique, especially when combined with delegation, is very powerful but that "Dynamic, highly parameterized software is harder to understand than more static software." (Gang of Four 1995:21)
Generic programming refers to features of certain statically typed programming languages that allow some code to effectively circumvent the static typing requirements. For instance in C++, a template is a routine in which some parameters are qualified by a type variable. Since code generation in C++ depends on concrete types, the template is specialized for each combination of argument types that occur in practice. Generic programming is commonly used to implement containers such as lists and hash tables and functions such as a particular sorting algorithm for objects specified in terms more general than a concrete type.




Contents


1 Programming language support for generic programming

1.1 Generic programming in object-oriented languages

1.1.1 Generics in Ada

1.1.1.1 Ada example
1.1.1.2 Advantages and limitations


1.1.2 Templates in C++

1.1.2.1 Technical overview
1.1.2.2 Template specialization
1.1.2.3 Advantages and disadvantages


1.1.3 Templates in D

1.1.3.1 Static-if
1.1.3.2 Alias parameters


1.1.4 Generics in Java
1.1.5 Generic programming in C# and .NET
1.1.6 Generic programming in Delphi


1.2 Generic programming in Functional languages

1.2.1 Generic programming in Haskell

1.2.1.1 PolyP
1.2.1.2 Generic Haskell
1.2.1.3 The "Scrap your boilerplate" approach


1.2.2 Clean


1.3 Generic programming features in other languages


2 See also
3 External links and references

3.1 General
3.2 C++/D
3.3 C#/.NET
3.4 Delphi
3.5 Haskell/functional
3.6 Java
3.7 Object Pascal


4 Notes





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Programming language support for generic programming
Generic programming facilities first appeared in the 1970s in languages like CLU and Ada, and were subsequently adopted by many object-based and object-oriented languages, including BETA, C++, D, Eiffel, Java, and DEC's now defunct Trellis-Owl language. Implementations of generics in languages such as Java and C# are formally based on the notion of parametricity, due to John C. Reynolds. Software entities created using generic programming are known as generics in Ada, Eiffel, Java, C#, VB .NET and Haskell; templates in C++; and parameterized types in Design Patterns.
Generic programming is implemented and supported differently within each language. The term "generic" has also been used differently in programming contexts. For example, in Forth the compiler can execute code while compiling and one can create new compiler keywords and new implementations for those words on the fly. It has few words that expose the compiler behaviour and therefore naturally offers generic programming capacities which, however, are not referred to as such in most Forth texts. The term has been used in functional programming, specifically in Haskell-like languages, which use a structural type system where types are always parametric and the actual code on those types is generic. In these uses generic programming still serves the similar purpose of code-saving and the rendering of an abstraction.

[edit] Generic programming in object-oriented languages
When creating containers of objects it is possible to write specific implementations for each datatype contained, even if the code is virtually identical except for different datatypes. In C++, this duplication of code can be circumvented by defining a template class:


template<typename T> 
class List 
{ 
   /* class contents */ 
};
 
List<Animal> list_of_animals;
List<Car> list_of_cars;

Above, T is a placeholder for whatever type is specified when the list is created. These "containers-of-type-T", commonly called generics, are a generic programming technique allowing a class to be reused with different datatypes as long as certain contracts such as subtypes and signature are kept. Generic programming should not to be confused with inclusion polymorphism, which is the algorithmic usage of exchangeable sub-classes: for instance, a list of objects of type Moving_Object containing objects of type Animal and Car. Generics can also be used for type-independent functions as in the Swap example below:


template<typename T>
void Swap(T & a, T & b) //"&" passes parameters by reference
{
   T temp = b;
   b = a;
   a = temp;
}
 
string hello = "world!", world = "Hello, ";
Swap( world, hello );
cout << hello << world << endl; //Output is "Hello, world!"

The C++ template construct used above is widely cited as the generic programming construct that popularized the notion among programmers and language designers and supports many generic programming idioms. The D programming language also offers fully generic-capable templates based on the C++ precedent but with a simplified syntax. The Java programming language has provided generic programming facilities syntactically based on C++'s since the introduction of J2SE 5.0 and implements the generics subset of generic programming.
Although the examples above are a common use of generic programming, and some languages implement only this aspect of it, the concept of generic programming is not limited to "generics" as a programming language construct. In Python, a language with strong, dynamic typing, generic programming is both transparent and also the simplest way to write routines. For example, the preceding example can be translated into Python if a box class is created to simulate the C++ notion of call-by-reference.


class Box:
  def __init__(self,ob):
    self.contents = ob
 
def swap(box1,box2):
  box2.contents, box1.contents = box1.contents, box2.contents

C# 2.0, Chrome 1.5 and Visual Basic .NET 2005 have constructs that take advantage of the support for generics present in the Microsoft .NET Framework since version 2.0. The ML family of programming languages encourage generic programming through parametric polymorphism and generic modules called functors. The type class mechanism of Haskell supports generic programming.
Dynamic typing, such as is featured in Objective-C, and, judicious use of protocols circumvent the need for use of generic programming techniques, since there exists a general type to contain any object. While Java does so also, the casting that needs to be done breaks the discipline of static typing, and generics are one way of achieving some of the benefits of dynamic typing with the advantages of having static typing.

[edit] Generics in Ada
Ada has had generics since it was first designed in 1977-1980. The standard library uses generics to provide many services. Ada 2005 adds a comprehensive generic container library to the standard library, which was inspired by C++'s standard template library.
A generic unit is a package or a subprogram that takes one or more generic formal parameters.
A generic formal parameter is a value, a variable, a constant, a type, a subprogram, or even an instance of another, designated, generic unit. For generic formal types, the syntax distinguishes between discrete, floating-point, fixed-point, access (pointer) types, etc. Some formal parameters can have default values.
To instantiate a generic unit, the programmer passes actual parameters for each formal. The generic instance then behaves just like any other unit. It is possible to instantiate generic units at run-time, for example inside a loop.

[edit] Ada example
The specification of a generic package:


 generic
    Max_Size : Natural; -- a generic formal value
    type Element_Type is private; -- a generic formal type; accepts any nonlimited type
 package Stacks is
    type Size_Type is range 0 .. Max_Size;
    type Stack is limited private;
    procedure Create (S : out Stack;
                      Initial_Size : in Size_Type := Max_Size);
    procedure Push (Into : in out Stack; Element : in Element_Type);
    procedure Pop (From : in out Stack; Element : out Element_Type);
    Overflow : exception;
    Underflow : exception;
 private
    subtype Index_Type is Size_Type range 1 .. Max_Size;
    type Vector is array (Index_Type range <>) of Element_Type;
    type Stack (Allocated_Size : Size_Type := 0) is record
       Top : Index_Type;
       Storage : Vector (1 .. Allocated_Size);
    end record;
 end Stacks;

Instantiating the generic package:


 type Bookmark_Type is new Natural;
 -- records a location in the text document we are editing
 
 package Bookmark_Stacks is new Stacks (Max_Size => 20,
                                        Element_Type => Bookmark_Type);
 -- Allows the user to jump between recorded locations in a document

Using an instance of a generic package:


 type Document_Type is record
    Contents : Ada.Strings.Unbounded.Unbounded_String;
    Bookmarks : Bookmark_Stacks.Stack;
 end record;
 
 procedure Edit (Document_Name : in String) is
   Document : Document_Type;
 begin
   -- Initialise the stack of bookmarks:
   Bookmark_Stacks.Create (S => Document.Bookmarks, Initial_Size => 10);
   -- Now, open the file Document_Name and read it in...
 end Edit;


[edit] Advantages and limitations
The language syntax allows precise specification of constraints on generic formal parameters. For example, it is possible to specify that a generic formal type will only accept a modular type as the actual. It is also possible to express constraints between generic formal parameters; for example:


 generic
    type Index_Type is (<>); -- must be a discrete type
    type Element_Type is private; -- can be any nonlimited type
    type Array_Type is array (Index_Type range <>) of Element_Type;

In this example, Array_Type is constrained by both Index_Type and Element_Type. When instantiating the unit, the programmer must pass an actual array type that satisfies these constraints.
The disadvantage of this fine-grained control is a complicated syntax, but, because all generic formal parameters are completely defined in the specification, the compiler can instantiate generics without looking at the body of the generic.
Unlike C++, Ada does not allow specialised generic instances, and requires that all generics be instantiated explicitly. These rules have several consequences:

the compiler can implement shared generics: the object code for a generic unit can be shared between all instances (unless the programmer requests inlining of subprograms, of course). As further consequences:

there is no possibility of code bloat (code bloat is common in C++ and requires special care, as explained below).
it is possible to instantiate generics at run time, as well as at compile time, since no new object code is required for a new instance.
actual objects corresponding to a generic formal object are always considered to be nonstatic inside the generic; see Generic formal objects in the Wikibook for details and consequences.


all instances of a generic being exactly the same, it is easier to review and understand programs written by others; there are no "special cases" to take into account.
all instantiations being explicit, there are no hidden instantiations that might make it difficult to understand the program.
Ada does not permit "template metaprogramming", because it does not allow specialisations.


[edit] Templates in C++
C++ uses templates to enable generic programming techniques. The C++ Standard Library (also known as the Standard Template Library or STL) provides a framework of templates for common data structures and algorithms. Templates in C++ may also be used for template metaprogramming, which is a way of pre-evaluating some of the code at compile-time rather than run-time. Using template specialization, C++ Templates are considered turing complete.

[edit] Technical overview
There are two kinds of templates: function templates and class templates. A function template is a pattern for creating ordinary functions based upon the parameterizing types supplied when instantiated. For example, the C++ Standard Template Library contains the function template max(x, y) which creates functions that return either x or y, whichever is larger. max() could be defined like this:


template <typename T>
T max(T x, T y) {
    return x < y ? y : x;
}

Specializations of this function template, instantiations with specific types, can be called just like an ordinary function:


cout << max(3, 7);   // outputs 7

The compiler examines the arguments used to call max and determines that this is a call to max(int, int). It then instantiates a version of the function where the parameterizing type T is int, making the equivalent of the following function:


int max(int x, int y) {
    return x < y ? y : x;
}

This works whether the arguments x and y are integers, strings, or any other type for which the expression x < y is sensible, or more specifically, for any type for which operator< is defined. Common inheritance is not needed for the set of types that can be used, and so it is very similar to duck typing. A program defining a custom data type can use operator overloading to define the meaning of < for that type, thus allowing its use with the max() function template. While this may seem a minor benefit in this isolated example, in the context of a comprehensive library like the STL it allows the programmer to get extensive functionality for a new data type, just by defining a few operators for it. Merely defining < allows a type to be used with the standard sort(), stable_sort(), and binary_search() algorithms or to be put inside data structures such as sets, heaps, and associative arrays.
C++ templates are completely type safe at compile time. As a demonstration, the standard type complex does not define the < operator, because there is no strict order on complex numbers. Therefore max(x, y) will fail with a compile error if x and y are complex values. Likewise, other templates that rely on < cannot be applied to complex data. Unfortunately, compilers historically generate somewhat esoteric, long, and unhelpful error messages for this sort of error. Ensuring that a certain object adheres to a method protocol can alleviate this issue.
The second kind of template, a class template, extends the same concept to classes. A class template specialization is a class. Class templates are often used to make generic containers. For example, the STL has a linked list container. To make a linked list of integers, one writes list<int>. A list of strings is denoted list<string>. A list has a set of standard functions associated with it, which work for any compatible parameterizing types.

[edit] Template specialization
A powerful feature of C++'s templates is template specialization. This allows alternative implementations to be provided based on certain characteristics of the parameterized type that is being instantiated. Template specialization has two purposes: to allow certain forms of optimization, and to reduce code bloat.
For example, consider a sort() template function. One of the primary activities that such a function does is to swap or exchange the values in two of the container's positions. If the values are large (in terms of the number of bytes it takes to store each of them), then it is often quicker to first build a separate list of pointers to the objects, sort those pointers, and then build the final sorted sequence. If the values are quite small however it is usually fastest to just swap the values in-place as needed. Furthermore if the parameterized type is already of some pointer-type, then there is no need to build a separate pointer array. Template specialization allows the template creator to write different implementations and to specify the characteristics that the parameterized type(s) must have for each implementation to be used.
Unlike function templates, class templates can be partially specialized. That means that an alternate version of the class template code can be provided when some of the template parameters are known, while leaving other template parameters generic. This can be used, for example, to create a default implementation (the primary specialization) that assumes that copying a parameterizing type is expensive and then create partial specializations for types that are cheap to copy, thus increasing overall efficiency. Clients of such a class template just use specializations of it without needing to know whether the compiler used the primary specialization or some partial specialization in each case. Class templates can also be fully specialized, which means that an alternate implementation can be provided when all of the parameterizing types are known.

[edit] Advantages and disadvantages
Some uses of templates, such as the max() function, were previously filled by function-like preprocessor macros (a legacy of the C programming language). For example, here is a possible max() macro:


#define max(a,b) ((a) < (b) ? (b) : (a))

Both macros and templates are expanded at compile time. Macros are always expanded inline; templates can also be expanded as inline functions when the compiler deems it appropriate. Thus both function-like macros and function templates have no run-time overhead.
However, templates are generally considered an improvement over macros for these purposes. Templates are type-safe. Templates avoid some of the common errors found in code that makes heavy use of function-like macros. Perhaps most importantly, templates were designed to be applicable to much larger problems than macros.
There are three primary drawbacks to the use of templates: compiler support, poor error messages, and code bloat. Many compilers historically have poor support for templates, thus the use of templates can make code somewhat less portable. Support may also be poor when a C++ compiler is being used with a linker which is not C++-aware, or when attempting to use templates across shared library boundaries. Most modern compilers however now have fairly robust and standard template support, and the new C++ standard, C++0x, is expected to further address these issues.
Almost all compilers produce confusing, long, or sometimes unhelpful error messages when errors are detected in code that uses templates.[citation needed] This can make templates difficult to develop.
Finally, the use of templates requires the compiler to generate a separate instance of the templated class or function for every permutation of type parameters used with it. (This is necessary because types in C++ are not all the same size, and the sizes of data fields are important to how classes work.) So the indiscriminate use of templates can lead to code bloat, resulting in excessively large executables.[citation needed] However, judicious use of template specialization can dramatically reduce such code bloat in some cases. The extra instantiations generated by templates can also cause debuggers to have difficulty working gracefully with templates. For example, setting a debug breakpoint within a template from a source file may either miss setting the breakpoint in the actual instantiation desired or may set a breakpoint in every place the template is instantiated.
Also, because the compiler needs to perform macro-like expansions of templates and generate different instances of them at compile time, the implementation source code for the templated class or function must be available (e.g. included in a header) to the code using it. Templated classes or functions, including much of the Standard Template Library (STL), cannot be compiled. (This is in contrast to non-templated code, which may be compiled to binary, providing only a declarations header file for code using it.) This may be a disadvantage by exposing the implementing code, which removes some abstractions, and could restrict its use in closed-source projects.[citation needed]

[edit] Templates in D
The D programming language supports templates that are evolved from those in C++. Most C++ template idioms will carry over to D without alteration, but D adds functionality that streamlines some common cases.
The most obvious differences are syntax changes. D uses parentheses ( ) instead of angle-brackets < > in a template definition. It also uses the !( ) construct (that is, parentheses preceded by an exclamation point) instead of angle-brackets in template instantiation. Therefore, a!(b) in D is the equivalent of a<b> in C++. These changes were made in the interest of making templates easier to parse, as using angle-brackets can lead to ambiguous syntax.

[edit] Static-if
D provides a static if construct that checks conditions at compile-time. This is vaguely analogous to C++'s #if and #endif preprocessor macross. The major difference is that static if has access to all compile-time values, including template arguments. Therefore, many situations which require template specialization in C++ may be written inline in D. Recursive templates in D can look almost identical to their runtime equivalents. This is shown in the classic compile-time factorial template.


template factorial(uint n) {
    static if (n < 2)
        const uint factorial = 1;
    else
        const uint factorial = n * factorial!(n-1);
}


[edit] Alias parameters
Templates in D may also accept alias parameters. Alias parameters are similar to C++'s typedef but can also substitute templates parameters. This is a superset of the functionality of template arguments in C++, and will be added in the forthcoming C++0x specification. Alias parameters may be templates, functions, types, or any other compile-time symbol. This allows a coder to, for example, "inject" a function into the middle of a template function.


template wrapper(alias Fn) {
    // Wraps a D function with an "extern(C)" interface.
    extern(C) void wrapper() {
        Fn();
    }
}

This sort of template might be useful when interfacing D code with a C API. If a hypothetical C API wants a function pointer, you might use the template like this:


void foo() {
    // ...
}
 
some_c_function(&wrapper!(foo));


[edit] Generics in Java
Main article: Generics in Java
Support for the generics, or "containers-of-type-T", subset of generic programming were added to the Java programming language in 2004 as part of J2SE 5.0. In Java, generics are checked at compile time for type correctness. The generic type information is then removed via a process called type erasure, and is unavailable at runtime. For example, a List<String> is converted to the raw type List. The compiler inserts type casts to convert the elements to the String type when they are retrieved from the list.

[edit] Generic programming in C# and .NET
Generics in C# (and other .NET languages) were added as part of .NET Framework 2.0 in November 2005. Although similar to generics in Java, .NET generics do not apply type erasure, but implement generics as a first class object in the runtime using reification. This design choice provides additional functionality, such as allowing reflection with preservation of generic types, as well as alleviating some of the limitations of erasure (such as being unable to create generic arrays).[1][2] This also means that there is no performance hit from runtime casts and normally expensive boxing conversions. When primitive and value types are used as generic arguments, they get specialized implementations, allowing for efficient generic collections and methods. As in C++ and Java, nested generic types such as Dictionary<string, List<int>> are valid types.
C# (and .NET in general) allows six varieties of generic type constraints using the where keyword including restricting generic types to be value types, to be classes, to have constructors, and to inherit from interfaces.[3] Below is an example with an interface constraint:


class Sample
{
  public static void Main()
  {
    int[] list = { 0, 1, 2, 3 };
    MakeAtLeast<int>(list, 2); // change array to { 2, 2, 2, 3 }
  }
 
  public static void MakeAtLeast<T>(IList<T> list, T lowest) where T : IComparable<T>
  {
    for (int i = 0; i < list.Count; i++)
      if (list[i].CompareTo(lowest) < 0) list[i] = lowest;
  }
}

Since all arrays implement the IList<T> interface (commonly associated with list classes), the MakeAtLeast() method allows operation on arrays, with elements of type T. The method's type constraint indicates that the method is applicable to any type T that implements the generic IComparable<T> interface. This ensures a compile time error if the method is called with a list of another type. The interface provides the generic method CompareTo(T).
The above method could also be written without generic types, simply using the non-generic IList type. However, this would make the method less type safe, as it would allow the method to be applied to a list of incomparable items, resulting in a run time error. The method would need to access the list items as objects instead, and would require casting to compare two elements. (For value types like types such as int this requires a boxing conversion, although this can be worked around using the Comparer<T> class, as is done in the standard collection classes.)

[edit] Generic programming in Delphi
Generic support was added to Delphi language in October 2008. The first generic support to Generics was Delphi 2007 .NET in 2006, but it was only for .NET platform, and real support for Generics in Delphi was added in Delphi 2009.

[edit] Generic programming in Functional languages

[edit] Generic programming in Haskell
Six of the predefined type classes in Haskell (including Eq, the types that can be compared for equality, and Show, the types whose values can be rendered as strings) have the special property of supporting derived instances. This means that a programmer defining a new type can state that this type is to be an instance of one of these special type classes, without providing implementations of the class methods as is usually necessary when declaring class instances. All the necessary methods will be "derived" -- that is, constructed automatically -- based on the structure of the type. For instance, the following declaration of a type of binary trees states that it is to be an instance of the classes Eq and Show:


data BinTree a = Leaf a | Node (BinTree a) a (BinTree a)
      deriving (Eq, Show)

This results in an equality function (==) and a string representation function (show) being automatically defined for any type of the form BinTree T provided that T itself supports those operations.
The support for derived instances of Eq and Show makes their methods == and show generic in a qualitatively different way from parametrically polymorphic functions: these "functions" (more accurately, type-indexed families of functions) can be applied to values of various types, and although they behave differently for every argument type, little work is needed to add support for a new type. Ralf Hinze (2004) has shown that a similar effect can be achieved for user-defined type classes by certain programming techniques. Other researchers have proposed approaches to this and other kinds of genericity in the context of Haskell and extensions to Haskell (discussed below).

[edit] PolyP
PolyP was the first generic programming language extension to Haskell. In PolyP, generic functions are called polytypic. The language introduces a special construct in which such polytypic functions can be defined via structural induction over the structure of the pattern functor of a regular datatype. Regular datatypes in PolyP are a subset of Haskell datatypes. A regular datatype t must be of kind * → *, and if a is the formal type argument in the definition, then all recursive calls to t must have the form t a. These restrictions rule out higher-kinded datatypes as well as nested datatypes, where the recursive calls are of a different form. The flatten function in PolyP is here provided as an example:


   flatten :: Regular d => d a -> [a]
   flatten = cata fl
 
   polytypic fl :: f a [a] -> [a]
     case f of
       g+h -> either fl fl
       g*h -> \(x,y) -> fl x ++ fl y
       () -> \x -> []
       Par -> \x -> [x]
       Rec -> \x -> x
       d@g -> concat . flatten . pmap fl
       Con t -> \x -> []
 
   cata :: Regular d => (FunctorOf d a b -> b) -> d a -> b


[edit] Generic Haskell
Generic Haskell is another extension to Haskell, developed at Utrecht University in The Netherlands. The extensions it provides are:

Type-indexed values are defined as a value indexed over the various Haskell type constructors (unit, primitive types, sums, products, and user-defined type constructors). In addition, we can also specify the behaviour of a type-indexed values for a specific constructor using constructor cases, and reuse one generic definition in another using default cases.

The resulting type-indexed value can be specialised to any type.

Kind-indexed types are types indexed over kinds, defined by giving a case for both * and k → k'. Instances are obtained by applying the kind-indexed type to a kind.
Generic definitions can be used by applying them to a type or kind. This is called generic application. The result is a type or value, depending on which sort of generic definition is applied.
Generic abstraction enables generic definitions be defined by abstracting a type parameter (of a given kind).
Type-indexed types are types which are indexed over the type constructors. These can be used to give types to more involved generic values. The resulting type-indexed types can be specialised to any type.

As an example, the equality function in Generic Haskell:[4]


   type Eq {[ * ]} t1 t2 = t1 -> t2 -> Bool
   type Eq {[ k -> l ]} t1 t2 = forall u1 u2. Eq {[ k ]} u1 u2 -> Eq {[ l ]} (t1 u1) (t2 u2)
 
   eq {| t :: k |} :: Eq {[ k ]} t t
   eq {| Unit |} _ _ = True
   eq {| :+: |} eqA eqB (Inl a1) (Inl a2) = eqA a1 a2
   eq {| :+: |} eqA eqB (Inr b1) (Inr b2) = eqB b1 b2
   eq {| :+: |} eqA eqB _ _ = False
   eq {| :*: |} eqA eqB (a1 :*: b1) (a2 :*: b2) = eqA a1 a2 && eqB b1 b2
   eq {| Int |} = (==)
   eq {| Char |} = (==)
   eq {| Bool |} = (==)


[edit] The "Scrap your boilerplate" approach
The Scrap your boilerplate approach is a lightweight generic programming approach for Haskell (Lämmel and Peyton Jones, 2003). A web site for this approach explains which components of it are currently implemented in GHC. Uniplate is an even simpler package with a similar basic approach.[1]

[edit] Clean
Clean offers generic programming based PolyP and the generic Haskell as supported by the GHC>=6.0. It parametrizes by kind as those but offers overloading.

[edit] Generic programming features in other languages
Standard ML and OCaml provide functors, which are similar to class templates and to Ada's generic packages. Scheme syntactic abstractions also have connection to generic programming -- these are in fact a superset of templating a la C++.

[edit] See also

Partial evaluation
Concept (generic programming)
Type polymorphism


[edit] External links and references

[edit] General

Bertrand Meyer. "Genericity vs Inheritance." In OOPSLA (First ACM Conference on Object-Oriented Programming Systems, Languages and Applications), Portland (Oregon), September 29–October 2, 1986, pages 391–405.
Gabriel Dos Reis and Jaakko Järvi, What is Generic Programming?, LCSD 2005.
Alexander A. Stepanov, Collected Papers of Alexander A. Stepanov (creator of the STL)
http://www.generic-programming.org


[edit] C++/D

Walter Bright, Templates Revisited.
David Vandevoorde, C++ Templates: The Complete Guide, 2003 Addison-Wesley. ISBN 0-201-73484-2


[edit] C#/.NET

Jason Clark, "Introducing Generics in the Microsoft CLR," September 2003, MSDN Magazine, Microsoft.
Jason Clark, "More on Generics in the Microsoft CLR," October 2003, MSDN Magazine, Microsoft.
M. Aamir Maniar, Generics.Net. An open source generics library for C#.


[edit] Delphi

Nick Hodges, "Delphi 2009 Reviewers Guide," October 2008, CodeGear Developer Network, CodeGear.
Craig Stuntz, "Delphi 2009 Generics and Type Constraints," October 2008
Dr. Bob, "Delphi 2009 Generics"


[edit] Haskell/functional

Dæv Clarke, Johan Jeuring and Andres Löh, The Generic Haskell user's guide
Ralf Hinze, "Generics for the Masses," In Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP), 2004.
Simon Peyton Jones, editor, The Haskell 98 Language Report, Revised 2002.
Ralf Lämmel and Simon Peyton Jones, "Scrap Your Boilerplate: A Practical Design Pattern for Generic Programming," In Proceedings of the ACM SIGPLAN International Workshop on Types in Language Design and Implementation (TLDI'03), 2003. (Also see the website devoted to this research)
Andres Löh, Exploring Generic Haskell, Ph.D. thesis, 2004 Utrecht University. ISBN 90-393-3765-9
Generic Haskell: a language for generic programming


[edit] Java

Gilad Bracha, Generics in the Java Programming Language, 2004.
Maurice Naftalin and Philip Wadler, Java Generics and Collections, 2006, O'Reilly Media, Inc. ISBN 0-596-52775-6
Peter Sestoft, Java Precisely, Second Edition, 2005 MIT Press. ISBN 0-262-69325-9
Generic Programming In Java, 2004 Sun Microsystems, Inc.
Angelika Langer, Java Generics FAQs


[edit] Object Pascal

Free Pascal: Free Pascal Reference guide Chapter 8: Generics, Michaël Van Canneyt, 2007
Delphi for Win32: Generics with Delphi 2009 Win32, Sébastien DOERAENE, 2008
Delphi for .NET: Delphi Generics, Felix COLIBRI, 2008


[edit] Notes

^ C#: Yesterday, Today, and Tomorrow: An Interview with Anders Hejlsberg
^ Generics in C#, Java, and C++
^ Constraints on Type Parameters (C# Programming Guide)
^ The Generic Haskell User's Guide




Retrieved from "http://en.wikipedia.org/wiki/Generic_programming"
Categories: Generic programmingHidden categories: All articles with unsourced statements | Articles with unsourced statements since March 2009 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Česky
Deutsch
Eesti
Español
Français
한국어
Nederlands
日本語
‪Norsk (bokmål)‬
Polski
Português
Русский
Српски / Srpski
Українська
粵語
中文









 This page was last modified on 3 April 2009, at 11:00.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
