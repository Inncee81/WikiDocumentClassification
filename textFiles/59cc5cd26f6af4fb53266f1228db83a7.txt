













Delegation pattern - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Delegation_pattern";
		var wgTitle = "Delegation pattern";
		var wgAction = "view";
		var wgArticleId = "148655";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 283564450;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-php {line-height: normal;}
.source-php li, .source-php pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for php
 * CSS class: source-php, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-php .de1, .source-php .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-php  {}
.source-php .head {}
.source-php .foot {}
.source-php .imp {font-weight: bold; color: red;}
.source-php .ln-xtra {color: #cc0; background-color: #ffc;}
.source-php li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-php li.li2 {font-weight: bold;}
.source-php .kw1 {color: #b1b100;}
.source-php .kw2 {color: #000000; font-weight: bold;}
.source-php .kw3 {color: #000066;}
.source-php .co1 {color: #808080; font-style: italic;}
.source-php .co2 {color: #808080; font-style: italic;}
.source-php .coMULTI {color: #808080; font-style: italic;}
.source-php .es0 {color: #000099; font-weight: bold;}
.source-php .br0 {color: #66cc66;}
.source-php .st0 {color: #ff0000;}
.source-php .nu0 {color: #cc66cc;}
.source-php .me1 {color: #006600;}
.source-php .me2 {color: #006600;}
.source-php .sc0 {}
.source-php .sc1 {}
.source-php .sc2 {}
.source-php .sc3 {}
.source-php .re0 {color: #0000ff;}
.source-php .re1 {color: #ff0000}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-eiffel {line-height: normal;}
.source-eiffel li, .source-eiffel pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for eiffel
 * CSS class: source-eiffel, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-eiffel .de1, .source-eiffel .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-eiffel  {}
.source-eiffel .head {}
.source-eiffel .foot {}
.source-eiffel .imp {font-weight: bold; color: red;}
.source-eiffel .ln-xtra {color: #cc0; background-color: #ffc;}
.source-eiffel li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-eiffel li.li2 {font-weight: bold;}
.source-eiffel .kw1 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw2 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw3 {color: #800080;}
.source-eiffel .kw4 {color: #800000}
.source-eiffel .kw5 {color: #603000;}
.source-eiffel .co1 {color: #008000; font-style: italic;}
.source-eiffel .coMULTI {}
.source-eiffel .es0 {color: #005070; font-weight: bold;}
.source-eiffel .br0 {color: #600000;}
.source-eiffel .st0 {color: #0080A0;}
.source-eiffel .nu0 {color: #FF0000;}
.source-eiffel .me1 {color: #000060;}
.source-eiffel .me2 {color: #000050;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Delegation pattern

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
In software engineering, the delegation pattern is a technique where an object outwardly expresses certain behaviour but in reality delegates responsibility for implementing that behavior to an associated object in an Inversion of Responsibility. The delegation pattern is the fundamental abstraction that underpins composition (also referred to as aggregation), mixins and aspects.




Contents


1 Examples

1.1 Simple Java example
1.2 Complex Java example
1.3 Complex C++ example
1.4 Objective-C example
1.5 Example using PHP
1.6 Complex Eiffel example


2 Criticisms
3 See also
4 External Links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Examples

[edit] Simple Java example
In this Java programming language example, the class C has method stubs that forward the methods f() and g() to class A. Class C pretends that it has attributes of class A.


 class A {
     void f() { System.out.println("A: doing f()"); }
     void g() { System.out.println("A: doing g()"); }
 }
 
 class C {
     // delegation
     A a = new A();
 
     void f() { a.f(); }
     void g() { a.g(); }
 
     // normal attributes
     X x = new X();
     void y() { /* do stuff */ }
 }
 
 public class Main {
     public static void main(String[] args) {
         C c = new C();
         c.f();
         c.g();
     }
 }


[edit] Complex Java example
By using interfaces, delegation can be made more flexible and typesafe. In this example, class C can delegate to either class A or class B. Class C has methods to switch between classes A and B. Including the implements clauses improves type safety, because each class must implement the methods in the interface. The main tradeoff is more code.


 interface I {
     void f();
     void g();
 }
 
 class A implements I {
     public void f() { System.out.println("A: doing f()"); }
     public void g() { System.out.println("A: doing g()"); }
 }
 
 class B implements I {
     public void f() { System.out.println("B: doing f()"); }
     public void g() { System.out.println("B: doing g()"); }
 }
 
 class C implements I {
     // delegation
     I i = new A();
 
     public void f() { i.f(); }
     public void g() { i.g(); }
 
     // normal attributes
     void toA() { i = new A(); }
     void toB() { i = new B(); }
 }
 
 
 public class Main {
     public static void main(String[] args) {
         C c = new C();
         c.f();     // output: A: doing f()
         c.g();     // output: A: doing g()
         c.toB();
         c.f();     // output: B: doing f()
         c.g();     // output: B: doing g()
     }
 }


[edit] Complex C++ example
This example is a C++ version of the complex Java example above. Since C++ does not have an interface construct, a pure virtual class plays the same role. The advantages and disadvantages are largely the same as in the Java example.


 #include <iostream>
 using namespace std;
 
 class I {
   public:
     virtual void f() = 0;
     virtual void g() = 0;
     virtual ~I() {}
 };
 
 class A : public I {
   public:
     void f() { cout << "A: doing f()" << endl; }
     void g() { cout << "A: doing g()" << endl; }
     ~A() { cout << "A: cleaning up." << endl; }
 };
 
 class B : public I {
   public:
     void f() { cout << "B: doing f()" << endl; }
     void g() { cout << "B: doing g()" << endl; }
     ~B() { cout << "B: cleaning up." << endl; }
 };
 
 class C : public I {
   public:
     // construction/destruction
     C() : i( new A() ) { }
     virtual ~C() { delete i; }
 
   private:
     // delegation
     I* i;
 
   public:
     void f() { i->f(); }
     void g() { i->g(); }
 
     // normal attributes
     void toA() { delete i; i = new A(); }
     void toB() { delete i; i = new B(); }
 };
 
 int main() {
     // we use by default the instance of A.
     C c;
     // Here we are calling A methods.
     c.f();
     c.g();
     // Here delete the instance of A and switch with the instance of B.
     c.toB();
     // Now with the same methods we are calling B methods.
     c.f();
     c.g();
 
     // The delegate is deleted by normal C++ scoping rules.
 }

The output is :
A: doing f()
A: doing g()
A: cleaning up.
B: doing f()
B: doing g()
B: cleaning up.

[edit] Objective-C example
Delegation is very common in the Cocoa framework (the most common client library of Objective-C). Here's an example involving a scrolling view, which will ask its delegate if it's okay to scroll to a certain point before doing so.


 @interface TCScrollView : NSView// A custom view that scrolls its children.
 {
    id delegate; // A delegate that wants to act on events in this view
 }
 -(IBAction)scrollToCenter:(id)sender; // A method that can be bound to a button in the UI
 -(void)scrollToPoint:(NSPoint)to;
 
 // Accessors. Implementation not shown.
 @property (nonatomic, assign) id delegate;
 @end
 
 // A category on NSObject describing possible TCScrollView delegate methods.
 // This is an informal protocol: implementor doesn't have to implement all or even any of 
 // the methods in the protocol
 @interface NSObject (TCScrollViewDelegate) 
 -(BOOL)scrollView:(TCScrollView*)scrollView shouldScrollToPoint:(NSPoint)newPoint;
 @end
 
 @implementation TCScrollView
 -(IBAction)scrollToCenter:(id)sender; { 
   [self scrollToPoint:NSPointMake(0,0)];
 }
 -(void)scrollToPoint:(NSPoint)to;
 {
   BOOL shouldScroll = YES;
   // If we have a delegate, and that delegate indeed does implement our delegate method,
   if(delegate && [delegate respondsToSelector:@selector(scrollView:shouldScrollToPoint:)])
     shouldScroll = [delegate scrollView:self shouldScrollToPoint:to]; // ask it if it's okay to scroll to this point.
 
   if(!shouldScroll) return;  // If not, ignore the scroll request.
 
   /// Scrolling code omitted.
 }
 @end
 
 
 @interface MyCoolAppController
 {
    IBOutlet TCScrollView* scrollView;
 }
 @end
 @implementation MyCoolAppController
 -(void)awakeFromNib; {
   [scrollView setDelegate:self];
 }
 -(BOOL)scrollView:(TCScrollView*)scrollView shouldScrollToPoint:(NSPoint)newPoint;
 {
   if(newPoint.x > 0 && newPoint.y > 0)
     return YES;
   return NO;
 }
 @end


[edit] Example using PHP





This article may contain material not appropriate for an encyclopedia. Please discuss this issue on the talk page.


Say you write a parent class to model cats and then extend the class to specific cats:


 class Cat {
   function Meow()
   {
     echo 'Meow' ;
   }
   function Snuggle()
   {
     echo 'Purr' ;
   }
   function Eat()
   {
     $this->meow() ;
     $this->meow() ;
     $this->meow() ;
     echo 'I begged until I got food, now I am eating' ;
   }
   function Sleep()
   {
      echo 'Curling up on cat bed' ;
   }
 }
 
 class Tabby extends Cat
 {
   function Draw()
   {
     echo 'I look like a tabby' ;
   }
 }
 
 class BlackCat extends Cat
 {
   function Draw()
   {
     echo 'I have sleek black fur' ;
   }
 }

This code is fine; however, let's say you watch a documentary about lions and realize you didn't model lions. At the same time you also think you would like to add in cheetahs and tigers, so you set about implementing the following Lion class.


 class Lion extends Cat
 {
   function Meow()
   {
     echo "I can't meow" ;
   }
   function Roar()
   {
     echo 'roar' ;
   }
   function Snuggle()
   {
     echo 'Eat the fool who tried to snuggle with me' ;
   }
   function Sleep()
   {
     echo 'Curling up under tree';
   }
   function Eat()
   {
     echo 'Hunt gazelles' ;
   }
   function Draw()
   {
     echo 'I look like a lion' ;
   }
 }

So now you have a lion class, however you also have a new roar() method. Now you have to edit all your code to test if this is a lion, and if so call roar instead of meow. You realize that tigers also roar, sleep under trees and don't snuggle well, but they don't eat gazelles. Perhaps you could make a big cat class and extend it to tigers and lions and override the base classes. But then you realize a cheetah is a big cat that sleeps under trees and eat gazelles, but they don't roar. This is getting messier by the minute. Next you see another documentary with civet cats and they eat birds and sleep in the trees and make a different sound. Oh no! Your code is now a disaster filled with classes extended left and right with all kinds of methods being overridden. On top of all this you also realize that if you end up with hundreds of cats who sleep under trees that override the sleep method and want to change what that method does, you will need to edit every single place that is overridden.
Let's try this a little differently and define an abstract cat interface as follows:


 abstract class ICat
 {
   private $SoundBehavior ;
   private $SnuggleBehavior ;
   private $EatBehavior ;
   private $SleepBehavior ;
 
   function MakeSound()
   {
     $this->SoundBehavior->MakeSound() ;
   }
   function Snuggle()
   {
     $this->SnuggleBehavior->Snuggle() ;
   }
   function Eat()
   {
     $this->EatBehavior->Eat() ;
   }
   function Sleep()
   {
     $this->SleepBehavior->Sleep() ;
   }
   function Draw(){}
   function setSoundBehavior( $SoundBehavior )
   {
     $this->SoundBehavior = $SoundBehavior ;
   }
   function setSnuggleBehavior( $SnuggleBehavior )
   {
     $this->SnuggleBehavior = $SnuggleBehavior ;
   }    
   function setEatBehavior( $EatBehavior )
   {
     $this->EatBehavior = $EatBehavior ;
   }
   function setSleepBehavior( $SleepBehavior )
   {
     $this->SleepBehavior = $SleepBehavior ;
   }
 }

Now create an interface for each behavior, then an implementation using SoundBehavior as an example (each behavior would need its own interface/implementation):


 interface SoundBehavior
 {
   function MakeSound(){}
 }
 class Roar implements SoundBehavior
 {
   function MakeSound()
   {
     echo 'Roar' ;
   }
 }
 class Meow implements SoundBehavior
 {
   function MakeSound()
   {
     echo 'Meow' ;
   }
 }

Assuming you created all your behaviours, let's define a lion and a cat


 class HouseCat extends ICat
 {
   function Cat()
   {
     $this->SetSoundBehavior( new Meow() ) ;
     $this->SetSnuggleBehavior( new PurrSnuggle() ) ;
     $this->SetEatBehavior( new BegForFood() ) ;
     $this->SetSleepBehavior( new SleepInBed() ) ;
   }
   function Draw()
   {
     echo 'I look like a plain cat' ;
   }
 }
 
 class Tabby Extends HouseCat
 {
   function Draw()
   {
     echo 'I look like a Tabby' ;
   }
 }
 
 class Tiger extends ICat
 {
   function Cat()
   {
     $this->SetSoundBehavior( new Roar() ) ;
     $this->SetSnuggleBehavior( new EatSnuggler() ) ;
     $this->SetEatBehavior( new HuntGazelles() ) ;
     $this->SetSleepBehavior( new SleepUnderTree() ) ;
   }
   function Draw()
   {
     echo 'I look like a tiger' ;
   }
 }

This final abstract interface ICat, delegates responsibility of cat behavior instead of using methods in a base class and overriding them where needed. If we didn't use delegation above we would need to override base method classes repeatedly in subclasses. Additional classes can be added which share some, but not all, of the cat functionality using a different set of delegates.

[edit] Complex Eiffel example
This example is a Eiffel version of the complex Java example above.


 deferred class I feature
     f is deferred end
     g is deferred end
 end
 
 class A inherit I feature
     f is do print("A: doing f%N") end
     g is do print("A: doing g%N") end
 end
 
 class B inherit I feature
     f is do print("B: doing f%N") end
     g is do print("B: doing g%N") end
 end
 
 class C inherit I creation to_a, to_b feature
     i: I
 
     f is do i.f end
     g is do i.g end
 
     to_a is do create {A} i end
     to_b is do create {B} i end
 end
 
 class MAIN creation main feature
     main is local c: C do
         create c.to_a
         c.f
         c.g
         c.to_b
         c.f
         c.g
     end
 end


[edit] Criticisms
This pattern typically sacrifices speed optimization in favor of enhanced clarity of abstraction.

[edit] See also

Delegation (programming)
Design pattern
Post-object programming


[edit] External Links



Retrieved from "http://en.wikipedia.org/wiki/Delegation_pattern"
Categories: Software design patterns | Articles with example PHP code | Articles with example Java code | Articles with example C++ codeHidden categories: Articles which may be unencyclopedic 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Русский
中文









 This page was last modified on 13 April 2009, at 14:23 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
