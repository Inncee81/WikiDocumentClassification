













XML - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "XML";
		var wgTitle = "XML";
		var wgAction = "view";
		var wgArticleId = "34138";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 281379327;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-xml {line-height: normal;}
.source-xml li, .source-xml pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for xml
 * CSS class: source-xml, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-xml .de1, .source-xml .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-xml  {}
.source-xml .head {}
.source-xml .foot {}
.source-xml .imp {font-weight: bold; color: red;}
.source-xml .ln-xtra {color: #cc0; background-color: #ffc;}
.source-xml li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-xml li.li2 {font-weight: bold;}
.source-xml .coMULTI {color: #808080; font-style: italic;}
.source-xml .es0 {color: #000099; font-weight: bold;}
.source-xml .br0 {color: #66cc66;}
.source-xml .st0 {color: #ff0000;}
.source-xml .nu0 {color: #cc66cc;}
.source-xml .sc0 {color: #00bbdd;}
.source-xml .sc1 {color: #ddbb00;}
.source-xml .sc2 {color: #339933;}
.source-xml .sc3 {color: #009900;}
.source-xml .re0 {color: #000066;}
.source-xml .re1 {font-weight: bold; color: black;}
.source-xml .re2 {font-weight: bold; color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-text .de1, .source-text .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-text  {}
.source-text .head {}
.source-text .foot {}
.source-text .imp {font-weight: bold; color: red;}
.source-text .ln-xtra {color: #cc0; background-color: #ffc;}
.source-text li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-text li.li2 {font-weight: bold;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); XML

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article may be too long to comfortably read and navigate. Please consider splitting content into sub-articles and using this article for a summary of the key points of the subject. (March 2009)



XML




Filename extension
.xml


Internet media type
application/xml, text/xml (deprecated)


Uniform Type Identifier
public.xml


Developed by
World Wide Web Consortium


Type of format
Markup language


Extended from
SGML


Extended to
XHTML, RSS, Atom, ...


Standard(s)
1.0 (Fifth Edition) 1.1 (Second Edition)


XML (Extensible Markup Language) is a general-purpose specification for creating custom markup languages.[1] It is classified as an extensible language, because it allows the user to define the mark-up elements. XML's purpose is to aid information systems in sharing structured data, especially via the Internet, [2] to encode documents, and to serialize data; in the last context, it compares with text-based serialization languages such as JSON, YAML and S-Expressions. [3]
XML's set of tools helps developers in creating web pages but its usefulness goes well beyond that. XML, in combination with other standards, makes it possible to define the content of a document separately from its formatting, making it easy to reuse that content in other applications or for other presentation environments. Most importantly, XML provides a basic syntax that can be used to share information between different kinds of computers, different applications, and different organizations without needing to pass through many layers of conversion.[4] [5]
XML began as a simplified subset of the Standard Generalized Markup Language (SGML), meant to be readable by people via semantic constraints; application languages can be implemented in XML. These include XHTML,[6] RSS, MathML, GraphML, Scalable Vector Graphics, MusicXML, and others. Moreover, XML is sometimes used as the specification language for such application languages.
XML is recommended by the World Wide Web Consortium (W3C). It is a fee-free open standard. The recommendation specifies lexical grammar and parsing requirements.




Contents


1 Correctness
2 Well-formedness

2.1 Entity references

2.1.1 Numeric character references


2.2 Well-formed documents
2.3 Automatic verification


3 Validity

3.1 DTD
3.2 XML Schema
3.3 RELAX NG
3.4 ISO DSDL and other schema languages
3.5 International use


4 Displaying on the web
5 Extensions
6 Processing files

6.1 Simple API for XML (SAX)
6.2 DOM
6.3 Transformation engines and filters
6.4 Pull parsing
6.5 Non-extractive processing API
6.6 Data binding
6.7 Specific applications and editors


7 History

7.1 Sources
7.2 Versions
7.3 Patent claims


8 Criticism

8.1 Advantages
8.2 Disadvantages


9 In business
10 Standards
11 See also
12 Notes
13 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Correctness
An XML document has two correctness levels:

Well-formed. A well-formed document conforms to the XML syntax rules; e.g. if a start-tag (< >) appears without a corresponding end-tag (</>), it is not well-formed. A document not well-formed is not in XML; a conforming parser is disallowed from processing it.
Valid. A valid document additionally conforms to semantic rules, either user-defined or in an XML schema, especially DTD; e.g. if a document contains an undefined element, then it is not valid; a validating parser is disallowed from processing it.


[edit] Well-formedness
If only a well-formed element is required, XML is a generic framework for storing any amount of text or any data whose structure can be represented as a tree. The only indispensable syntactical requirement is that the document has exactly one root element (also known as the document element), i.e. the text must be enclosed between a root start-tag and a corresponding end-tag, known as a "well-formed" XML document:


<book>This is a book... </book>

The root element can be preceded by an optional XML declaration element stating what XML version is in use (normally 1.0); it might also contain character encoding and external dependencies information.


<?xml version="1.0" encoding="UTF-8" ?>

The specification requires that processors of XML support the pan-Unicode character encodings UTF-8 and UTF-16 (UTF-32 is not mandatory). The use of more limited encodings, e.g. those based on ISO/IEC 8859, is acknowledged, widely used, and supported.
Comments can be placed anywhere in the tree, including in the text if the content of the element is text or #PCDATA.
XML comments start with <!-- and end with -->. Two consecutive dashes (--) may not appear anywhere in the text of the comment.


<!-- This is a comment. -->

In any meaningful application, additional markup is used to structure the contents of the XML document. The text enclosed by the root tags may contain an arbitrary number of XML elements. The basic syntax for one element is:


<element_name attribute_name="attribute_value">Element Content</element_name>

The two instances of »element_name« are referred to as the start-tag and end-tag, respectively. Here, »Element Content« is some text which may again contain XML elements. So, a generic XML document contains a tree-based data structure. Here is an example of a structured XML document:


 <recipe name="bread" prep_time="5 mins" cook_time="3 hours">
   <title>Basic bread</title>
   <ingredient amount="8" unit="dL">Flour</ingredient>
   <ingredient amount="10" unit="grams">Yeast</ingredient>
   <ingredient amount="4" unit="dL" state="warm">Water</ingredient>
   <ingredient amount="1" unit="teaspoon">Salt</ingredient>
   <instructions>
     <step>Mix all ingredients together.</step>
     <step>Knead thoroughly.</step>
     <step>Cover with a cloth, and leave for one hour in warm room.</step>
     <step>Knead again.</step>
     <step>Place in a bread baking tin.</step>
     <step>Cover with a cloth, and leave for one hour in warm room.</step>
     <step>Bake in the oven at 180(degrees)C for 30 minutes.</step>
   </instructions>
 </recipe>

Attribute values must always be quoted, using single or double quotes, and each attribute name may appear only once in any single element.
XML requires that elements be properly nested—elements may never overlap, and so must be closed in the order opposite to which they are opened. For example, this fragment of code below cannot be part of a well-formed XML document because the title and author elements are closed in the wrong order:


<!-- WRONG! NOT WELL-FORMED XML! -->
<title>Book on Logic<author>Aristotle</title></author>

One way of writing the same information in a way which could be incorporated into a well-formed XML document is as follows:


<!-- Correct: well-formed XML fragment. -->
<title>Book on Logic</title> <author>Aristotle</author>

XML provides special syntax for representing an element with empty content. Instead of writing a start-tag followed immediately by an end-tag, a document may contain an empty-element tag. An empty-element tag resembles a start-tag but contains a slash just before the closing angle bracket. The following three examples are equivalent in XML:


<foo></foo>
<foo />
<foo/>

An empty-element may contain attributes:


<info author="John Smith" genre="science-fiction" date="2009-Jan-01" />


[edit] Entity references
An entity in XML is a named body of data, usually text. Entities are often used to represent single characters that cannot easily be entered on the keyboard; they are also used to represent pieces of standard ("boilerplate") text that occur in many documents, especially if there is a need to allow such text to be changed in one place only.
Special characters can be represented either using entity references, or by means of numeric character references. An example of a numeric character reference is "&#x20AC;", which refers to the Euro symbol by means of its Unicode codepoint in hexadecimal.
An entity reference is a placeholder that represents that entity. It consists of the entity's name preceded by an ampersand ("&") and followed by a semicolon (";"). XML has five predeclared entities:

&amp; (& or "ampersand")
&lt; (< or "less than")
&gt; (> or "greater than")
&apos; (' or "apostrophe")
&quot; (" or "quotation mark")

Here is an example using a predeclared XML entity to represent the ampersand in the name "AT&T":


<company_name>AT&amp;T</company_name>

Additional entities (beyond the predefined ones) can be declared in the document's Document Type Definition (DTD). A basic example of doing so in a minimal internal DTD follows. Declared entities can describe single characters or pieces of text, and can reference each other.


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
    <!ENTITY copy "&#xA9;">
    <!ENTITY copyright-notice "Copyright &copy; 2009, XYZ Enterprises">
]>
<example>
    &copyright-notice;
</example>

When viewed in a suitable browser, the XML document above appears as:
Copyright © 2009, XYZ Enterprises

[edit] Numeric character references
Numeric character references look like entity references, but instead of a name, they contain the "#" character followed by a number. The number (in decimal or "x"-prefixed hexadecimal) represents a Unicode code point. Unlike entity references, they are neither predeclared nor do they need to be declared in the document's DTD. They have typically been used to represent characters that are not easily encodable, such as an Arabic character in a document produced on a European computer. The ampersand in the "AT&T" example could also be escaped like this (decimal 38 and hexadecimal 26 both represent the Unicode code point for the "&" character):


<company_name>AT&#38;T</company_name>
<company_name>AT&#x26;T</company_name>

Similarly, in the previous example, notice that "&#xA9;" is used to generate the “©” symbol.
See also numeric character references.

[edit] Well-formed documents
In XML, a well-formed document must conform to the following rules, among others:

Non-empty elements are delimited by both a start-tag and an end-tag.
Empty elements may be marked with an empty-element (self-closing) tag, such as <IAmEmpty />. This is equal to <IAmEmpty></IAmEmpty>.
All attribute values are quoted with either single (') or double (") quotes. Single quotes close a single quote and double quotes close a double quote.[citation needed]
To include a double quote inside an attribute value that is double quoted, or a single quote inside an attribute value that is single quoted, escape the inner quote mark using a Character entity reference. This is necessary when an attribute value must contain both types (single and double quotes) or when you do not have control over the type of quotation a particular XML editor uses for wrapping attribute values. These character entity references are predefined in XML and do not need to be declared even when using a DTD or Schema: &quot; and &apos;. You may also use the numeric character entity references (hex) &#x0022; and &#x0027; or their equivalent decimal notations &#0034; and &#0039;.
Tags may be nested but must not overlap. Each non-root element must be completely contained in another element.
The document complies with its declared character encoding. The encoding may be declared or implied externally, such as in "Content-Type" headers when a document is transported via HTTP, or internally, using explicit markup at the very beginning of the document. When no such declaration exists, a Unicode encoding is assumed, as defined by a Unicode Byte Order Mark before the document's first character. If the mark does not exist, UTF-8 encoding is assumed.

Element names are case-sensitive. For example, the following is a well-formed matching pair:

<Step> ... </Step>

whereas these are not

<Step> ... </step>
<STEP> ... </step>

By carefully choosing the names of the XML elements one may convey the meaning of the data in the markup. This increases human readability while retaining the rigor needed for software parsing.
Choosing meaningful names implies the semantics of elements and attributes to a human reader without reference to external documentation. However, this can lead to verbosity, which complicates authoring and increases file size.

[edit] Automatic verification
It is relatively simple to verify that a document is well-formed or validated XML, because the rules of well-formedness and validation of XML are designed for portability of tools. The idea is that any tool designed to work with XML files will be able to work with XML files written in any XML language (or XML application). Here are some examples of ways to verify XML documents:

load it into an XML-capable browser, such as Firefox or Internet Explorer
use a tool like xmlwf (usually bundled with expat)
parse the document, for instance in Ruby:


irb> require "rexml/document"
irb> include REXML
irb> doc = Document.new(File.new("test.xml")).root


[edit] Validity
By leaving the names, allowable hierarchy, and meanings of the elements and attributes open and definable by a customizable schema or DTD, XML provides a syntactic foundation for the creation of purpose-specific, XML-based markup languages. The general syntax of such languages is rigid — documents must adhere to the general rules of XML, ensuring that all XML-aware software can at least read and understand the relative arrangement of information within them. The schema merely supplements the syntax rules with a set of constraints. Schemas typically restrict element and attribute names and their allowable containment hierarchies, such as only allowing an element named 'birthday' to contain one element named 'month' and one element named 'day', each of which has to contain only character data. The constraints in a schema may also include data type assignments that affect how information is processed; for example, the 'month' element's character data may be defined as being a month according to a particular schema language's conventions, perhaps meaning that it must not only be formatted a certain way, but also must not be processed as if it were some other type of data.
An XML document that complies with a particular schema/DTD, in addition to being well-formed, is said to be valid.
Before the advent of generalised data description languages such as SGML and XML, software designers had to define special file formats or small languages to share data between programs. This required writing detailed specifications and special-purpose parsers and writers.
XML's regular structure and strict parsing rules allow software designers to leave parsing to standard tools, and since XML provides a general, data model-oriented framework for the development of application-specific languages, software designers need only concentrate on the development of rules for their data, at relatively high levels of abstraction.
Well-tested tools exist to validate an XML document "against" a schema: the tool automatically verifies whether the document conforms to constraints expressed in the schema. Some of these validation tools are included in XML parsers, and some are packaged separately.
Other usages of schemas exist: XML editors, for instance, can use schemas to support the editing process (by suggesting valid elements and attributes names, etc).

[edit] DTD
Main article: Document Type Definition
The oldest schema format for XML is the Document Type Definition (DTD), inherited from SGML. While DTD support is ubiquitous due to its inclusion in the XML 1.0 standard, it is seen as limited for the following reasons:

It has no support for newer features of XML, most importantly namespaces.
It lacks expressiveness. Certain formal aspects of an XML document cannot be captured in a DTD.
It uses a custom non-XML syntax, inherited from SGML, to describe the schema.

DTD is still used in many applications because it is considered the easiest to read and write.

[edit] XML Schema
Main article: XML Schema (W3C)
A newer XML schema language, described by the W3C as the successor of DTDs, is XML Schema, or more informally referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system, allow for more detailed constraints on an XML document's logical structure, and must be processed in a more robust validation framework. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them, although XSD implementations require much more than just the ability to read XML.

[edit] RELAX NG
Main article: RELAX NG
Another popular schema language for XML is RELAX NG. Initially specified by OASIS, RELAX NG is now also an ISO international standard (as part of DSDL). It has two formats: an XML based syntax and a non-XML compact syntax. The compact syntax aims to increase readability and writability but, since there is a well-defined way to translate the compact syntax to the XML syntax and back again by means of James Clark's Trang conversion tool, the advantage of using standard XML tools is not lost. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.

[edit] ISO DSDL and other schema languages
The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing.
Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide attribute defaults. RELAX NG and Schematron intentionally do not provide these; for example the infoset augmentation facility.

[edit] International use
XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the open corner bracket, "<"). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:


<?xml version="1.0" encoding="UTF-8"?>
<俄語>Китайский язык</俄語>


[edit] Displaying on the web
Generally, generic XML documents do not carry information about how to display the data.[7] Without using CSS or XSLT, a generic XML document is rendered as raw XML text by most web browsers. Some display it with 'handles' (e.g. + and - signs in the margin) that allow parts of the structure to be expanded or collapsed with mouse-clicks.
In order to style the rendering in a browser with CSS, the XML document must include a reference to the stylesheet:[8]


<?xml-stylesheet type="text/css" href="myStyleSheet.css"?>

Note that this is different from specifying such a stylesheet in HTML, which uses the <link> element.
XSLT (XSL Transformations) can be used to alter the format of XML data, either into HTML or other formats that are suitable for a browser to display.
To specify client-side XSLT, the following processing instruction is required in the XML:[9]


<?xml-stylesheet type="text/xml" href="myTransform.xslt"?>

Client-side XSLT is supported by many web browsers. Alternatively, one may use XSLT to convert XML into a displayable format on the server rather than being dependent on the end-user's browser capabilities. The end-user is not aware of what has gone on 'behind the scenes'; all they see is well-formatted, displayable data.
See the XSLT article for examples of XSLT in action.

[edit] Extensions

XPath makes it possible to refer to individual parts of an XML document. This provides random access to XML data for other technologies, including XSLT, XSL-FO, XQuery etc. XPath expressions can refer to all or part of the text, data and values in XML elements, attributes, processing instructions, comments etc. They can also access the names of elements and attributes. XPaths can be used in both valid and well-formed XML, with and without defined namespaces.
XQuery is to XML and XML Databases what SQL is to relational databases: ways to access, manipulate and return XML.
XInclude defines the ability for XML files to include all or part of an external file. When processing is complete, the final XML infoset has no XInclude elements, but instead has copied the documents or parts thereof into the final infoset. It uses XPath to refer to a portion of the document for partial inclusions.
XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring.
XML Signature defines the syntax and processing rules for creating digital signatures on XML content.
XML Encryption defines the syntax and processing rules for encrypting XML content.
XPointer is a system for addressing components of XML-based internet media.

XML files may be served with a variety of Media types. RFC 3023 defines the types "application/xml" and "text/xml", which say only that the data is in XML, and nothing about its semantics. The use of "text/xml" has been criticized as a potential source of encoding problems but is now in the process of being deprecated.[10] RFC 3023 also recommends that XML-based languages be given media types beginning in "application/" and ending in "+xml"; for example "application/atom+xml" for Atom. This page discusses further XML and MIME.

[edit] Processing files
Three traditional techniques for processing XML files are:

Using a programming language and the SAX API.
Using a programming language and the DOM API.
Using a transformation engine and a filter

More recent and emerging techniques for processing XML files are:

Pull Parsing
Non-Extractive Parsing (i.e. in-situ parsing)
Data binding


[edit] Simple API for XML (SAX)
SAX is a lexical, event-driven interface in which a document is read serially and its contents are reported as "callbacks" to various methods on a handler object of the user's design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.

[edit] DOM
DOM (Document Object Model) is an interface-oriented Application Programming Interface that allows for navigation of the entire document as if it were a tree of "Node" objects representing the document's contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM Nodes are abstract; implementations provide their own programming language-specific bindings. DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.

[edit] Transformation engines and filters
A filter in the Extensible Stylesheet Language (XSL) family can transform an XML file for displaying or printing.

XSL-FO is a declarative, XML-based page layout language. An XSL-FO processor can be used to convert an XSL-FO document into another non-XML format, such as PDF.
XSLT is a declarative, XML-based document transformation language. An XSLT processor can use an XSLT stylesheet as a guide for the conversion of the data tree represented by one XML document into another tree that can then be serialized as XML, HTML, plain text, or any other format supported by the processor.
XQuery is a W3C language for querying, constructing and transforming XML data.
XPath is a DOM-like node tree data model and path expression language for selecting data within XML documents. XSL-FO, XSLT and XQuery all make use of XPath. XPath also includes a useful function library.


[edit] Pull parsing
Pull parsing[11] treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, SimpleXML in PHP and System.Xml.XmlReader in .NET.
A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this 'iterator' can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace, values of XML attributes, value of text, etc.), and can also move the iterator to the 'next' item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.

[edit] Non-extractive processing API
Non-extractive XML Processing API is a new and emerging category of parsers that aim to overcome the fundamental limitations of DOM and SAX. The most representative is VTD-XML, which abolishes the object-oriented modeling of XML hierarchy and instead uses 64-bit Virtual Token Descriptors (encoding offsets, lengths, depths, and types) of XML tokens. VTD-XML's approach enables a number of interesting features/enhancements, such as high performance, low memory usage [12], ASIC implementation [13], incremental update [14], and native XML indexing [15] [16].

[edit] Data binding
Another form of XML Processing API is data binding, where XML data is made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB)[17], Liquid XML Data Binder for C++, Java, VB & .Net [18] and CodeSynthesis XSD for C++[19][20].

[edit] Specific applications and editors
The native file format of OpenOffice.org, AbiWord, and Apple's iWork applications is XML. Some parts of Microsoft Office 2007 are also able to edit XML files with a user-supplied schema (but not a DTD), and Microsoft has released a file format compatibility kit for Office 2003 that allows previous versions of Office to save in the new XML based format. There are dozens of other XML editors available.

[edit] History
The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.[21][22] By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web, and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C's activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.
XML was compiled by a working group of eleven members,[23] supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.[24] James Clark served as Technical Lead of the Working Group, notably contributing the empty-element "<empty/>" syntax and the name "XML". Other names that had been put forward for consideration included "MAGMA" (Minimal Architecture for Generalized Markup Applications), "SLIM" (Structured Language for Internet Markup) and "MGML" (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen. Halfway through the project Bray accepted a consulting engagement with Netscape, provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft's Jean Paoli as a third co-editor.
The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in twenty weeks of intense work between July and November 1996, when the first Working Draft of an XML specification was published.[25] Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.
XML 1.0 achieved the Working Group's goals of Internet usability, general-purpose usability, SGML compatibility, facilitation of easy development of processing software, minimization of optional features, legibility, formality, conciseness, and ease of authoring. Like its antecedent SGML, XML allows for some redundant syntactic constructs and includes repetition of element identifiers. In these respects, terseness was not considered essential in its structure.

[edit] Sources
XML is a profile of an ISO standard SGML, and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation (processing instructions), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set).
Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a 'transfer syntax'; HTML, in which elements were synchronous with their resource, the separation of document character set from resource encoding, the xml:lang attribute, and the HTTP notion that metadata accompanied the resource rather than being needed at the declaration of a link; and the Extended Reference Concrete Syntax (ERCS), from which XML 1.0's naming rules were taken, and which had introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters.
Ideas that developed during discussion which were novel in XML, were the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags.

[edit] Versions
There are two current versions of XML. The first, XML 1.0, was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use. The second, XML 1.1, was initially published on February 4, 2004, the same day as XML 1.0 Third Edition, and is currently in its second edition, as published on August 16, 2006. It contains features — some contentious — that are intended to make XML easier to use in certain cases[26] - mainly enabling the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 2.0. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features. [27]
Prior to the fifth edition of XML 1.0, it and XML 1.1 differed in the requirements of characters used for element and attribute names: the first four editions of XML 1.0 only allowed characters which are defined in Unicode 2.0, which includes most world scripts, but excludes those which were added in later Unicode versions. Among the excluded scripts are Mongolian, Cambodian, Amharic, Burmese, and others.
Almost any Unicode character can be used in the character data and attribute values of an XML 1.1 document, even if the character is not defined, aside from having a code point, in the current version of Unicode. The approach in XML 1.1 is that only certain characters are forbidden, and everything else is allowed, whereas in older editions of XML 1.0, only certain characters were explicitly allowed, and thus prior to its fifth edition XML 1.0 could not accommodate the addition of characters in future versions of Unicode.
In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for "robustness", most of the control characters introduced in XML 1.1 must be expressed as numeric character references. Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.
There are also discussions on an XML 2.0, although it seems unlikely[vague] if such will ever come about. XML-SW (SW for skunk works), written by one of the original developers of XML, contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces, XML Base and XML Information Set (infoset) into the base standard.
The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name Fast Infoset for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).

[edit] Patent claims
In October 2005 the small company Scientigo publicly asserted that two of its patents, U.S. Patent 5,842,213  and U.S. Patent 6,393,426 , apply to the use of XML. The patents cover the "modeling, storage and transfer [of data] in a particular non-hierarchical, non-integrated neutral form", according to their applications, which were filed in 1997 and 1999. Scientigo CEO Doyal Bryant expressed a desire to "monetize" the patents but stated that the company was "not interested in having us against the world." He said that Scientigo was discussing the patents with several large corporations.[28]
XML users and independent experts responded to Scientigo's claims with widespread skepticism and criticism. Some derided the company as a patent troll. Tim Bray described any claims that the patents covered XML as "ridiculous on the face of it".[29]

[edit] Criticism





This article's Criticism or Controversy section(s) may mean the article does not present a neutral point of view of the subject. It may be better to integrate the material in such sections into the article as a whole.







This article is in a list format that may be better presented using prose. You can help by converting this section to prose, if appropriate. Editing help is available. (January 2009)


Commentators have offered various critiques of XML, suggesting circumstances where XML provides both advantages and potential disadvantages.[30]

[edit] Advantages

XML provides a basic syntax that can be used to share information between different kinds of computers, different applications, and different organizations. [4] XML data is stored in plain text format.[31] This software- and hardware-independent way of storing data allows different incompatible systems to share data without needing to pass them through many layers of conversion. This also makes it easier to expand or upgrade to new operating systems, new applications, or new browsers, without losing any data.
With XML, your data can be available to all kinds of "reading machines" (Handheld computers, voice machines, news feeds, etc), and make it more available for blind people, or people with other disabilities.[31]
XML provides a gateway for communication between applications, even applications on wildly different systems. As long as applications can share data (through HTTP, file sharing, or another mechanism), and have an XML parser, they can share structured information that is easily processed. Databases can trade tables, business applications can trade updates, and document systems can share information. [4]
It supports Unicode, allowing almost any information in any written human language to be communicated.
It can represent common computer science data structures: records, lists and trees.
Its self-documenting format describes structure and field names as well as specific values.
The strict syntax and parsing requirements make the necessary parsing algorithms extremely simple, efficient, and consistent.
Content-based XML markup enhances searchability, making it possible for agents and search engines to categorize data instead of wasting processing power on context-based full-text searches.[4]
XML is heavily used as a format for document storage and processing, both online and offline.
It is based on international standards.
It can be updated incrementally.
It allows validation using schema languages such as XSD and Schematron, which makes effective unit-testing, firewalls, acceptance testing, contractual specification and software construction easier.
The hierarchical structure is suitable for most (but not all) types of documents.
It is platform-independent, thus relatively immune to changes in technology.
Forward and backward compatibility are relatively easy to maintain despite changes in DTD or Schema.
Its predecessor, SGML, has been in use since 1986, so there is extensive experience and software available.


[edit] Disadvantages

Difficult for the end-user to understand its capabilities.
XML syntax is redundant or large relative to binary representations of similar data,[32] especially with tabular data.
The redundancy may affect application efficiency through higher storage, transmission and processing costs.[33][34]
XML syntax is verbose, especially for human readers, relative to other alternative 'text-based' data transmission formats.[35][36]
The hierarchical model for representation is limited in comparison to an object oriented graph.[37][38]
Expressing overlapping (non-hierarchical) node relationships requires extra effort.[39]
XML namespaces are problematic to use and namespace support can be difficult to correctly implement in an XML parser.[40]
XML is commonly depicted as "self-documenting" but this depiction ignores critical ambiguities.[41][42]
The distinction between content and attributes in XML seems unnatural to some and makes designing XML data structures harder.[43]
Transformations, even identity transforms, result in changes to format (whitespace, attribute ordering, attribute quoting, whitespace around attributes, newlines). These problems can make diff-ing the XML source very difficult except via Canonical XML or ExamDiff Pro.
Encourages non-relational data structures (data non-normalized)


[edit] In business
XBRL (eXtensible Business Reporting Language), which is based on XML, is widely used in the financial world. Due to increased demand for financial transparency, XBRL technology helps facilitate the processes of transferring data and reporting financial results. Notably, the SEC requires some filings in XBRL, [44] and Japanese banks and institutions run XBRL projects including mandatory filing.[45]
Web publishing uses XML to have a single source for creating and updating all content, which significantly saves time and reduces costs for companies when printing documents. In addition, some governments use XML for large documentation and printing maps, and airplane and car manufactures may use XML technology to print maintenance booklets.[citation needed]

[edit] Standards
In addition to the ISO standards mentioned above, other related document include:


ISO/IEC 8825-4:2002 Information technology -- ASN.1 encoding rules: XML Encoding Rules (XER)
ISO/IEC 8825-5:2004 Information technology -- ASN.1 encoding rules: Mapping W3C XML schema definitions into ASN.1
ISO/IEC 9075-14:2006 Information technology -- Database languages -- SQL -- Part 14: XML-Related Specifications (SQL/XML)
ISO 10303-28:2007 Industrial automation systems and integration -- Product data representation and exchange -- Part 28: Implementation methods: XML representations of EXPRESS schemas and data, using XML schemas
ISO/IEC 13250-3:2007 Information technology -- Topic Maps -- Part 3: XML syntax
ISO/IEC 13522-5:1997 Information technology -- Coding of multimedia and hypermedia information -- Part 5: Support for base-level interactive applications
ISO/IEC 13522-8:2001 Information technology -- Coding of multimedia and hypermedia information -- Part 8: XML notation for ISO/IEC 13522-5
ISO/IEC 18056:2007 Information technology -- Telecommunications and information exchange between systems -- XML Protocol for Computer Supported Telecommunications Applications (CSTA) Phase III
ISO/IEC 19503:2005 Information technology -- XML Metadata Interchange (XMI)
ISO/IEC 19776-1:2005 Information technology -- Computer graphics, image processing and environmental data representation -- Extensible 3D (X3D) encodings -- Part 1: Extensible Markup Language (XML) encoding
ISO/IEC 22537:2006 Information technology -- ECMAScript for XML (E4X) specification
ISO 22643:2003 Space data and information transfer systems -- Data entity dictionary specification language (DEDSL) -- XML/DTD Syntax
ISO/IEC 23001-1:2006 Information technology -- MPEG systems technologies -- Part 1: Binary MPEG format for XML
ISO 24531:2007 Intelligent transport systems -- System architecture, taxonomy and terminology -- Using XML in ITS standards, data registries and data dictionaries



[edit] See also

Comparison of layout engines (XML)
Binary XML
List of XML markup languages
Document Object Model
Category:XML-based standards
S-expressions, an alternative from the 50s from which XML was inspired, which also can represent infinitely complex structure.


[edit] Notes


^ Although it is not a mark-up language, itself, because it defines a syntax for markup languages without laying down a specific "vocabulary".
^ Bray, Tim; Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau (September 2006). "Extensible Markup Language (XML) 1.0 (Fourth Edition)-Origin and Goals". World Wide Web Consortium. http://www.w3.org/TR/2006/REC-xml-20060816/#sec-origin-goals. Retrieved on October 29 2006. 
^ JSON , YAML and S-Expressions are alternative text-based formats that are lighter-weight, less verbose than XML. See Critique of XML in this article.
^ a b c d St.Laurent, Simon (1998). "Why XML?". http://www.simonstl.com/articles/whyxml.htm. Retrieved on January 23 2009. 
^ Foster, Charles (2008). "XML Databases and XML information exchange". http://www.cfoster.net/articles/xmldb-business-case/. 
^ XHTML is attempts to simplify and improve the consistency of HTML, which is based on SGML.
^ The XML specification does not (by itself) indicate rules for formatting and layout. This is in contrast to the HTML specification (for example) which does indicate such rules. Nevertheless, some XML documents may indicate graphical layout, display or formatting based on some other specification. An example is SVG, which is a modularized language for describing two-dimensional vector and mixed vector/raster graphics in XML.
^ "Associating Style Sheets with XML documents, Version 1.0: W3C Recommendation". W3C. 29 June 1999. http://www.w3.org/TR/xml-stylesheet/. Retrieved on 2009-01-06. 
^ "XSL Transformations (XSLT) Version 1.0: W3C Recommendation - Embedding Stylesheets". W3C. 16 November 1999. http://www.w3.org/TR/xslt#section-Embedding-Stylesheets. Retrieved on 2009-01-06. 
^ xml-dev - Fw: An I-D for text/xml, application/xml, etc
^ Push, Pull, Next! by Bob DuCharme, at XML.com
^ Simplify XML processing with VTD-XML - Java World
^ http://www.ximpleware.com/wp_SUN.pdf
^ Cut, paste, split, and assemble XML documents with VTD-XML - Java World
^ VTD+XML format spec
^ Index XML documents with VTD-XML
^ http://java.sun.com/xml/jaxb/
^ http://www.liquid-technologies.com
^ http://www.artima.com/cppsource/xml_data_binding.html
^ http://www.codesynthesis.com/products/xsd/
^ Bray, Tim (February 2005). "A conversation with Tim Bray: Searching for ways to tame the world’s vast stores of information". Association for Computing Machinery's "Queue site". http://www.acmqueue.com/modules.php?name=Content&pa=showpage&pid=282. Retrieved on April 16 2006. 
^ edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). "Publishers, multimedia, and interactivity". Interactive multimedia. Cobb Group. ISBN 1-55615-124-1. 
^ The working group was originally called the "Editorial Review Board." The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210.
^ Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG
^ Extensible Markup Language (XML)
^ "Extensible Markup Language (XML) 1.1 (Second Edition) - Rationale and list of changes for XML 1.1". W3C. http://www.w3.org/TR/xml11/#sec-xml11. Retrieved on 2006-12-21. 
^ Harold, Elliotte Rusty (2004). Effective XML. Addison-Wesley. pp. 10–19. ISBN 0321150406. http://www.cafeconleche.org/books/effectivexml/. 
^ Small company makes big claims on XML patents - CNET News.com
^ XML co-inventor Bray responds to patent assault | Between the Lines | ZDNet.com
^ (See e.g., XML-QL Proposal discussing XML benefits, When to use XML, "XML Sucks" on c2.com, Daring to Do Less with XML)
^ a b How Can XML be Used?
^ Harold, Elliotte Rusty (2002). Processing XML with Java(tm): a guide to SAX, DOM, JDOM, JAXP, and TrAX. Addison-Wesley. ISBN 0201771861. XML documents are too verbose compared with binary equivalents.
^ Harold, Elliotte Rusty (2002). XML in a Nutshell: A Desktop Quick Reference. O'Reilly. ISBN 0596002920.  XML documents are very verbose and searching is inefficient for high-performance largescale database applications.
^ However, the Binary XML effort strives to alleviate these problems by using a binary representation for the XML document. For example, the Java reference implementation of the Fast Infoset standard parsing speed is better by a factor 10 compared to Java Xerces, and by a factor 4 compared to the Piccolo driver, one of the fastest Java-based XML parser [1].
^ Bierman, Gavin (2005). Database Programming Languages: 10th international symposium, DBPL 2005 Trondheim, Norway. Springer. ISBN 3540309519. XML syntax is too verbose for human readers in for certain applications. Proposes a dual syntax for human readability.
^ Although many purportedly "less verbose" text formats actually cite XML as both inspiration and prior art. See e.g., http://yaml.org/spec/current.html, http://innig.net/software/sweetxml/index.html, http://www.json.org/xml.html.
^ A hierarchical model only gives a fixed, monolithic view of the tree structure. For example, either actors under movies, or movies under actors, but not both.
^ Lim, Ee-Peng (2002). Digital Libraries: People, Knowledge, and Technology. Springer. ISBN 3540002618. Discusses some of the limitation with fixed hierarchy. Proceedings of the 5th International Conference on Asian Digital Libraries, ICADL 2002, held in Singapore in December 2002.
^ Searle, Leroy F. (2004). Voice, text, hypertext: emerging practices in textual studies. University of Washington Press. ISBN 0295983051.  Proposes an alternative system for encoding overlapping elements.
^ (See e.g., http://www-128.ibm.com/developerworks/library/x-abolns.html )
^ "The Myth of Self-Describing XML" (PDF). http://www.oceaninformatics.biz/publications/e2.pdf. Retrieved on 2007-05-12. 
^ (See e.g., Use–mention distinction, Naming collision, Polysemy)
^ "Does XML Suck?". http://xmlsucks.org/but_you_have_to_use_it_anyway/does-xml-suck.html. Retrieved on 2007-12-15. (See "8. Complexity: Attributes and Content")
^ "Investors Click Through to Salary Information With New Tool". The CRO Magazine. 2008-02-25. http://www.thecro.com/node/623. Retrieved on 2009-01-21. 
^ "XBRL Planet - Country Overview". XBRL International www.xbrl.org. 2009-03-25. http://www.xbrlplanet.org/planet/snapshot.php?iso3166=jp&feedID=28&gmapID=7. Retrieved on 2009-03-25. 



[edit] External links





This article's external links may not follow Wikipedia's content policies or guidelines. Please improve this article by removing excessive or inappropriate external links.





Wikibooks has more on the topic of
XML




W3C XML homepage
Introduction to Generalized Markup by Charles Goldfarb
Making Mistakes with XML by Sean Kelly
Annex A of ISO 8879:1986 (SGML)
The Multilingual WWW by Gavin Nicol
Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe
XML Based languages
Essential XML Quick Reference
XML, Java and the Future of the Web by Jon Bosak
XML tutorials in w3schools
XML.gov
Thinking XML: The XML decade by Uche Ogbuji
XML: Ten year anniversary by Elliot Kimber
Closing Keynote, XML 2006 by Jon Bosak
Five years later, XML... by Simon St. Laurent
23 XML fallacies to watch out for by Sean McGrath
W3C XML is Ten!, XML 10 years press release
Lawrence A. Cunningham (2005). "Language, Deals and Standards: The Future of XML Contracts". Washington University Law Review. SSRN 900616. 








v • d • e

Standards of the World Wide Web Consortium





Recommendations

Canonical XML · CDF · CSS · DOM · HTML · MathML · OWL · P3P · PLS · RDF · RDF Schema · SISR · SMIL · SOAP · SRGS · SSML · SVG · SPARQL · Timed Text · VoiceXML · WSDL · XForms · XHTML · XLink · XML · XML Base · XML Encryption · XML Events · XML Information Set · XML Schema · XML Signature · XPath · XPointer · XQuery · XSL · XSL-FO · XSLT






Notes

XAdES · XHTML+SMIL






Working Drafts

CCXML · CURIE · HTML 5 · InkML · WICD · XFDL · XFrames · XBL · XHTML+MathML+SVG · XProc  · OWL 2






Guidelines

Web Content Accessibility Guidelines






deprecated

HDML · JSSS · PGML · VML









Retrieved from "http://en.wikipedia.org/wiki/XML"
Categories: XML | Markup languages | World Wide Web Consortium standards | Technical communication | Bibliography file formats | Computer file formats | Open formats | Data modeling languages | Data serialization formats | Application layer protocols | Presentation layer protocolsHidden categories: All articles with unsourced statements | Articles with unsourced statements since March 2009 | All pages needing cleanup | Wikipedia articles needing clarification from March 2008 | Cleanup from section | Cleanup from January 2009 | Articles with sections that need to be turned into prose | Articles with unsourced statements since November 2008 | Wikipedia external links cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Afrikaans
العربية
বাংলা
Bosanski
Български
Català
Česky
Dansk
Deutsch
Eesti
Español
Esperanto
Euskara
فارسی
Français
Gaeilge
Galego
한국어
हिन्दी
Hrvatski
Bahasa Indonesia
Interlingua
Íslenska
Italiano
עברית
ລາວ
Latviešu
Lietuvių
Magyar
മലയാളം
Bahasa Melayu
Nederlands
日本語
‪Norsk (bokmål)‬
‪Norsk (nynorsk)‬
Polski
Português
Română
Русский
Shqip
Simple English
Slovenčina
Slovenščina
Српски / Srpski
Suomi
Svenska
ไทย
Tiếng Việt
Тоҷикӣ
Türkçe
Türkmençe
Українська
Žemaitėška
中文









 This page was last modified on 2 April 2009, at 22:09.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
