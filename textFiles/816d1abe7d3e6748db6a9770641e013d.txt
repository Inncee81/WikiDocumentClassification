













Closure (computer science) - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Closure_(computer_science)";
		var wgTitle = "Closure (computer science)";
		var wgAction = "view";
		var wgArticleId = "62319";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 275330811;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-scheme {line-height: normal;}
.source-scheme li, .source-scheme pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for scheme
 * CSS class: source-scheme, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-scheme .de1, .source-scheme .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-scheme  {}
.source-scheme .head {}
.source-scheme .foot {}
.source-scheme .imp {font-weight: bold; color: red;}
.source-scheme .ln-xtra {color: #cc0; background-color: #ffc;}
.source-scheme li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-scheme li.li2 {font-weight: bold;}
.source-scheme .kw1 {color: #b1b100;}
.source-scheme .co1 {color: #808080; font-style: italic;}
.source-scheme .coMULTI {color: #808080; font-style: italic;}
.source-scheme .es0 {color: #000099; font-weight: bold;}
.source-scheme .br0 {color: #66cc66;}
.source-scheme .st0 {color: #ff0000;}
.source-scheme .nu0 {color: #cc66cc;}
.source-scheme .me0 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-javascript {line-height: normal;}
.source-javascript li, .source-javascript pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for javascript
 * CSS class: source-javascript, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-javascript .de1, .source-javascript .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-javascript  {}
.source-javascript .head {}
.source-javascript .foot {}
.source-javascript .imp {font-weight: bold; color: red;}
.source-javascript .ln-xtra {color: #cc0; background-color: #ffc;}
.source-javascript li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-javascript li.li2 {font-weight: bold;}
.source-javascript .kw1 {color: #000066; font-weight: bold;}
.source-javascript .kw2 {color: #003366; font-weight: bold;}
.source-javascript .kw3 {color: #000066;}
.source-javascript .co1 {color: #009900; font-style: italic;}
.source-javascript .coMULTI {color: #009900; font-style: italic;}
.source-javascript .es0 {color: #000099; font-weight: bold;}
.source-javascript .br0 {color: #66cc66;}
.source-javascript .st0 {color: #3366CC;}
.source-javascript .nu0 {color: #CC0000;}
.source-javascript .me1 {color: #006600;}
.source-javascript .sc0 {}
.source-javascript .sc1 {}
.source-javascript .sc2 {}
.source-javascript .sc3 {}
.source-javascript .re0 {color: #0066FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ocaml {line-height: normal;}
.source-ocaml li, .source-ocaml pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ocaml
 * CSS class: source-ocaml, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ocaml .de1, .source-ocaml .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ocaml  {}
.source-ocaml .head {}
.source-ocaml .foot {}
.source-ocaml .imp {font-weight: bold; color: red;}
.source-ocaml .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ocaml li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ocaml li.li2 {font-weight: bold;}
.source-ocaml .kw1 {color: #06c; font-weight: bold;}
.source-ocaml .coMULTI {color: #5d478b; font-style: italic;}
.source-ocaml .br0 {color: #a52a2a;}
.source-ocaml .st0 {color: #3cb371;}
.source-ocaml .nu0 {color: #c6c;}
.source-ocaml .me1 {color: #060;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-smalltalk {line-height: normal;}
.source-smalltalk li, .source-smalltalk pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for smalltalk
 * CSS class: source-smalltalk, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-smalltalk .de1, .source-smalltalk .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-smalltalk  {}
.source-smalltalk .head {}
.source-smalltalk .foot {}
.source-smalltalk .imp {font-weight: bold; color: red;}
.source-smalltalk .ln-xtra {color: #cc0; background-color: #ffc;}
.source-smalltalk li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-smalltalk li.li2 {font-weight: bold;}
.source-smalltalk .kw1 {color: #7f007f;}
.source-smalltalk .coMULTI {color: #007f00; font-style: italic;}
.source-smalltalk .es0 {}
.source-smalltalk .br0 {color: #000066; font-weight:bold;}
.source-smalltalk .st0 {color: #7f0000;}
.source-smalltalk .nu0 {color: #7f0000;}
.source-smalltalk .me0 {}
.source-smalltalk .sc0 {}
.source-smalltalk .re0 {color: #0000ff;}
.source-smalltalk .re1 {color: #7f0000;}
.source-smalltalk .re2 {color: #7f0000;}
.source-smalltalk .re3 {color: #00007f;}
.source-smalltalk .re4 {color: #7f007f;}
.source-smalltalk .re5 {color: #00007f;}
.source-smalltalk .re6 {color: #00007f;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ruby {line-height: normal;}
.source-ruby li, .source-ruby pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ruby
 * CSS class: source-ruby, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ruby .de1, .source-ruby .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ruby  {}
.source-ruby .head {}
.source-ruby .foot {}
.source-ruby .imp {font-weight: bold; color: red;}
.source-ruby .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ruby li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ruby li.li2 {font-weight: bold;}
.source-ruby .kw1 {color:#9966CC; font-weight:bold;}
.source-ruby .kw2 {color:#0000FF; font-weight:bold;}
.source-ruby .kw3 {color:#CC0066; font-weight:bold;}
.source-ruby .kw4 {color:#CC00FF; font-weight:bold;}
.source-ruby .co1 {color:#008000; font-style:italic;}
.source-ruby .coMULTI {color:#000080; font-style:italic;}
.source-ruby .es0 {color:#000099;}
.source-ruby .br0 {color:#006600; font-weight:bold;}
.source-ruby .st0 {color:#996600;}
.source-ruby .nu0 {color:#006666;}
.source-ruby .me1 {color:#9900CC;}
.source-ruby .sc0 {}
.source-ruby .sc1 {}
.source-ruby .sc2 {}
.source-ruby .re0 {color:#ff6633; font-weight:bold;}
.source-ruby .re1 {color:#0066ff; font-weight:bold;}
.source-ruby .re2 {color:#6666ff; font-weight:bold;}
.source-ruby .re3 {color:#ff3333; font-weight:bold;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Closure (computer science)

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
In computer science, a closure is a function that is evaluated in an environment containing one or more bound variables. When called, the function can access these variables. The explicit use of closures is associated with functional programming and with languages such as ML, Lisp and Perl. Constructs such as objects in other languages can also be modeled with closures.
In some languages, a closure may occur when a function is defined within another function, and the inner function refers to local variables of the outer function. At runtime, when the outer function executes, a closure is formed, consisting of the inner function’s code and references to any variables of the outer function required by the closure.
A closure can be used to associate a function with a set of "private" variables, which persist over several invocations of the function. The scope of the variable encompasses only the closed-over function, so it cannot be accessed from other program code. However, the variable is of indefinite extent, so a value established in one invocation remains available in the next. As a consequence, closures can be used to hide state, and thus to implement object-oriented programming.
The term closure is often mistakenly used to mean anonymous function. This is probably because most languages implementing anonymous functions allow them to form closures and programmers are usually introduced to both concepts at the same time. These are, however, distinct concepts.
The concept of closures was developed in the 1960s and was first fully implemented as a language feature in the programming language Scheme. Since then, many languages have been designed to support closures.
Function objects are sometimes also called closures.




Contents


1 Closures and first-class functions
2 Uses of closures
3 Differences in semantics
4 Implementation and theory
5 See also
6 References
7 External links

7.1 Closure in Delphi







//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Closures and first-class functions
Closures typically appear in languages in which functions are first-class values—in other words, such languages allow functions to be passed as arguments, returned from function calls, bound to variable names, etc., just like simpler types such as strings and integers. For example, consider the following Scheme function:


; Return a list of all books with at least THRESHOLD copies sold.
(define (best-selling-books threshold)
  (filter 
    (lambda (book) (>= (book-sales book) threshold))
    book-list))

In this example, the lambda expression (lambda (book) (>= (book-sales book) threshold)) appears within the function best-selling-books. When the lambda expression is evaluated, Scheme creates a closure consisting of the code for the lambda and a reference to the threshold variable, which is a free variable inside the lambda.
The closure is then passed to the filter function, which calls it repeatedly to determine which books are to be added to the result list and which are to be discarded. Because the closure itself has a reference to threshold, it can use that variable each time filter calls it. The function filter itself might be defined in a completely separate file.
Here is the same example rewritten in ECMAScript (JavaScript), another popular language with support for closures:


// Return a list of all books with at least 'threshold' copies sold.
function bestSellingBooks(threshold) {
  return bookList.filter(
      function(book) { return book.sales >= threshold; }
    );
}

The function keyword is used here instead of lambda, and an Array.filter method[1] instead of a global filter function, but otherwise the structure and the effect of the code are the same.
A function may create a closure and return it. The following example is a function that returns a function.
In Scheme:


; Return a function that approximates the derivative of f
; using an interval of dx, which should be appropriately small.
(define (derivative f dx)
  (lambda (x) (/ (- (f (+ x dx)) (f x)) dx)))

In ECMAScript:


// Return a function that approximates the derivative of f
// using an interval of dx, which should be appropriately small.
function derivative(f, dx) {
  return function(x) {
    return (f(x + dx) - f(x)) / dx;
  };
}

Because the closure in this case outlives the scope of the function that creates it, the variables f and dx live on after the function derivative returns. In languages without closures, the lifetime of a local variable coincides with the execution of the scope where that variable is declared. In languages with closures, variables must continue to exist as long as any existing closures have references to them. This is most commonly implemented using some form of garbage collection.
While this is not always clarified, a closure need not be formed using an anonymous function. The Python programming language, for example, has very limited support for anonymous functions but fully supports closures. For example, one way the above ECMAScript example could be implemented in Python is:


# Return a function that approximates the derivative of f
# using an interval of dx, which should be appropriately small.
def derivative(f, dx):
    def gradient(x):
        return (f(x + dx) - f(x)) / dx
    return gradient

In this example, the function named gradient forms a closure together with the variables f and dx. This closure is then returned by the outer function named derivative.
Although lambda expressions in Python are limited to being a single expression, they are still powerful enough to duplicate the above functionality:


>>> from math import sin, cos
>>> derivative = lambda f, dx: lambda x: (f(x + dx) - f(x)) / dx
>>> dx = derivative(sin, 1e-8)
>>> dx(.5)
0.8775825621754052
>>> cos(.5)
0.87758256189037276
>>>


[edit] Uses of closures
Closures have many uses:

Designers of software libraries can allow users to customize behavior by passing closures as arguments to important functions. For example, a function that sorts values can accept a closure argument that compares the values to be sorted according to a user-defined criterion.
Because closures delay evaluation—i.e., they do not "do" anything until they are called—they can be used to define control structures. For example, all Smalltalk's standard control structures, including branches (if/then/else) and loops (while and for), are defined using objects whose methods accept closures. Users can easily define their own control structures as well.
Multiple functions can be produced which close over the same environment, enabling them to communicate privately by altering that environment (in languages that allow assignment). In Scheme:



(define foo #f)
(define bar #f)
 
(let ((secret-message "none"))
  (set! foo (lambda (msg) (set! secret-message msg)))
  (set! bar (lambda () secret-message)))
 
(display (bar)) ; prints "none"
(newline)
(foo "meet me by the docks at midnight")
(display (bar)) ; prints "meet me by the docks at midnight"


Closures can be used to implement object systems.[2]

Note: Some speakers call any data structure that binds a lexical environment a closure, but the term usually refers specifically to functions.

[edit] Differences in semantics
As different languages do not always have a common definition of the lexical environment, their definitions of closure may vary as well. The commonly held minimalist definition of the lexical environment defines it as a set of all bindings of variables in the scope, and that is also what closures in any language have to capture. It should be noted though that the meaning of a variable binding also differs. In imperative languages, variables bind to relative locations in memory that can store values. Although the relative location of a binding does not change at runtime, the value in the bound location can. In such languages, since closure captures the binding, any operation on the variable, whether done from the closure or not, is performed on the same relative memory location. Here is an example illustrating the concept in ECMAScript, which is one such language:


var f, g;
function foo()
{
  var x = 0;
  f = function() { return ++x; };
  g = function() { return --x; };
  x = 1;
  print(f()); // "2"
}
foo();
print(g()); // "1"
print(f()); // "2"

Note how function foo and the closures referred to by variables f and g all use the same relative memory location signified by local variable x.
On the other hand, many functional languages, such as ML, bind variables directly to values. In this case, since there is no way to change the value of the variable once it is bound, there is no need to share the state between closures - they just use the same values.
Yet another subset, lazy functional languages such as Haskell, bind variables to a result of a computation in the future. Consider this example in Haskell:


 
foo x y = let r = x / y
          in (\z -> z + r)
f = foo 1 0
main = do putStr (show (f 123))

The binding of r captured by the closure defined within function foo is to the computation (x / y) - which in this case results in division by zero. However, since it is the computation that is captured, and not the value, the error only manifests itself when the closure is invoked, and actually attempts to use the captured binding.
Yet more differences manifest themselves in the behavior of other lexically scoped constructs, such as return, break and continue statements. Such constructs can in general be considered in terms of invoking an escape continuation established by an enclosing control statement (in case of break and continue, such interpretation requires looping constructs to be considered in terms of recursive function calls). In some languages, such as ECMAScript, return refers to the continuation established by the closure lexically innermost with respect to the statement - thus, a return within a closure transfers control to the code that called it. In Smalltalk, however, the superficially similar ^ operator invokes the escape continuation established for the method invocation, ignoring the escape continuations of any intervening nested closures. The escape continuation of a particular closure can only be invoked in Smalltalk implicitly by reaching the end of the closure's code. The following examples in ECMAScript and Smalltalk highlight the difference:


"Smalltalk"
foo
  | xs |
  xs := #(1 2 3 4).
  xs do: [:x | ^x].
  ^0
bar
  Transcript show: (self foo printString) "prints 1"



// ECMAScript
function foo() {
  var xs = new Array(1, 2, 3, 4);
  xs.forEach(function(x) { return x; });
  return 0;
}
print(foo()); // prints 0

The above code snippets will behave differently because the Smalltalk ^ operator and the JavaScript return operator are not analogous. In the ECMAScript example, return x will leave the inner closure to begin a new iteration of the forEach loop, whereas in the Smalltalk example, ^x will abort the loop and return from the method foo.
Common Lisp provides a construct that can express either of the above actions: Smalltalk ^x behaves as (return-from foo x), while JavaScript return x behaves as (return-from nil x). Hence, Smalltalk makes it possible for a captured escape continuation to outlive the extent in which it can be successfully invoked. Consider:


foo
    ^[ :x | ^x ]
bar
    | f |
    f := self foo.
    f value: 123 "error!"

When the closure returned by the method foo is invoked, it attempts to return a value from the invocation of foo that created the closure. Since that call has already returned and the Smalltalk method invocation model does not follow the spaghetti stack discipline to allow multiple returns, this operation results in an error.
Some languages, such as Ruby, allow the programmer to choose the way return is captured. An example in Ruby:


# ruby
def foo
  f = Proc.new { return "return from foo from inside proc" }
  f.call # control leaves foo here
  return "return from foo"
end
 
def bar
  f = lambda { return "return from lambda" }
  f.call # control does not leave bar here
  return "return from bar"
end
 
puts foo # prints "return from foo from inside proc"
puts bar # prints "return from bar"

Both Proc.new and lambda in this example are ways to create a closure, but semantics of the closures thus created are different with respect to the return statement.
In Scheme, definition and scope of the return control statement is explicit (and only arbitrarily named 'return' for the sake of the example). The following is a direct translation of the Ruby sample.


(define call/cc call-with-current-continuation)
 
(define (foo)
  (call/cc 
   (lambda (return)
     (define (f) (return "return from foo from inside proc"))
     (f) ; control leaves foo here
     (return "return from foo"))))
 
(define (bar)
  (call/cc
   (lambda (return)
     (define (f) (call/cc (lambda (return) (return "return from lambda"))))
     (f) ; control does not leave bar here
     (return "return from bar"))))
 
(display (foo)) ; prints "return from foo from inside proc"
(newline)
(display (bar)) ; prints "return from bar"


[edit] Implementation and theory
Closures are typically implemented with a special data structure that contains a pointer to the function code, plus a representation of the function's lexical environment (e.g., the set of available variables and their values) at the time when the closure was created.
A language implementation cannot easily support full closures if its run-time memory model allocates all local variables on a linear stack. In such languages, a function's local variables are deallocated when the function returns. However, a closure requires that the free variables it references survive the enclosing function's execution. Therefore those variables must be allocated so that they persist until no longer needed. This explains why typically languages that natively support closures also use garbage collection. The alternative is for the language to accept that certain use cases will lead to undefined behaviour, as in the proposal for lambda expressions in C++.[3]
In ML, local variables are allocated on a linear stack. When a closure is created, it copies the values of those variables that are needed by the closure into the closure's data structure.
A typical modern Scheme implementation allocates local variables that might be used by closures dynamically and stores all other local variables on the stack.
Closures are closely related to Actors in the Actor model of concurrent computation where the values in the function's lexical environment are called acquaintances. An important issue for closures in concurrent programming languages is whether the variables in a closure can be updated and if so how these updates can be synchronized. Actors provide one solution.[4]

[edit] See also

Lambda calculus
Funarg problem
Continuation
Spaghetti stack
Value-level programming
Command pattern
Eiffel programming language
Anonymous function
Dependency injection
Currying (a function)


[edit] References


^ "filter". Mozilla Developer Center. 29 November 2007. http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:filter. Retrieved on 2008-12-23. 
^ "Re: FP, OO and relations. Does anyone trump the others?". 29 December 1999. http://okmij.org/ftp/Scheme/oop-in-fp.txt. Retrieved on 2008-12-23. 
^ Lambda Expressions and Closures C++ Standards Committee. 29 February 2008.
^ Foundations of Actor Semantics Will Clinger. MIT Mathematics Doctoral Dissertation. June 1981.



[edit] External links

The Original "Lambda Papers": A classic series of papers by Guy Steele and Gerald Sussman discussing, among other things, the versatility of closures in the context of Scheme (where they appear as lambda expressions).
Closures: An article about closures in dynamically-typed imperative languages, by Martin Fowler.
Collection closure methods: example of a technical domain where using closures is convenient, by Martin Fowler.
The beauty of closures: an article about using closures in Java and .NET
What are closures: an post on closures in Javascript


[edit] Closure in Delphi

Nick Hodges, "Delphi 2009 Reviewers Guide," October 2008, CodeGear Developer Network, CodeGear.
Craig Stuntz, "Understanding Anonymous Methods," October 2008
Dr. Bob, "Delphi 2009 Anonymous Methods"




Retrieved from "http://en.wikipedia.org/wiki/Closure_(computer_science)"
Categories: Theoretical computer science 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Български
Deutsch
Español
Français
Italiano
Nederlands
日本語
Polski
Português
Русский
Simple English
ไทย
Українська









 This page was last modified on 6 March 2009, at 04:42.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
