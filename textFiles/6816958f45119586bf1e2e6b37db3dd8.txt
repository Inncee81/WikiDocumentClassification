













Function object - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Function_object";
		var wgTitle = "Function object";
		var wgAction = "view";
		var wgArticleId = "509999";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 276372017;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-d {line-height: normal;}
.source-d li, .source-d pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for d
 * CSS class: source-d, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-d .de1, .source-d .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-d  {}
.source-d .head {}
.source-d .foot {}
.source-d .imp {font-weight: bold; color: red;}
.source-d .ln-xtra {color: #cc0; background-color: #ffc;}
.source-d li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-d li.li2 {font-weight: bold;}
.source-d .kw1 {color: #b1b100;}
.source-d .kw2 {color: #000000; font-weight: bold;}
.source-d .kw3 {color: #aaaadd; font-weight: bold;}
.source-d .kw4 {color: #993333;}
.source-d .co1 {color: #808080; font-style: italic;}
.source-d .co2 {color: #a1a100;}
.source-d .coMULTI {color: #808080; font-style: italic;}
.source-d .es0 {color: #000099; font-weight: bold;}
.source-d .br0 {color: #66cc66;}
.source-d .st0 {color: #ff0000;}
.source-d .nu0 {color: #cc66cc;}
.source-d .me1 {color: #006600;}
.source-d .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-lisp {line-height: normal;}
.source-lisp li, .source-lisp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for lisp
 * CSS class: source-lisp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-lisp .de1, .source-lisp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-lisp  {}
.source-lisp .head {}
.source-lisp .foot {}
.source-lisp .imp {font-weight: bold; color: red;}
.source-lisp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-lisp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-lisp li.li2 {font-weight: bold;}
.source-lisp .kw1 {color: #b1b100;}
.source-lisp .co1 {color: #808080; font-style: italic;}
.source-lisp .coMULTI {color: #808080; font-style: italic;}
.source-lisp .es0 {color: #000099; font-weight: bold;}
.source-lisp .br0 {color: #66cc66;}
.source-lisp .st0 {color: #ff0000;}
.source-lisp .nu0 {color: #cc66cc;}
.source-lisp .me0 {color: #555;}
.source-lisp .me1 {color: #555;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ruby {line-height: normal;}
.source-ruby li, .source-ruby pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ruby
 * CSS class: source-ruby, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ruby .de1, .source-ruby .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ruby  {}
.source-ruby .head {}
.source-ruby .foot {}
.source-ruby .imp {font-weight: bold; color: red;}
.source-ruby .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ruby li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ruby li.li2 {font-weight: bold;}
.source-ruby .kw1 {color:#9966CC; font-weight:bold;}
.source-ruby .kw2 {color:#0000FF; font-weight:bold;}
.source-ruby .kw3 {color:#CC0066; font-weight:bold;}
.source-ruby .kw4 {color:#CC00FF; font-weight:bold;}
.source-ruby .co1 {color:#008000; font-style:italic;}
.source-ruby .coMULTI {color:#000080; font-style:italic;}
.source-ruby .es0 {color:#000099;}
.source-ruby .br0 {color:#006600; font-weight:bold;}
.source-ruby .st0 {color:#996600;}
.source-ruby .nu0 {color:#006666;}
.source-ruby .me1 {color:#9900CC;}
.source-ruby .sc0 {}
.source-ruby .sc1 {}
.source-ruby .sc2 {}
.source-ruby .re0 {color:#ff6633; font-weight:bold;}
.source-ruby .re1 {color:#0066ff; font-weight:bold;}
.source-ruby .re2 {color:#6666ff; font-weight:bold;}
.source-ruby .re3 {color:#ff3333; font-weight:bold;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-eiffel {line-height: normal;}
.source-eiffel li, .source-eiffel pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for eiffel
 * CSS class: source-eiffel, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-eiffel .de1, .source-eiffel .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-eiffel  {}
.source-eiffel .head {}
.source-eiffel .foot {}
.source-eiffel .imp {font-weight: bold; color: red;}
.source-eiffel .ln-xtra {color: #cc0; background-color: #ffc;}
.source-eiffel li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-eiffel li.li2 {font-weight: bold;}
.source-eiffel .kw1 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw2 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw3 {color: #800080;}
.source-eiffel .kw4 {color: #800000}
.source-eiffel .kw5 {color: #603000;}
.source-eiffel .co1 {color: #008000; font-style: italic;}
.source-eiffel .coMULTI {}
.source-eiffel .es0 {color: #005070; font-weight: bold;}
.source-eiffel .br0 {color: #600000;}
.source-eiffel .st0 {color: #0080A0;}
.source-eiffel .nu0 {color: #FF0000;}
.source-eiffel .me1 {color: #000060;}
.source-eiffel .me2 {color: #000050;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Function object

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
For functors in the mathematical field of category theory, see Category theory.
A function object, also called a functor, functional or functionoid,[1] is a computer programming construct allowing an object to be invoked or called as if it were an ordinary function, usually with the same syntax.




Contents


1 Description
2 Origins
3 Functors in C and C++

3.1 Performance
3.2 Maintaining State


4 Functors in D
5 Functors in Java
6 Functors in Python
7 Functors in Lisp
8 Functors in Ruby
9 Functors in Eiffel
10 Other meanings of functor
11 See also
12 References
13 Further reading
14 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Description
A typical use of a functor is in writing callback functions. A callback in procedural languages, such as C, may be accomplished by using function pointers. However it can be difficult or awkward to pass state into or out of the callback function. This restriction also inhibits more dynamic behavior of the function. A functor solves those problems since the function is really a façade for a full object, thus it carries its own state.
Most modern object-oriented languages such as C++, Java, Python, Ruby and Lisp support the definition of functors and may even make significant use of them.

[edit] Origins
Smalltalk was one of the first languages to support functors through the use of block constructs that are an integral part of the language syntax. For example, one can supply functors as arguments to collection objects to provide filtering and sorting. It is a perfect realization of the strategy pattern that promotes the use of pluggable behaviour.

[edit] Functors in C and C++
Consider the example of a sorting routine which uses a callback function to define an ordering relation between a pair of items. A C program using function pointers may appear as:


/* Callback function */
int compare_function(int A, int B) {
  return (A < B);
}
...
/* Declaration of C sorting function */
void sort_ints(int* begin_items, int num_items, int (*cmpfunc)(int, int) );
...
int main() {
    int items[] = {4, 3, 1, 2};
    sort_ints(items, sizeof(items)/sizeof(int), compare_function);
}

In C++ a functor may be used instead of an ordinary function by defining a class which overloads the function call operator by defining an operator() member function. In C++ this is called a class type functor, and may appear as follows:


class compare_class {
  public:
  bool operator()(int A, int B) {
    return (A < B);
  }
};
...
// Declaration of C++ sorting function.
template <class ComparisonFunctor> 
void sort_ints(int* begin_items, int num_items, ComparisonFunctor c);
...
int main() {
    int items[] = {4, 3, 1, 2};
    compare_class functor;
    sort_ints(items, sizeof(items)/sizeof(int), functor);
}

Notice that the syntax for providing the callback to the sort_ints() function is identical, but an object is passed instead of a function pointer. When invoked, the callback function is executed just as any other member function, and therefore has full access to the other members (data or functions) of the object.
It is possible to use function objects in situations other than as callback functions (although the shortened term functor is normally not used). Continuing the example,


  functor_class Y;
  int result = Y( a, b );

In addition to class type functors, other kinds of function objects are also possible in C++. They can take advantage of C++'s member-pointer or template facilities. The expressiveness of templates allows some functional programming techniques to be used, such as defining functors in terms of other functors (like function composition). Much of the C++ Standard Template Library (STL) makes heavy use of template-based function objects.

[edit] Performance
An advantage of function objects in C++ is performance because unlike a function pointer, a function object can be inlined. For example, consider a simple function which increments its argument implemented as a function object:


struct IncrementFunctor {
  void operator()(int &i) { ++i; }
};

and as a free function:


void increment_function(int &i) { ++i; }

Recall the standard library function std::for_each():


template<typename InputIterator, typename Function>
Function for_each(InputIterator first, InputIterator last, Function f) {
  for ( ; first != last; ++first)
    f(*first);
  return f;
}

Suppose we apply std::for_each() like so:


int A[] = {1, 4, 2, 8, 5, 7};
const int N = sizeof(A) / sizeof(A[0]);
for_each(A, A + N, IncrementFunctor());
for_each(A, A + N, increment_function);

Both calls to for_each() will work as expected. The first call will be to this version:


IncrementFunctor for_each<int*,IncrementFunctor>(int*, int*, IncrementFunctor)

the second will be to this version:


void(*)(int&) for_each<int*,void(*)(int&)>(int*, int*, void(*)(int&))

Within for_each<int*,IncrementFunctor>(), the compiler will be able to inline the function object because the function is known at compile time whereas within for_each<int*,void(*)(int&)>() the function cannot be known at compile time and so cannot be inlined.
Actually, a function can easily be known at compile time and the compiler will happily inline it, if it is instructed to. The only requirement is that the compiler has seen the function definition, and that applies equally to functions inside a class or outside. In case we are not inlining however, the linker is instructed to "silently" drop multiple definitions of the same function from different compilation units, without producing an error, but only if said function is a class function. The linker will not dismiss multiple definitions of the same function if it is not a class function.

[edit] Maintaining State
Another advantage of functors is that they can maintain state that affects operator() between calls. Inconveniently copies of a functor must share a state to work correctly. STL algorithms are allowed to make copies. For example, the following code defines a generator that counts from 10 up and is invoked 11 times.


#include <iostream>
#include <iterator>
#include <algorithm>
 
class countfrom {
private:
  int &count;
public:
  countfrom(int &n) : count(n) {}
  int operator()() { return count++; }
};
 
int main() {
  int state(10);
  std::generate_n(std::ostream_iterator<int>(std::cout, "\n"), 11, countfrom(state));
  return 0;
}


[edit] Functors in D
D provides several ways of declaring functors. Lisp/Python-style using closures or C#-style using delegates, respectively:


bool find(T)(T[] haystack, bool delegate(T) needle_test) {
  foreach ( straw; haystack ) {
    if ( needle_test(straw) )
      return true;
  }
  return false;
}
 
void main() {
    int[] haystack = [345,15,457,9,56,123,456];
    int   needle = 123;
    bool needleTest(int n) {
      return n == needle;
    }
    assert(
      find(haystack, &needleTest)
    );
}

The difference between a delegate and a closure in D is automatically and conservatively determined by the compiler. D also supports function literals, that allow a lambda-style definition:


void main() {
    int[] haystack = [345,15,457,9,56,123,456];
    int   needle = 123;
    assert(
       find(haystack, (int n) { return n == needle; })
    );
}

In order to allow the compiler to inline the code (see above), functors can also be specified C++-style using operator overloading:


bool find(T,F)(T[] haystack, F needle_test) {
  foreach ( straw; haystack ) {
    if ( needle_test(straw) )
      return true;
  }
  return false;
}
 
void main() {
    int[] haystack = [345,15,457,9,56,123,456];
    int   needle = 123;
    class NeedleTest {
      int needle;
      this(int n) { needle = n; }
      bool opCall(int n) {
        return n == needle;
      }
    }
    assert(
      find(haystack, new NeedleTest(needle))
    );
}


[edit] Functors in Java
Since Java does not have first-class functions, functors are usually expressed by an interface with a single method, typically with the implementation being an anonymous inner class.
For an example from Java's standard library, java.util.Collections.sort() takes a List and a functor whose role is to compare objects in the List. But because Java does not have first-class functions, the function is part of the Comparator interface. This could be used as follows.


List<String> list = Arrays.asList("10", "1", "20", "11", "21", "12");
 
Collections.sort(list, new Comparator<String>() {
    public int compare(String o1, String o2) {
        return Integer.valueOf(o1).compareTo(Integer.valueOf(o2));
    }
});


[edit] Functors in Python
In Python, functions are objects, just like strings, numbers, lists, and so on. This feature eliminates the need to create a functor object in many cases. However, any object with a __call__() method may be called using function-call syntax.
An example is this Accumulator class (based on Paul Graham's study on programming language syntax and clarity here):


class Accumulator(object):
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        self.n += x
        return self.n

An example of this in use (using the interactive interpreter):

>>> a = Accumulator(4)
>>> a(5)
9
>>> a(2)
11
>>> b = Accumulator(42)
>>> b(7)
49


Another way to construct a functor in Python is to use a closure:


def Accumulator(n):
    def inc(x):
        inc.n += x
        return inc.n
    inc.n = n
    return inc


[edit] Functors in Lisp
In Common Lisp, Scheme and other languages in that family, functions are objects, just like strings, vectors, lists, numbers and so forth. A closure-constructing operator creates a function-object from a piece of the program itself: the piece of code given as an argument to the operator is part of the function, and so is the lexical environment: the bindings of the lexically visible variables are "captured" and stored in the functor, which is more commonly called a closure. The captured bindings play the role of "member variables", and the code part of the closure plays the role of the "anonymous member function", just like operator () in C++.
The closure constructor has the syntax (lambda (parameters ...) code ...). The (parameters ...) part allows an interface to be declared, so that the function takes the declared parameters. The code ... part consists of expressions that are evaluated when the functor is called.
Many uses of functors in languages like C++ are simply emulations of the missing closure constructor. Since the programmer cannot directly construct a closure, he or she must define a class which has all of the necessary state variables, and also a member function. Then, construct an instance of that class instead, ensuring that all the member variables are initialized through its constructor. The values are derived precisely from those local variables that ought to be captured directly by a closure.
A function-object using the class system, no use of closures:


(defclass counter ()
  ((value :initarg :value :accessor value-of)))
 
(defmethod functor-call ((c counter))
  (incf (value-of c)))
 
(defun make-counter (initial-value)
  (make-instance 'counter :value initial-value))
 
;;; use the counter:
 
(defvar *c* (make-counter 10))
 
(functor-call *c*) --> 11
(functor-call *c*) --> 12

Since there is no standard way to make funcallable objects in Lisp, we fake it by defining a generic function called FUNCTOR-CALL. This can be specialized for any class whatsoever. The standard FUNCALL function is not generic; it only takes function objects.
It is this FUNCTOR-CALL generic function which gives us functors, which are a computer programming construct allowing an object to be invoked or called as if it were an ordinary function, usually with the same syntax. We have almost the same syntax: FUNCTOR-CALL instead of FUNCALL. Some Lisps provide "funcallable" objects as a simple extension. Making objects callable using the same syntax as functions is a fairly trivial business. Making a function call operator work with different kinds of "function things", whether they be class objects or closures is no more complicated than making a + operator that works with different kinds of numbers, such as integers, reals or complex numbers.
Now, a counter implemented using a closure. This is much more brief and direct. The INITIAL-VALUE argument of the MAKE-COUNTER factory function is captured and used directly. It does not have to be copied into some auxiliary class object through a constructor. It is the counter. An auxiliary object is created, but that happens "behind the scenes".


(defun make-counter (initial-value)
  (lambda () (incf initial-value)))
 
;;; use the counter
 
(defvar *c* (make-counter 10))
 
(funcall *c*) --> 11
(funcall *c*) --> 12

More than one closure can be created in the same lexical environment. A vector of closures, each implementing a specific kind of operation, can quite faithfully emulate an object that has a set of virtual operations. That type of single dispatch object-oriented programming can be done entirely with closures.
So there exists a kind of tunnel being dug from both sides of the proverbial mountain. Programmers in OOP languages discover functors by restricting objects to have one "main" function to "do" that object's functional purpose, and even eliminate its name so that it looks like the object is being called! While programmers who use closures are not surprised that an object is called like a function, they discover that multiple closures sharing the same environment can provide a complete set of abstract operations like a virtual table for single dispatch type OOP.

[edit] Functors in Ruby
Ruby has a number of objects that can be considered functors, in particular Method and Proc objects. Ruby also has two kinds of objects that can be thought of as semi-functors: UnboundMethod and block. UnboundMethods must first be bound to an object (thus becoming a Method) before they can be used as a functor. Blocks can be called like functors, but in order to be used in any other capacity as an object (eg. passed as an argument) they must first be converted to a Proc. More recently, symbols (accessed via the literal unary indicator :) can also be converted to Procs. Using Ruby's unary & operator—equivalent to calling to_proc on an object, and assuming that method exists—the Ruby Extensions Project created a simple hack.


class Symbol
   def to_proc
      proc { |obj, *args| obj.send(self, *args) }
   end
end

Now, method foo can be a functor, i.e. a Proc, via &:foo and used via takes_a_functor(&:foo). Symbol.to_proc was officially added to Ruby on June 11, 2006 during RubyKaiga2006. [1]
Because of the variety of forms, the term Functor is not generally used in Ruby to mean a Function object. Rather it has come to represent a type of dispatch delegation introduced by the Ruby Facets project. The most basic definition of which is:


class Functor
  def initialize(&func)
    @func = func
  end
  def method_missing(op, *args, &blk)
    @func.call(op, *args, &blk)
  end
end

This usage is more akin to that used by functional programming languages, like ML, and the original mathematical terminology.

[edit] Functors in Eiffel
Operations and objects are seen always as separate concepts in the Eiffel software development method and programming language. However, the agent mechanism facilitates the modeling of operations as runtime objects. Agents satisfy the range of application attributed to functors, such as being passed as arguments in procedural calls or specified as callback routines. The design of the agent mechanism in Eiffel attempts to reflect the object-oriented nature of the method and language. An agent is an object which generally is a direct instance of one of the two library classes which model the two types of routines in Eiffel: PROCEDURE and FUNCTION. These two classes descend from the more abstract ROUTINE.
Within software text, the language keyword agent allows agents to be constructed in a compact form. In the following example, the goal is to add the action of stepping the gauge forward to the list of actions to be executed in the event that a button is clicked.


            my_button.select_actions.extend (agent my_gauge.step_forward)

The routine extend referenced in the example above is a feature of a class in a graphical user interface (GUI) library to provide event-driven programming capabilities.
In other library classes, agents are seen to be used for different purposes. In a library supporting data structures, for example, a class modeling linear structures effects universal quantification with a function for_all of type BOOLEAN which accepts an agent, an instance of FUNCTION, as an argument. So, in the following example, my_action is executed only if all members of my_list contain the character '!':


    my_list: LINKED_LIST [STRING]
        ...
            if my_list.for_all (agent {STRING}.has ('!')) then
                my_action
            end
        ...

When agents are created, the arguments to the routines they model and even the target object to which they are applied can be either closed or left open. Closed arguments and targets are given values at agent creation time. The assignment of values for open arguments and targets is deferred until some point after the agent is created. The routine for_all expects as an argument an agent representing a function with one open argument or target which conforms to actual generic parameter for the structure (STRING in this example.)
When the target of an agent is left open, the class name of the expected target, enclosed in braces, is substituted for an object reference as shown in the text agent {STRING}.has ('!') in the example above. When an argument is left open, the question mark character ('?') is coded as a placeholder for the open argument.
The ability to close or leave open targets and arguments is intended to improve the flexibility of the agent mechanism. Consider a class that contains the following procedure to print a string on standard output after a new line:


    print_on_new_line (s: STRING)
            -- Print `s' preceded by a new line
        do
            print ("%N" + s)
        end

The following snippet, assumed to be in the same class, uses print_on_new_line to demonstrate the mixing of open arguments and open targets in agents used as arguments to the same routine.


    my_list: LINKED_LIST [STRING]
        ...
            my_list.do_all (agent print_on_new_line (?))
            my_list.do_all (agent {STRING}.to_lower)
            my_list.do_all (agent print_on_new_line (?))
        ...

This example uses the procedure do_all for linear structures, which executes the routine modeled by an agent for each item in the structure.
The sequence of three instructions prints the strings in my_list, converts the strings to lowercase, and then prints them again.
Procedure do_all iterates across the structure executing the routine substituting the current item for either the open argument (in the case of the agents based on print_on_new_line), or the open target (in the case of the agent based on to_lower).
Open and closed arguments and targets also allow the use of routines which call for more arguments than are required by closing all but the necessary number of arguments:


            my_list.do_all (agent my_multi_arg_procedure (closed_arg_1, ?, closed_arg_2, closed_arg_3)

The Eiffel agent mechanism is detailed in the Eiffel ISO/ECMA standard document.

[edit] Other meanings of functor
In some functional programming languages, such as ML, a functor represents a mapping from modules to modules, and is a technique for reusing code. Functors used in this manner are analogous to the original mathematical meaning of functor in category theory, or to the use of templates in C++.
In a more theoretical context a function object may be considered to be any instance of the class of functions, especially in languages such as Common Lisp in which functions are first-class objects. In this case the shortened term functor is rarely used.
In Prolog and related languages, functor is a synonym for function symbol.

[edit] See also

function closure
Command pattern


[edit] References


^ http://www.parashift.com/c++-faq-lite/pointers-to-members.html#faq-33.10







This article needs additional citations for verification.
Please help improve this article by adding reliable references. Unsourced material may be challenged and removed. (February 2009)



[edit] Further reading

David Vandevoorde & Nicolai M Josuttis (2006). C++ Templates: The Complete Guide, ISBN 0-201-73484-2 : Specifically, chapter 22 is entirely devoted to function objects.


[edit] External links

Description from the Portland Pattern Repository
C++ Advanced Design Issues - Asynchronous C++ by Kevlin Henney
The Function Pointer Tutorials by Lars Haendel (2000/2001)
Article "Generalized Function Pointers" by Herb Sutter
Generic Algorithms for Java




Retrieved from "http://en.wikipedia.org/wiki/Function_object"
Categories: Programming constructs | Articles with example C code | Articles with example C++ code | Articles with example Java code | Articles with example Python code | Articles with example Ruby codeHidden categories: Articles needing additional references from February 2009 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


日本語









 This page was last modified on 10 March 2009, at 21:47 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
