













Scope (programming) - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Scope_(programming)";
		var wgTitle = "Scope (programming)";
		var wgAction = "view";
		var wgArticleId = "62068";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 278247554;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-pascal {line-height: normal;}
.source-pascal li, .source-pascal pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for pascal
 * CSS class: source-pascal, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-pascal .de1, .source-pascal .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-pascal  {}
.source-pascal .head {}
.source-pascal .foot {}
.source-pascal .imp {font-weight: bold; color: red;}
.source-pascal .ln-xtra {color: #cc0; background-color: #ffc;}
.source-pascal li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-pascal li.li2 {font-weight: bold;}
.source-pascal .kw1 {color: #b1b100;}
.source-pascal .kw2 {color: #000000; font-weight: bold;}
.source-pascal .kw3 {}
.source-pascal .kw4 {color: #993333;}
.source-pascal .co1 {color: #808080; font-style: italic;}
.source-pascal .co2 {color: #339933;}
.source-pascal .coMULTI {color: #808080; font-style: italic;}
.source-pascal .es0 {color: #000099; font-weight: bold;}
.source-pascal .br0 {color: #66cc66;}
.source-pascal .st0 {color: #ff0000;}
.source-pascal .nu0 {color: #cc66cc;}
.source-pascal .me1 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-perl {line-height: normal;}
.source-perl li, .source-perl pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for perl
 * CSS class: source-perl, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-perl .de1, .source-perl .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-perl  {}
.source-perl .head {}
.source-perl .foot {}
.source-perl .imp {font-weight: bold; color: red;}
.source-perl .ln-xtra {color: #cc0; background-color: #ffc;}
.source-perl li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-perl li.li2 {font-weight: bold;}
.source-perl .kw1 {color: #b1b100;}
.source-perl .kw2 {color: #000000; font-weight: bold;}
.source-perl .kw3 {color: #000066;}
.source-perl .co1 {color: #808080; font-style: italic;}
.source-perl .coMULTI {color: #808080; font-style: italic;}
.source-perl .es0 {color: #000099; font-weight: bold;}
.source-perl .br0 {color: #66cc66;}
.source-perl .st0 {color: #ff0000;}
.source-perl .nu0 {color: #cc66cc;}
.source-perl .me1 {color: #006600;}
.source-perl .me2 {color: #006600;}
.source-perl .re0 {color: #0000ff;}
.source-perl .re4 {color: #009999;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Scope (programming)

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article needs additional citations for verification. Please help improve this article by adding reliable references (ideally, using inline citations). Unsourced material may be challenged and removed. (December 2008)


In computer programming, scope is an enclosing context where values and expressions are associated. Various programming languages have various types of scopes. The type of scope determines what kind of entities it can contain and how it affects them -- or semantics. Typically, scope is used to define the visibility and reach of information hiding. Scopes can:

contain declarations or definitions of identifiers;
contain statements and/or expressions which define an executable algorithm or part thereof;
nest or be nested.

A namespace is a scope that uses the enclosing nature of the scope to group logically related identifiers under a single identifier. Thus, scopes can affect the name resolution for their contents.
Variables are associated with scopes. Different scoping types affect how local variables are bound. This has different consequences depending if the language has static (lexical) or dynamic scoping.




Contents


1 History
2 Example
3 Static versus dynamic scoping

3.1 Static scoping (also known as lexical scoping)
3.2 Dynamic scoping
3.3 Example


4 References
5 See also
6 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] History
Static scoping (also known as lexical scoping) was first introduced in Lisp 1.5 (via the FUNARG device developed by Steve Russell, working under John McCarthy) and added later into Algol 60 (also by Steve Russell), and has been picked up in other languages since then. Descendants of dynamically scoped languages often adopt static scoping. Emacs Lisp, for example, uses dynamic scoping, Common Lisp has both dynamic and static scoping, and Scheme uses static scoping exclusively. The original Lisp used dynamic scoping. In other cases, languages which already had dynamic scoping have added static scoping afterwards, such as Perl. C and Pascal have always had static scoping, since they are both influenced by the ideas that went into Algol.

[edit] Example
The following example shows various scopes declared in the language C#:


namespace N
{                        // namespace scope, merely groups identifiers
   class C
   {                     // class scope, defines/declares member variables and functions
      void f (bool b)
      {                  // outermost block (function) scope, contains executable statements
         if (b)
         {               // inner block scope for conditionally executed statements
                          // (Note, both block scopes are unnamed.)
           ...
         }
      }
   }
}


[edit] Static versus dynamic scoping
One of the basic reasons for scoping is to keep variables in different parts of the program distinct from one another. Since there are only a small number of short variable names, and programmers share habits about the naming of variables (e.g., i for an array index), in any program of moderate size the same variable name will be used in multiple different scopes. The question of how to match various variable occurrences to the appropriate binding sites is generally answered in one of two ways: static scoping and dynamic scoping.

[edit] Static scoping (also known as lexical scoping)
With static scope, a variable always refers to its top-level environment. This is a property of the program text and unrelated to the runtime call stack. Because matching a variable to its binding only requires analysis of the program text, this type of scoping is sometimes also called lexical scoping. Static scope is standard in modern functional languages such as ML and Haskell because it allows the programmer to reason as if variable bindings are carried out by substitution. Static scoping also makes it much easier to make modular code and reason about it, since its binding structure can be understood in isolation. In contrast, dynamic scope forces the programmer to anticipate all possible dynamic contexts in which the module's code may be invoked.
For example, consider the following program fragment (in Pascal):


Program A;
Var I:Integer;
    K:Char;
    R:Real;
 
    Procedure B;
    Var K:Real;
        L:Integer;
 
        Procedure C;
        Var M:Real;
 
        Begin
        // (1)
        End;
 
    Begin
    // (2)
    End;
 
Begin
// (3)
end.

In the above code, the variable I is accessible as an Integer at points (1), (2) and (3) in the program because its scope is global, and is not overridden by another variable of the same name. The variable K is accessible as a Real at points (1) and (2) and as a character at (3). Also, because of the scope of K, the variable called K in C (at point (1)) and B (at point (2)) is not the same variable K in the main program at point (3). Variable L is accessible only in procedure C at point (1) and procedure B at point (2), and is not accessible from the main program. Variable M is only accessible in procedure C at point (1), and is not accessible either from Procedure B or the main program. Also, procedure C can only be called from Procedure B; it cannot be called from the main program. Also, there could be yet another procedure C declared later in the program, and a reference to that procedure would be dependent upon where in the program code as to which procedure is being called, same as to which variable is being referenced in the above example.
Correct implementation of static scope in languages with first-class nested functions can be subtle, as it requires each function value to carry with it a record of the values of the variables that it depends on (the pair of the function and this environment is called a closure). When first-class nested functions are not used or not available (such as in C), this overhead is of course not incurred. Variable lookup is always very efficient with static scope, as the location of each value is known at compile time.

[edit] Dynamic scoping
With dynamic scope, each identifier has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack (which may have been empty), which is popped off when the control flow leaves the scope. Evaluating x in any context always yields the top binding. In other words, a global identifier refers to the identifier associated with the most recent environment. Note that this cannot be done at compile time because the binding stack only exists at runtime, which is why this type of scoping is called dynamic scoping.
Generally, certain blocks are defined to create bindings whose lifetime is the execution time of the block; this adds some features of static scoping to the dynamic scoping process. However, since a section of code can be called from many different locations and situations, it can be difficult to determine at the outset what bindings will apply when a variable is used (or if one exists at all). This can be beneficial; application of the principle of least knowledge suggests that code avoid depending on the reasons for (or circumstances of) a variable's value, but simply use the value according to the variable's definition. This narrow interpretation of shared data can provide a very flexible system for adapting the behavior of a function to the current state (or policy) of the system. However, this benefit relies on careful documentation of all variables used this way as well as on careful avoidance of assumptions about a variable's behavior, and does not provide any mechanism to detect interference between different parts of a program. As such, dynamic scoping can be dangerous and almost no modern languages use it. Some languages, like Perl and Common Lisp, allow the programmer to choose static or dynamic scoping when (re)defining a variable. Logo and Emacs lisp are some of the few languages that use dynamic scoping.
Dynamic scoping is fairly easy to implement. To find an identifier's value, the program can traverse the runtime stack, checking each activation record (each function's stack frame) for a value for the identifier. This is known as deep binding. An alternate strategy that is usually more efficient is to maintain a stack of bindings for each identifier; the stack is modified whenever the variable is bound or unbound, and a variable's value is simply that of the top binding on the stack. This is called shallow binding. Note that both of these strategies assume a last-in-first-out (LIFO) ordering to bindings for any one variable; in practice all bindings are so ordered.

[edit] Example
This example compares the consequences of using static scope and dynamic scope. Observe the following code, in a C-like language:


int x = 0;
int f() { return x; }
int g() { int x = 1; return f(); }

With static scoping, calling g will return 0 since it has been determined at compile time that the expression x in any invocation of f will yield the global x binding which is unaffected by the introduction of a local variable of the same name in g.
With dynamic scoping, the binding stack for the x identifier will contain two items when f is invoked from g: the global binding to 0, and the binding to 1 introduced in g (which is still present on the stack since the control flow hasn't left g yet). Since evaluating the identifier expression by definition always yields the top binding, the result is 1.
In the language Perl, variables can be defined with either static or dynamic scoping. Perl's keyword "my" defines a statically scoped local variable, while the keyword "local" defines dynamically scoped local variable[1]. This allows for further clarification with practical examples of each scoping model.


$x = 0;
sub f { return $x; }
sub g { my $x = 1; return f(); }
print g()."\n";

The example above uses "my" for static scoping of g's local variable $x. As above, calling g returns 0 because f cannot see g's variable $x, so it looks for the global $x.


$x = 0;
sub f { return $x; }
sub g { local $x = 1; return f(); }
print g()."\n";

In this alternative, "local" is used to make g's $x dynamically-scoped. Now, calling g yields 1 because f sees g's local variable by looking up the execution stack.
In other words, the dynamically-scoped variable $x is resolved in the environment of execution, rather than the environment of definition.

[edit] References

Harold Abelson and Gerald Jay Sussman. “Lexical addressing”. Structure and Interpretation of Computer Programs.



^ Perl FAQ 4.3 What's the difference between dynamic and static (lexical) scoping?



[edit] See also

Closure (computer science)
Global variable
Local variable
Name binding
Name resolution
Variables (scope and extent)
Information hiding


[edit] External links

"Lexical Scoping in JavaScript" A blogpost on Lexical scoping in Javascript by Kartik bansal




Retrieved from "http://en.wikipedia.org/wiki/Scope_(programming)"
Categories: Programming constructsHidden categories: Articles needing additional references from December 2008 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Deutsch
Français
Italiano
Nederlands
日本語









 This page was last modified on 19 March 2009, at 01:48 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
