













List comprehension - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "List_comprehension";
		var wgTitle = "List comprehension";
		var wgAction = "view";
		var wgArticleId = "275744";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 284548563;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-lisp {line-height: normal;}
.source-lisp li, .source-lisp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for lisp
 * CSS class: source-lisp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-lisp .de1, .source-lisp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-lisp  {}
.source-lisp .head {}
.source-lisp .foot {}
.source-lisp .imp {font-weight: bold; color: red;}
.source-lisp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-lisp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-lisp li.li2 {font-weight: bold;}
.source-lisp .kw1 {color: #b1b100;}
.source-lisp .co1 {color: #808080; font-style: italic;}
.source-lisp .coMULTI {color: #808080; font-style: italic;}
.source-lisp .es0 {color: #000099; font-weight: bold;}
.source-lisp .br0 {color: #66cc66;}
.source-lisp .st0 {color: #ff0000;}
.source-lisp .nu0 {color: #cc66cc;}
.source-lisp .me0 {color: #555;}
.source-lisp .me1 {color: #555;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-ocaml {line-height: normal;}
.source-ocaml li, .source-ocaml pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for ocaml
 * CSS class: source-ocaml, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-ocaml .de1, .source-ocaml .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-ocaml  {}
.source-ocaml .head {}
.source-ocaml .foot {}
.source-ocaml .imp {font-weight: bold; color: red;}
.source-ocaml .ln-xtra {color: #cc0; background-color: #ffc;}
.source-ocaml li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-ocaml li.li2 {font-weight: bold;}
.source-ocaml .kw1 {color: #06c; font-weight: bold;}
.source-ocaml .coMULTI {color: #5d478b; font-style: italic;}
.source-ocaml .br0 {color: #a52a2a;}
.source-ocaml .st0 {color: #3cb371;}
.source-ocaml .nu0 {color: #c6c;}
.source-ocaml .me1 {color: #060;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-javascript {line-height: normal;}
.source-javascript li, .source-javascript pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for javascript
 * CSS class: source-javascript, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-javascript .de1, .source-javascript .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-javascript  {}
.source-javascript .head {}
.source-javascript .foot {}
.source-javascript .imp {font-weight: bold; color: red;}
.source-javascript .ln-xtra {color: #cc0; background-color: #ffc;}
.source-javascript li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-javascript li.li2 {font-weight: bold;}
.source-javascript .kw1 {color: #000066; font-weight: bold;}
.source-javascript .kw2 {color: #003366; font-weight: bold;}
.source-javascript .kw3 {color: #000066;}
.source-javascript .co1 {color: #009900; font-style: italic;}
.source-javascript .coMULTI {color: #009900; font-style: italic;}
.source-javascript .es0 {color: #000099; font-weight: bold;}
.source-javascript .br0 {color: #66cc66;}
.source-javascript .st0 {color: #3366CC;}
.source-javascript .nu0 {color: #CC0000;}
.source-javascript .me1 {color: #006600;}
.source-javascript .sc0 {}
.source-javascript .sc1 {}
.source-javascript .sc2 {}
.source-javascript .sc3 {}
.source-javascript .re0 {color: #0066FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); List comprehension

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
A list comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists. It follows the form of the mathematical set-builder notation (set comprehension.) as distinct from the use of map and filter functions.




Contents


1 Overview
2 History
3 Examples in different programming languages

3.1 Clojure
3.2 C#
3.3 Erlang
3.4 F#
3.5 Haskell
3.6 JavaFX
3.7 Javascript 1.8
3.8 OCaml
3.9 Python
3.10 Scala
3.11 Visual Prolog


4 Similar constructs

4.1 Monad comprehension
4.2 Set comprehension
4.3 Dict comprehension
4.4 Parallel list comprehension
4.5 XQuery and XPath


5 See also
6 Notes and references
7 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Overview
Consider the following example in set builder notation.



This can be read, "S is the set of all 2 times x where x is an item in the set of natural numbers, for which x squared is greater than 3."
In this annotated version of the example:




x is the variable representing members of an input set.
 represents the input set, which in this example is the set of natural numbers
x2 > 3 is a predicate function acting as a filter on members of the input set.
 is an output function producing members of the new set from members of the input set that satisfy the predicate function.
{} brackets contain the expression
 , the vertical bar and the comma are separators.


A list comprehension has the same syntactic components to represent generation of a list in order from an input list or iterator:

A variable representing members of an input list.
An input list (or iterator).
An optional predicate expression.
And an output expression producing members of the output list from members of the input iterable that satisfy the predicate.

The order of generation of members of the output list is based on the order of items in the input.

In Haskell's list comprehension syntax, this set-builder construct would be written similarly, as:

s = [ 2*x | x <- [0..], x^2 > 3 ] 

Here, the list [0..] represents , x^2>3 represents the predicate, and 2*x represents the output expression.

List comprehensions give results in a defined order, (unlike the members of sets); and list comprehensions may generate the members of a list in order, rather than produce the entirety of the list thus allowing, for example, the previous Haskell definition of the members of an infinite list.

[edit] History
The SETL programming language (later 1960's) had a set formation construct, and the computer algebra system AXIOM (1973) has a similar construct that processes streams, but the first use of the term "comprehension" for such constructs was in Rod Burstall and John Darlington's description of their programming language NPL from 1977.
Comprehensions were proposed as a query notation for databases[1] and were implemented in the Kleisli database query language.[2]

[edit] Examples in different programming languages
Main article: Comparison of programming languages (list comprehension)
The following provides a few examples of specific syntax used in programming languages. For a more comprehensive comparison, please see the main article in the Programming language comparison series.
Although the original example denotes an infinite list, few languages can express that, so in some of those cases we show how to take a subset of 0,1,...,100 rather than a subset of .


[edit] Clojure
Further information: Clojure
An infinite lazy sequence:


(for [x (iterate inc 0) :when (> (* x x) 3)] (* 2 x))

This code produces the first 20 items of the above sequence:


(take 20 (for [x (iterate inc 0) :when (> (* x x) 3)] (* 2 x)))

Result:


(4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42)



[edit] C#
Further information: C#
The infinite set of natural numbers can be made available as a static property with a getter:


public static IEnumerable<int> Naturals 
{
    get { for (int n = 0; ; n++) yield return n; } 
}

Then the set can be defined by a comprehension:


var s = from x in Naturals where x*x > 3 select x*2;

Latest .NET 3.5 Framework has Enumerable.Range method which allows to write like this:


var s = from x in Enumerable.Range(0, int.MaxValue) where x*x > 3 select x*2;

or equivalent code through chain methods:


var s = Enumerable.Range(0, int.MaxValue).Where(x => x*x > 3).Select(x => x*2);


[edit] Erlang
Further information: Erlang
The same example in Erlang:

S = [2*X || X <- lists:seq(0,100), X*X > 3].



[edit] F#
Further information: F#
The F# generator comprehension has the list comprehension syntax elements. Generator comprehensions can be used to generate Lists, Sequences (like lists but evaluated on-demand) and Arrays (not discussed here).
Generators are of the form [for x in collection do ... yield expr] for lists and seq {for x in collection do ... yield expr} for sequences. For example:


(* Int32.MaxValue used to indicate "infinite" *)
> seq { for x in 0..System.Int32.MaxValue do
          if x*x > 3 then yield 2*x } ;;
val it : seq<int> = seq [4; 6; 8; 10; ...]



[edit] Haskell
Further information: Haskell
(Please refer to the main example in the overview).


[edit] JavaFX
Further information: JavaFX
Using the for statement and a boolean expression:


  var s = for (i in [1..100][n | n*n > 3]) { 2*i }



[edit] Javascript 1.8


Number.prototype.__iterator__=function(){for (let i=0; i<this; i++) yield i}
 
var s = [2*i for (i in 100) if (i*i>3)]


[edit] OCaml
Further information: OCaml
OCaml Batteries Included has uniform comprehension syntax for lists, arrays, enumerations (like streams), lazy lists (like lists but evaluated on-demand), sets, hashtables, etc.
Comprehension are of the form [? expression | x <- enumeration ; condition; condition ; ...]
For instance,


#   [? 2 * x | x <- 0 -- max_int ; x * x > 3];;
- : int Enum.t = <abstr>

or, to compute a list,


#   [? List: 2 * x | x <- 0 -- 100 ; x * x > 3];;
- : int list = [2; 4; 6; 8; 10]

or, to compute a set,


#   [? PSet: 2 * x | x <- 0 -- 100 ; x * x > 3];;
- : int PSet.t = <abstr>

etc.


[edit] Python
Further information: Python syntax and semantics: Generators
The Python programming language has a corresponding syntax for expressing list comprehensions. The near-equivalent in Python to the example above is as follows:


S = [2*x for x in range(101) if x**2 > 3]

A generator expression may be used in Python 2.4 to achieve functional equivalence with S using a generator to iterate an infinite list:


from itertools import count
S = (2*x for x in count() if x**2 > 3)



[edit] Scala
Further information: Scala
Using the for-comprehension:

val s = for (x <- Stream.from(0); if x*x > 3) yield 2*x



[edit] Visual Prolog
Further information: Visual Prolog

S = [ 2*X || X = std::fromTo(1, 100), X^2 > 3 ]



[edit] Similar constructs

[edit] Monad comprehension
In Haskell, a monad comprehension is a generalization of the list comprehension to other monads in functional programming.


[edit] Set comprehension
Version 3 of the Python language introduces syntax for set comprehensions. Similar in form to list comprehensions, set comprehensions generate Python sets instead of lists.


>>> s = {v for v in 'ABCDABCD' if v not in 'CB'}
>>> print(s)
{'A', 'D'}
>>> type(s)
<class 'set'>
>>>



[edit] Dict comprehension
Version 3 of the Python language introduces syntax for dictionary comprehensions. Similar in form to list comprehensions, dictionary comprehensions generate Python dictionaries instead of lists.


>>> d = {k:v for k,v in zip(range(4), 'ABCD') if v not in 'CB'}
>>> print(d)
{0: 'A', 3: 'D'}
>>> type(d)
<class 'dict'>
>>>



[edit] Parallel list comprehension
The Glasgow Haskell Compiler has an extension called parallel list comprehension (also known as zip-comprehension) that permits multiple independent branches of qualifiers within the list comprehension syntax. Whereas qualifiers separated by commas are dependent, qualifier branches separated by pipes are evaluated in parallel.


[edit] XQuery and XPath
Like the original NPL use, these are fundamentally database access languages.
This makes the comprehension concept more important, because it is computationally infeasible to retrieve the entire list and operate on it (the initial 'entire list' may be an entire XML database).
In XPath, the expression:

/library/book//paragraph[@style='first-in-chapter']

is conceptually evaluated as a series of "steps" where each step produces a list and the next step applies a filter function to each element in the previous step's output. See: http://www.w3.org/TR/xpath#section-Location-Steps.
In XQuery, full XPath is available, but FLWOR statements are also used, which is a more powerful comprehension construct. See http://www.w3schools.com/XQuery/xquery_flwor.asp.

for $b in //book
where $b[@pages < 400]
order by $b//title
return
  <shortBook>
    <title>{$b//title}</title>
    <firstPara>{($book//paragraph)[1]}</firstPara>
  </shortBook>

Here the XPath //book is evaluated to create a sequence (aka list); the where clause is a functional "filter", the order by sorts the result, and the <shortBook>...</shortBook> XML snippet is actually an anonymous function that builds/transforms XML for each element in the sequence using the 'map' approach found in other functional languages.
So, in another functional language the above FLWOR statement may be implemented like this:

 map(
   newXML(shortBook, newXML(title, $1.title), newXML(firstPara, $1...))
   filter(
     lt($1.pages, 400), 
     xpath(//book)
   )
 )



[edit] See also

Cf. the SELECT statement together with its FROM and WHERE clauses in SQL.
Programming language
Mathematical notation
Monads in functional programming for monads and monadic notation in general
For other programming language constructs used to process sequences:

Generator (computer science)
Map (higher-order function)


For other programming language constructs copied from the mathematical notation:

Guard (computing)
Pattern matching
Operator (programming)





[edit] Notes and references


^ Comprehensions, a query notation for DBPLs
^ The functional guts of the Kleisli query system



List Comprehension in The Free On-line Dictionary of Computing, Editor Denis Howe.
Phil Trinder [1] Comprehensions, a query notation for DBPLs, Proceedings of the third international workshop on Database programming languages : bulk types & persistent data: bulk types & persistent data, Nafplion, Greece, Pages 55-68, 1992.
Philip Wadler. Comprehending Monads. Proceedings of the 1990 ACM Conference on LISP and Functional Programming, Nice. 1990.
Limsoon Wong [2] The Functional Guts of the Kleisli Query System, International Conference on Functional Programming, Proceedings of the fifth ACM SIGPLAN international conference on Functional programming, Pages 1-10, 2000.

Haskell:

The Haskell 98 Report, chapter 3.11 List Comprehensions.
The Glorious Glasgow Haskell Compilation System User's Guide, chapter 7.3.4 Parallel List Comprehensions.
The Hugs 98 User's Guide, chapter 5.1.2 Parallel list comprehensions (a.k.a. zip-comprehensions).

OCaml:

OCaml Batteries Included
Language extensions introduced in OCaml Batteries Included

Python:

Python Reference Manual, chapter 5.2.4 List displays.
Python Enhancement Proposal PEP 202: List Comprehensions.
Python Reference Manual, chapter 5.2.5 Generator expressions.
Python Enhancement Proposal PEP 289: Generator Expressions.

PostScript:

Systems, Adobe (1999-02). PostScript Language Reference Manual, Third Edition. Addison-Wesley. pp. 524–524. ISBN 0-201-37922-8. http://www.adobe.com/products/postscript/pdfs/PLRM.pdf. 

Common Lisp

Implementation of a Lisp comprehension macro by Guy Lapalme

Clojure

Clojure API documentation - for macro

Axiom:

Axiom stream examples: [3]



[edit] External links

SQL-like set operations with list comprehension one-liners in the Python Cookbook
Discussion on list comprehensions in Scheme and related constructs
List Comprehensions across languages




Retrieved from "http://en.wikipedia.org/wiki/List_comprehension"
Categories: Programming constructs | Articles with example code | Articles with example Haskell code | Articles with example Python code | Articles with example Scala code 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Català
Français
Nederlands
Português









 This page was last modified on 18 April 2009, at 02:44 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
