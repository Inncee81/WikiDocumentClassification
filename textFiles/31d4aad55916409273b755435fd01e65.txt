













Objective-C - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Objective-C";
		var wgTitle = "Objective-C";
		var wgAction = "view";
		var wgArticleId = "22802";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 279425290;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-objc {line-height: normal;}
.source-objc li, .source-objc pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for objc
 * CSS class: source-objc, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-objc .de1, .source-objc .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-objc  {}
.source-objc .head {}
.source-objc .foot {}
.source-objc .imp {font-weight: bold; color: red;}
.source-objc .ln-xtra {color: #cc0; background-color: #ffc;}
.source-objc li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-objc li.li2 {font-weight: bold;}
.source-objc .kw1 {color: #0000ff;}
.source-objc .kw2 {color: #0000ff;}
.source-objc .kw3 {color: #0000dd;}
.source-objc .kw4 {color: #0000ff;}
.source-objc .kw5 {color: #0000ff;}
.source-objc .kw6 {color: #0000ff;}
.source-objc .co1 {color: #ff0000;}
.source-objc .co2 {color: #339900;}
.source-objc .coMULTI {color: #ff0000; font-style: italic;}
.source-objc .es0 {color: #666666; font-weight: bold;}
.source-objc .br0 {color: #002200;}
.source-objc .st0 {color: #666666;}
.source-objc .nu0 {color: #0000dd;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Objective-C

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article may require copy-editing for grammar, style, cohesion, tone or spelling. You can assist by editing it now. A how-to guide is available. (August 2008)



Objective-C

Paradigm
reflective, object oriented


Appeared in
1986


Designed by
Brad Cox and Tom Love


Developer
Apple Inc.


Typing discipline
duck, static, weak


Major implementations
gcc, Apple


Influenced by
Smalltalk, C


Influenced
TOM, Java, Objective-J


Objective-C is a reflective, object-oriented programming language which adds Smalltalk-style messaging to C.
Today it is used primarily on Mac OS X, iPhone OS, and GNUstep, three environments based on the OpenStep standard, and is the primary language used for the NeXTSTEP, OPENSTEP, and Cocoa application frameworks. Generic Objective-C programs which do not make use of these libraries can also be compiled for any system supported by gcc, which includes an Objective-C compiler.




Contents


1 History

1.1 Popularization through NeXT


2 Syntax

2.1 Messages
2.2 Interfaces and implementations

2.2.1 Interface
2.2.2 Implementation
2.2.3 Instantiation


2.3 Protocols
2.4 Dynamic typing
2.5 Forwarding

2.5.1 Example
2.5.2 Notes


2.6 Categories

2.6.1 Example usage of categories
2.6.2 Notes


2.7 Posing
2.8 #import


3 Other features
4 Language variants

4.1 Objective-C++
4.2 Objective-C 2.0

4.2.1 Garbage collection
4.2.2 Properties
4.2.3 Fast enumeration
4.2.4 Implications for Cocoa development




5 Today

5.1 Portable Object Compiler


6 Analysis of the language

6.1 Philosophical differences between Objective-C and C++


7 See also
8 Notes
9 References
10 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] History
In the early 1980s, common software engineering practice was based on structured programming. Structured programming was implemented in order to help "break down" programs into smaller parts, primarily to make them easier to work on as they grew increasingly large. However, as the problems being solved grew in size, structured programming became less useful as more and more procedures had to be written, leading to complex control structures and a low level of code reuse.
Many saw object-oriented programming as a potential solution to the problem. In fact, Smalltalk had already addressed many of these engineering issues; some of the most complex systems in the world were Smalltalk environments.[citation needed] On the downside, Smalltalk used a virtual machine. The virtual machine interpreted an object memory called an image, containing all development tools. The Smalltalk image was very large and tended to require huge amounts of memory for the time and ran very slowly, partly due to the lack of useful hardware VM/container support.
Objective-C was created primarily by Brad Cox and Tom Love in the early 1980s at their company Stepstone. Both had been introduced to Smalltalk while at ITT’s Programming Technology Center in 1981. Cox had become interested in the problems of true reusability in software design and programming. He realized that a language like Smalltalk would be invaluable in building powerful development environments for system developers at ITT. Cox began by modifying the C compiler to add some of the capabilities of Smalltalk. He soon had a working implementation of an object-oriented extension to the C language which he called "OOPC" for Object-Oriented Programming in C. Love, meanwhile, was hired by Schlumberger Research in 1982 and had the opportunity to acquire the first commercial copy of Smalltalk-80, which further influenced development of their brainchild.
In order to demonstrate that real progress could be made, Cox showed that making interchangeable software components really needed only a few practical changes to existing tools. Specifically, they needed to support objects in a flexible manner, come supplied with a usable set of libraries, and allow for the code (and any resources needed by the code) to be bundled into a single cross-platform format.
Love and Cox eventually formed a new venture, Productivity Products International (PPI), to commercialize their product, which coupled an Objective-C compiler with powerful class libraries.
In 1986, Cox published the main description of Objective-C in its original form in the book Object-Oriented Programming, An Evolutionary Approach. Although he was careful to point out that there is more to the problem of reusability than just the language, Objective-C often found itself compared feature for feature with other languages.

[edit] Popularization through NeXT
In 1988, NeXT, the company started by Steve Jobs after he left Apple, licensed Objective-C from StepStone (the owner of the Objective-C trademark) and released their own Objective-C compiler and libraries on which the NeXTstep user interface and interface builder were based. Although the NeXT workstations failed to make much of an impact in the marketplace, the tools were widely lauded in the industry. This led NeXT to drop hardware production and focus on software tools, selling NeXTstep (and OpenStep) as a platform for custom programming.
The GNU project started work on their free clone of NeXTStep, named GNUstep, based on the OpenStep standard. Dennis Glatting wrote the first gnu-objc runtime in 1992. The GNU Objective-C runtime which has been in use since 1993 is the one developed by Kresten Krab Thorup when he was a university student in Denmark. Kresten also worked at NeXT from 1993 to 1996.
After acquiring NeXT in 1996, Apple used OpenStep in its new operating system, Mac OS X. This included Objective-C and NeXT's Objective-C based developer tool, Project Builder (later replaced by Xcode), as well as its interface design tool, Interface Builder. Most of Apple's present-day Cocoa API is based on OpenStep interface objects, and is the most significant Objective-C environment being used for active development.

[edit] Syntax
Objective-C is a very thin layer on top of C. Objective-C is a strict superset of C. That is, it is possible to compile any C program with an Objective-C compiler. Objective-C derives its syntax from both C and Smalltalk. Most of the syntax (including preprocessing, expressions, function declarations, and function calls) is inherited from C, while the syntax for object-oriented features was created to enable Smalltalk-style messaging.

[edit] Messages
Objective-C syntax offers alternatives to a few "kludges" in C syntax but more importantly supports object-oriented programming (OOP). The Objective-C model of object-oriented programming is based on sending messages to sovereign (even self-correcting) objects. This is unlike the Simula-style programming model used by C++ and this distinction is semantically important. The basic difference is that in Objective-C one does not call a method; one sends a message. In Objective-C the "receiver" of a message can opt to refuse it. Both styles carry their own strengths and weaknesses. Simula-style OOP allows multiple inheritance and faster execution by using compile-time binding whenever possible but does not support dynamic binding by default. It also forces all methods to have a corresponding implementation unless they are virtual (an implementation is still required for the method to be called). Smalltalk-style OOP allows messages to go unimplemented and is dynamically bound, but in some cases runs slower and some programmers (especially ones from Simula based languages) feel that it is a hassle to debug.[citation needed]
An object with method method is said to "respond" to the message method. Sending the message method to the object pointed to by the pointer obj would require the following code in C++:


obj->method(parameter);

which in Objective-C is written as follows:


[obj method:parameter];

This mechanism allows messages to be sent to an object defined first at runtime — something statically typed languages such as C++ are incapable of per the current standards for such languages. C++ will be able to support messaging per ANSI Standard if the Boost library is standardized. Qt provides this capability to C++ and other languages (but Objective-C is poorly supported) by adding the "connect" function as well as a large array of classes that afford and support this functionality. (See the dynamic typing section below for more advantages of dynamic (late) binding).
Objective-C has a few features in message-passing that relate to how it handles OOP. Objective-C messages do not need to execute because they are dynamically bound. If a message is implemented by an object, it will execute. If not, it will not execute, yet the code will still compile and run. So for example, every object is sent an "awakeFromNib" message, but those objects don't necessarily have to implement "awakeFromNib" to compile – if an object does implement "awakeFromNib", then that code will be executed when the message is sent, otherwise the message is ignored. Messages can also be sent to the object that implements them or to the superclass that an object is derived from. These can be accessed using the "self" and "super" object pointers. Also, messages can be sent to nil objects.

[edit] Interfaces and implementations
Objective-C requires the interface and implementation of a class be in separately declared code blocks. By convention, the interface is put in a header file and the implementation in a code file; the header files, normally suffixed .h, are similar to C header files; the implementation (method) files, normally suffixed .m, can be very similar to C code files.

[edit] Interface
The interface of the class is usually defined in a header file. A common convention is to name the header file after the name of the class. The interface for class Class would thus be found in the file Class.h.
The interface declaration of the form:


@interface classname : superclassname {
    // instance variables
}
+classMethod1;
+(return_type)classMethod2;
+(return_type)classMethod3:(param1_type)parameter_varName;
 
-(return_type)instanceMethod1:(param1_type)param1_varName :(param2_type)param2_varName;
-(return_type)instanceMethod2WithParameter:(param1_type)param1_varName andOtherParameter:(param2_type)param2_varName;
@end

Plus signs denote class methods, minus signs denote instance methods. Class methods have no access to instance variables.
If you are translating from C++/C97 the above code is somewhat equivalent to:


struct classname : superclassname {
  // instance variables
 
  // Class (static) functions
  static void classMethod1();
  static return_type classMethod2();
  static return_type classMethod3(param1_type parameter_varName);
 
  // Instance (member) functions
  return_type instanceMethod1(param1_type param1_varName, param2_type param2_varName);
  return_type instanceMethod2WithParameter(param1_type param1_varName, param2_type param2_varName=default);
};

Note that instanceMethod2 demonstrates Objective C's named parameter capability for which there is no direct equivalent in C/C++.
Return types can be any standard C type, a pointer to a generic Objective-C object, or a pointer to a specific type of object such as NSArray *, NSImage *, or NSString *. The default return type is the generic Objective-C type id.
Method arguments begin with a colon followed by the expected argument type in parentheses followed by the argument name. In some cases (e.g. when writing system APIs) it is useful to add descriptive text before each parameter.


-(void) setRange:(int)start :(int)end;
-(void) importDocumentWithName:(NSString *)name withSpecifiedPreferences:(Preferences *)prefs beforePage:(int)insertPage;


[edit] Implementation
The interface only declares the class interface and not the methods themselves; the actual code is written in the implementation. Implementation (method) files normally have the file extension .m.


@implementation classname
+classMethod {
    // implementation
}
-instanceMethod {
    // implementation
}
@end

Methods are written as with their interface declarations. Comparing Objective-C and C:


-(int)method:(int)i {
    return [self square_root: i];
}



int function(int i) {
    return square_root(i);
}

The syntax allows pseudo-naming of arguments.


-(int)changeColorToRed:(float)red green:(float)green blue:(float)blue
 
[myColor changeColorToRed:5.0 green:2.0 blue:6.0];

Internal representations of this method vary between different implementations of Objective-C. If myColor is of the class Color, internally, instance method -changeColorToRed:green:blue: might be labeled _i_Color_changeColorToRed_green_blue. The i is to refer to an instance method, with the class and then method names appended, colons translated to underscores. As the order of parameters is part of the method name, it cannot be changed to suit coding style or expression as in true named parameters.
However, internal names of the function are rarely used directly, and generally messages are converted to function calls defined in the Objective-C runtime library – it's not necessarily known at link time which method will be called: the class of the receiver (the object being sent the message) need not be known until runtime.

[edit] Instantiation
Once an Objective-C class is written, it can be instantiated. This is done by first allocating the memory for a new object and then by initializing it. An object isn't fully functional until both steps have been completed. These steps are typically accomplished with a single line of code:


MyObject * o = [[MyObject alloc] init];

The alloc call allocates enough memory to hold all the instance variables for an object, and the init call can be overridden to set instance variables to specific values on creation. The init method is often written as follows:


-(id) init {
    self = [super init];
    if (self) {
        ivar1 = value1;
        ivar2 = value2;
        .
        .
        .
    }
    return self;
}


[edit] Protocols
Objective-C was extended at NeXT to introduce the concept of multiple inheritance of specification, but not implementation, through the introduction of protocols. This is a pattern achievable either as an abstract multiply-inherited base class in C++, or as an "interface" (as in Java and C#). Objective-C makes use of ad-hoc protocols, called informal protocols, and compiler enforced protocols called formal protocols.
An informal protocol is a list of methods which a class can implement. It is specified in the documentation, since it has no presence in the language. Informal protocols often include optional methods, where implementing the method can change the behavior of a class. For example, a text field class might have a delegate which should implement an informal protocol with an optional autocomplete method. The text field discovers whether the delegate implements that method (via reflection), and, if so, calls it to support autocomplete.
A formal protocol is similar to an interface in Java or C#. It is a list of methods which any class can declare itself to implement. Versions of Objective-C before 2.0 required that a class must implement all methods in a protocol it declares itself as adopting; the compiler will emit an error if the class does not implement every method of its declared protocols. However, Objective-C 2.0 added support for marking certain methods in a protocol optional; the compiler will not enforce that such methods are implemented.
The Objective-C concept of protocols is different from the Java or C# concept of interfaces in that a class may implement a protocol without being declared to implement that protocol. The difference is not detectable from outside code. Formal protocols cannot provide any implementations, they simply assure callers that classes which conform to the protocol will provide implementations. In the NeXT/Apple library, protocols are frequently used by the Distributed Objects system to represent the capabilities of an object executing on a remote system.
The syntax


@protocol Locking
- (void)lock;
- (void)unlock;
@end

denotes that there is the abstract idea of locking which is useful, and when stated in a class definition


@interface SomeClass : SomeSuperClass <Locking>
@end

denotes that instances of SomeClass will provide an implementation for the two instance methods using whatever means they want. This abstract specification is particularly useful to describe the desired behaviors of plug-ins for example, without constraining at all what the implementation hierarchy should be.

[edit] Dynamic typing
Objective-C, like Smalltalk, can use dynamic typing: an object can be sent a message that is not specified in its interface. This can allow for increased flexibility — in Objective-C an object can "capture" this message, and depending on the object, can send the message off again to a different object (who can respond to the message correctly and appropriately, or likewise send the message on again). This behavior is known as message forwarding or delegation (see below). Alternatively, an error handler can be used instead, in case the message cannot be forwarded. If the object does not forward the message, handle the error, or respond to it, a runtime error occurs.
Static typing information may also optionally be added to variables. This information is then checked at compile time. In the following statements, increasingly specific type information is provided. The statements are equivalent at runtime, but the additional information allows the compiler to warn the programmer if the passed argument does not match the type specified. In the first statement, the object may be of any class. In the second statement, the object must conform to the aProtocol protocol, and in the third, it must be a member of the NSNumber class.


- setMyValue:(id) foo;
- setMyValue:(id <aProtocol>) foo;
- setMyValue:(NSNumber*)foo;

Dynamic typing can be a powerful feature. When implementing container classes using statically-typed languages without generics like pre-1.5 Java, the programmer is forced to write a container class for a generic type of object, and then cast back and forth between the abstract generic type and the real type. Casting however breaks the discipline of static typing – if you put in an Integer and read out a String, you get an error. One way of alleviating the problem is to resort to generic programming, but then container classes must be homogeneous in type. This need not be the case with dynamic typing.

[edit] Forwarding
Since Objective-C permits the sending of a message to an object which might not respond to it, the object has a number of things it can do with the message. One of these things could be to forward the message on to an object which can respond to it. Forwarding can be used to implement certain design patterns, such as the Observer pattern or the Proxy pattern very simply.
The Objective-C runtime specifies a pair of methods in Object

forwarding methods:



- (retval_t) forward:(SEL) sel :(arglist_t) args; // with GCC
- (id) forward:(SEL) sel :(marg_list) args; // with NeXT/Apple systems


action methods:



- (retval_t) performv:(SEL) sel :(arglist_t) args;  // with GCC
- (id) performv:(SEL) sel :(marg_list) args; // with NeXT/Apple systems

and as such an object wishing to implement forwarding needs only to override the forwarding method to define the forwarding behaviour. The action methods performv:: need not be overridden as this method merely performs the method based on the selector and arguments.

[edit] Example
Here is an example of a program which demonstrates the basics of forwarding.

Forwarder.h



#import <objc/Object.h>
 
@interface Forwarder : Object
{
    id recipient; //The object we want to forward the message to. 
}
 
//Accessor methods
- (id) recipient;
- (id) setRecipient:(id) _recipient; 
 
@end


Forwarder.m



#import "Forwarder.h"
 
@implementation Forwarder
 
- (retval_t) forward: (SEL) sel : (arglist_t) args
{
    /*
     * Check whether the recipient actually responds to the message. 
     * This may or may not be desirable, for example, if a recipient
     * in turn does not respond to the message, it might do forwarding
     * itself.
     */
    if([recipient respondsTo:sel]) 
       return [recipient performv: sel : args];
    else
       return [self error:"Recipient does not respond"];
}
 
- (id) setRecipient: (id) _recipient
{
    recipient = _recipient;
    return self;
}
 
- (id) recipient
{
    return recipient;
}
 @end


Recipient.h



#import <objc/Object.h>
 
// A simple Recipient object.
@interface Recipient : Object
- (id) hello;
@end


Recipient.m



#import "Recipient.h"
 
@implementation Recipient
 
- (id) hello
{
    printf("Recipient says hello!\n");
 
    return self;
}
 
@end


main.m



#import "Forwarder.h"
#import "Recipient.h"
 
int
main(void)
{
    Forwarder *forwarder = [Forwarder new];
    Recipient *recipient = [Recipient new];
 
    [forwarder setRecipient:recipient]; //Set the recipient. 
    /* 
     * Observe forwarder does not respond to a hello message! It will
     * be forwarded. All unrecognized methods will be forwarded to
     * the recipient 
     * (if the recipient responds to them, as written in the Forwarder)
     */
    [forwarder hello]; 
 
    return 0;
}


[edit] Notes
If we were to compile the program, the compiler would report

$ gcc -x objective-c -Wno-import Forwarder.m Recipient.m main.m -lobjc
main.m: In function `main':
main.m:12: warning: `Forwarder' does not respond to `hello'
$

The compiler is reporting the point made earlier, that Forwarder does not respond to hello messages. In certain circumstances, such a warning can help us find errors, but in this circumstance, we can safely ignore this warning, since we have implemented forwarding. If we were to run the program

$ ./a.out
Recipient says hello!


[edit] Categories
Cox’s main concern was the maintainability of large code bases. Experience from the structured programming world had shown that one of the main ways to improve code was to break it down into smaller pieces. Objective-C borrowed and extended the concept of Categories to help with this process from Smalltalk implementations (e.g., see [1]).
A category collects method implementations into separate files. The programmer can place groups of related methods into a category to make them more readable. For instance, one could create a "SpellChecking" category "on" the String object, collecting all of the methods related to spell checking into a single place.
Furthermore, the methods within a category are added to a class at runtime. Thus, categories permit the programmer to add methods to an existing class without the need to recompile that class or even have access to its source code. For example, if the system you are supplied with does not contain a spell checker in its String implementation, you can add it without modifying the String source code.
Methods within categories become indistinguishable from the methods in a class when the program is run. A category has full access to all of the instance variables within the class, including private variables.
Categories provide an elegant solution to the fragile base class problem for methods.
If you declare a method in a category with the same method signature as an existing method in a class, the category’s method is adopted. Thus categories can not only add methods to a class, but also replace existing methods. This feature can be used to fix bugs in other classes by rewriting their methods, or to cause a global change to a class’ behavior within a program. If two categories have methods with the same method signature, it is undefined which category’s method is adopted.
Other languages have attempted to add this feature in a variety of ways. TOM took the Objective-C system a step further and allowed for the addition of variables as well. Other languages have instead used prototype oriented solutions, the most notable being Self.

[edit] Example usage of categories
This example builds up an Integer class, by defining first a basic class with only accessor methods implemented, and adding two categories, Arithmetic and Display, which extend the basic class. Whilst categories can access the base class’ private data members, it is often good practice to access these private data members through the accessor methods, which helps keep categories more independent from the base class. This is one typical usage of categories—the other is to use categories to add or replace certain methods in the base class (however it is not regarded as good practice to use categories for subclass overriding, also known as monkey patching).

Integer.h



#import <objc/Object.h>
 
@interface Integer : Object
{
    int integer;
}
 
- (int) integer;
- (id) integer: (int) _integer;
@end


Integer.m



#import "Integer.h"
 
@implementation Integer
- (int) integer
{
    return integer;
}
 
- (id) integer: (int) _integer
{
    integer = _integer;
 
    return self;
}
@end


Arithmetic.h



#import "Integer.h"
 
@interface Integer (Arithmetic)
- (id) add: (Integer *) addend;
- (id) sub: (Integer *) subtrahend;
@end


Arithmetic.m



#import "Arithmetic.h"
 
@implementation Integer (Arithmetic) 
- (id) add: (Integer *) addend
{
    return [self integer: [self integer] + [addend integer]];
}
 
- (id) sub: (Integer *) subtrahend
{
    return [self integer: [self integer] - [subtrahend integer]];
}
@end


Display.h



#import "Integer.h"
 
@interface Integer (Display)
- (id) showstars;
- (id) showint;
@end


Display.m



#import "Display.h"
 
@implementation Integer (Display) 
- (id) showstars
{
    int i, x = [self integer];
    for(i=0; i < x; i++)
       printf("*");
    printf("\n");
 
    return self;
}
 
- (id) showint
{
    printf("%d\n", [self integer]);
 
    return self;
}
@end


main.m



#import "Integer.h"
#import "Arithmetic.h" 
#import "Display.h"
 
int
main(void)
{
    Integer *num1 = [Integer new], *num2 = [Integer new];
    int x;
    printf("Enter an integer: ");
    scanf("%d", &x);
    [num1 integer:x];
    [num1 showstars];
    printf("Enter an integer: ");
    scanf("%d", &x);
    [num2 integer:x];
    [num2 showstars];
 
    [num1 add:num2];
    [num1 showint];
}


[edit] Notes
Compilation is performed, for example, by

gcc -x objective-c main.m Integer.m Arithmetic.m Display.m -lobjc

One can experiment by omitting the #import "Arithmetic.h" and [num1 add:num2] lines and omit Arithmetic.m in compilation. The program will still run. This means that it is possible to "mix-and-match" added categories if necessary – if one does not need to have some capability provided in a category, one can simply not compile it in.

[edit] Posing
Objective-C permits a class to wholly replace another class within a program. The replacing class is said to "pose as" the target class.
Note: Class posing was declared deprecated with Mac OS X v10.5 and unavailable in the 64-bit runtime.
For the versions still supporting posing: All messages sent to the target class are instead received by the posing class. There are several restrictions:

A class may only pose as one of its direct or indirect superclasses
The posing class must not define any new instance variables which are absent from the target class (though it may define or override methods).
The target class may not have received any messages prior to the posing.

Posing, similarly to categories, allows globally augmenting existing classes. Posing permits two features absent from categories:

A posing class can call overridden methods through super, thus incorporating the implementation of the target class.
A posing class can override methods defined in categories.

For example,


@interface CustomNSApplication : NSApplication
@end
 
@implementation CustomNSApplication
- (void) setMainMenu: (NSMenu*) menu
{
     // do something with menu
}
@end
 
class_poseAs ([CustomNSApplication class], [NSApplication class]);

This intercepts every invocation of setMainMenu to NSApplication.

[edit] #import
In the C language, the #include pre-compile directive allows for the insertion of entire files before any compilation actually begins. Objective-C adds the #import directive, which does the same thing, except that it knows not to insert a file which has already been inserted.
For example, if file A includes files X and Y, but X and Y each include the file Q, then Q will be inserted twice into the resultant file, causing "duplicate definition" compile errors. But if file Q is included using the #import directive, only the first inclusion of Q will occur—all others will be ignored.
A few compilers, including GCC, support #import for C programs too; its use is discouraged on the basis that the user of the header file has to distinguish headers which should be included only once, from headers designed to be used multiple times. It is argued that this burden should be placed on the implementor; to this end, the implementor may place the directive #pragma once in the header file, or use the traditional #include guard technique:


#ifndef HEADER_H
#define HEADER_H
... contents of header.h ...
#endif

If a header file uses guards or #pragma once, it makes no difference whether it is #included or #imported. The same objection to #import actually applies to Objective-C as well, and many Objective-C programs also use guards in their headers.

[edit] Other features
Objective-C's features often allow for flexible, and often easy, solutions to programming issues.

Delegating methods to other objects and remote invocation can be easily implemented using categories and message forwarding.
Swizzling of the isa pointer allows for classes to change at runtime. Typically used for debugging where freed objects are swizzled into zombie objects, whose only purpose is to report an error when someone calls them. Swizzling was also used in EOF to create database faults. Swizzling is used today by Apple’s Foundation Framework to implement Key-Value Observing.
Serialization, commonly called archival in Objective-C, can be done by overriding write and read methods.


[edit] Language variants

[edit] Objective-C++
Objective-C++ is a front-end to the GNU Compiler Collection which can compile source files which use a combination of C++ and Objective-C syntax. Objective-C++ adds to C++ the extensions Objective-C adds to C. As nothing is done to unify the semantics behind the various language features, certain restrictions apply:

A C++ class cannot derive from an Objective-C class and vice versa.
C++ namespaces cannot be declared inside an Objective-C declaration.
Objective-C classes cannot have instance variables of C++ classes which do not have a default constructor or which have one or more virtual methods, but pointers to C++ objects can be used as instance variables without restriction (allocate them with new in the -init method).
C++ "by value" semantics cannot be applied to Objective-C objects, which are only accessible through pointers.
An Objective-C declaration cannot be within a C++ template declaration and vice versa. Objective-C types, (e.g., Classname *) can be used as C++ template parameters, however.
Objective-C and C++ exception handling is distinct; the handlers of each cannot handle exceptions of the other type.
Care must be taken since the destructor calling conventions of Objective-C and C++’s exception run-time models do not match (i.e., a C++ destructor will not be called when an Objective-C exception exits the C++ object’s scope).


[edit] Objective-C 2.0
At the 2006 Worldwide Developers Conference, Apple announced the forthcoming release of "Objective-C 2.0," a revision of the Objective-C language to include "modern garbage collection, syntax enhancements[2], runtime performance improvements[3], and 64-bit support". Mac OS X v10.5, released in October 2007, included an Objective-C 2.0 compiler. It is not yet known when these language improvements will be available in the GNU runtime.

[edit] Garbage collection
Objective-C 2.0 provides an optional conservative yet generational garbage collector. When run in backwards-compatible mode, the runtime turns reference counting operations such as "retain" and "release" into no-ops. All objects are subject to garbage collection when garbage collection is enabled. Regular C pointers may be qualified with "__strong" to also trigger the underlying write-barrier compiler intercepts and thus participate in garbage collection. A zero-ing weak subsystem is also provided such that pointers marked as "__weak" are set to zero when the object (or more simply GC memory) is collected. The garbage collector does not exist on the iPhone implementation of Objective-C 2.0.

[edit] Properties
Objective-C 2.0 introduces a new syntax to declare instance variables as properties, with optional attributes to configure the generation of accessor methods. Properties are, in a sense, public instance variables; that is, declaring an instance variable as a property provides external classes with access (possibly limited, e.g. readonly) to that property. A property may be declared as "readonly", and may be provided with storage semantics such as "assign", "copy" or "retain". By default, properties are considered atomic, which results in a lock preventing multiple threads from accessing them at the same time. A property can be declared as "nonatomic" which removes this lock.


@interface Person : NSObject {
    @public NSString *name;
    @private int age;
}
@property(copy) NSString *name;
@property(readonly) int age;
-(id)initWithAge:(int)age;
@end

Properties are implemented by way of the @synthesize keyword, which generates getter and setter methods according to the property declaration. Alternately, the @dynamic keyword can be used to indicate that accessor methods will be provided by other means.


@implementation Person
@synthesize name;
@dynamic age;
-(id)initWithAge:(int)initAge
{
    age = initAge; // NOTE: direct instance variable assignment, not property setter
    return self;
}
-(int)age
{
    return 29; // NOTE: lying about age
}
@end

Properties can be accessed using the traditional message passing syntax, dot notation, or by name via the "valueForKey:"/"setValue:forKey:" methods.


Person *aPerson = [[Person alloc] initWithAge: 53];
aPerson.name = @"Steve"; // NOTE: dot notation, uses synthesized setter, equivalent to [aPerson setName: @"Steve"];
NSLog(@"Access by message (%@), dot notation(%@), property name(%@) and direct instance variable access (%@)",
      [aPerson name], aPerson.name, [aPerson valueForKey:@"name"], aPerson->name);

In order to use dot notation to invoke property accessors within an instance method, the "self" keyword should be used:


-(void) introduceMyselfWithProperties:(BOOL)useGetter
{
    NSLog(@"Hi, my name is %@.", (useGetter ? self.name : name)); // NOTE: getter vs. ivar access
}

A class or protocol's properties may be dynamically introspected.


int i, propertyCount = 0;
objc_property_t *propertyList = class_copyPropertyList([aPerson class], &propertyCount);
for (i=0; i<propertyCount; i++) {
    objc_property_t *thisProperty = propertyList + i;
    const char* propertyName = property_getName(*thisProperty);
    NSLog(@"Person has a property: '%s'", propertyName);
}


[edit] Fast enumeration
Instead of using an Enumerator object to iterate through a collection, Objective-C 2.0 offers the fast enumeration syntax. The following two loops are equivalent in Objective-C 2.0.


for (int i=0; i<[thePeople count]; i++) {
    Person *p = [thePeople objectAtIndex:i];
    NSLog(@"%@ is %i years old.", [p getName], [p getAge]);
}
 
for (Person *p in thePeople)
    NSLog(@"%@ is %i years old.", [p getName], [p getAge]);

Fast enumeration generates more efficient code than standard enumeration because methods calls to enumerate over objects are replaced by pointer arithmetic using the NSFastEnumeration protocol.[4]

[edit] Implications for Cocoa development
All Objective-C applications developed for Mac OS X that make use of the above improvements for Objective-C 2.0 are incompatible with all operating systems prior to 10.5 (Leopard). Even using fast enumeration, which one might expect to generate the exact same binaries as standard enumeration, will cause an application to crash on OS X version 10.4 or earlier.

[edit] Today
Objective-C today is often used in tandem with a fixed library of standard objects (often known as a "kit" or "framework"), such as Cocoa or GNUstep. These libraries often come with the operating system: the GNUstep libraries often come with Linux distributions and Cocoa comes with Mac OS X. The programmer is not forced to inherit functionality from the existing base class (NSObject). Objective-C allows for the declaration of new root classes which do not inherit any existing functionality. Originally, Objective-C based programming environments typically offered an Object class as the base class from which almost all other classes inherited. With the introduction of OpenStep, NeXT created a new base class named NSObject which offered additional features over Object (an emphasis on using object references and reference counting instead of raw pointers, for example). Almost all classes in Cocoa inherit from NSObject.
Not only did the renaming serve to differentiate the new default behavior of classes within the OpenStep API, but it allowed code which used Object — the original base class used on NeXTSTEP (and, more or less, other Objective-C class libraries) — to co-exist in the same runtime with code which used NSObject (with some limitations). As well, the introduction of the two letter prefix became a sort of simplistic form of namespaces, which Objective-C lacks. Using a prefix to create an informal packaging identifier became an informal coding standard in the Objective-C community, and continues to this day.

[edit] Portable Object Compiler
Besides the GCC/NeXT/Apple implementation, which added several extensions to the original Stepstone implementation, there exists another free open-source Objective-C implementation, which implements a slightly different set of extensions: The Portable Object Compiler [5] implements, among other things, also Smalltalk-like blocks for Objective-C.

[edit] Analysis of the language
Objective-C implementations use a thin runtime written in C which adds little to the size of the application. In contrast, most OO systems at the time that it was created used large virtual machine runtimes. Programs written in Objective-C tend to be not much larger than the size of their code and that of the libraries (which generally do not need to be included in the software distribution), in contrast to Smalltalk systems where a large amount of memory was used just to open a window. Objective-C applications tend to be larger than similar C or C++ applications because Objective-C dynamic typing does not allow methods to be stripped or inlined.
Likewise, the language can be implemented on top of existing C compilers (in GCC, first as a preprocessor, then as a module) rather than as a new compiler. This allows Objective-C to leverage the huge existing collection of C code, libraries, tools, and mindshare. Existing C libraries can be wrapped in Objective-C wrappers to provide an OO-style interface.
All of these practical changes lowered the barrier to entry, likely the biggest problem for the widespread acceptance of Smalltalk in the 1980s.
The first versions of Objective-C did not support garbage collection. At the time this decision was a matter of some debate, and many people considered long "dead times" (when Smalltalk did collection) to render the entire system unusable. Some 3rd party implementations have added this feature (most notably GNUstep) and Apple have implemented it as of Mac OS X v10.5.[6]
Another common criticism is that Objective-C does not have language support for namespaces. Instead, programmers are forced to add prefixes to their class names, which are traditionally shorter than namespace names and thus more prone to collisions. As of 2007, all Mac OS X classes and functions in the Cocoa programming environment are prefixed with "NS" (e.g. NSObject, NSButton) to identify them as belonging to the Mac OS X core; the "NS" derives from the names of the classes as defined during the development of NeXTstep.
Since Objective-C is a strict superset of C, it does not treat C primitive types as first-class objects either.
Unlike C++, Objective-C does not support operator overloading. Also unlike C++, Objective-C allows an object to directly inherit only from one class (forbidding multiple inheritance). However, categories and protocols may be used as alternative functionality to multiple inheritance.
Because Objective-C uses dynamic runtime typing and because all method calls are function calls (or, in some cases, syscalls), many common performance optimizations cannot be applied to Objective-C methods (for example: inlining, constant propagation, interprocedural optimizations, and scalar replacement of aggregates). This limits the performance of Objective-C abstractions relative to similar abstractions in languages such as C++. Proponents of Objective-C claim that it should not be used for low level abstraction in the way that C++ or Java are used, because Objective-C is known to have a high runtime cost.

[edit] Philosophical differences between Objective-C and C++
The design and implementation of C++ and Objective-C represent different approaches to extending C.
In addition to C’s style of procedural programming, C++ directly supports object-oriented programming, generic programming, and metaprogramming. C++ also comes with a large standard library which includes several container classes. Objective-C, on the other hand, adds only object-oriented features to C. Objective-C in its purest fashion does not contain the same number of standard library features, but in most places where Objective-C is used, it is used with an OpenStep-like library such as OPENSTEP, Cocoa, or GNUstep which provide similar functionality to some of C++’s standard library.
One notable difference is that Objective-C provides runtime support for some reflective features, whereas C++ adds only a small amount of runtime support to C. In Objective-C, an object can be queried about its own properties, for example whether it will respond to a certain message. In C++ this is not possible without the use of external libraries.
The use of reflection is part of the wider distinction between dynamic (run-time) features versus static (compile-time) features of a language. Although Objective-C and C++ each employ a mix of both features, Objective-C is decidedly geared toward run-time decisions while C++ is geared toward compile-time decisions. The tension between dynamic and static programming involves many of the classic trade-offs in programming.

[edit] See also

Comparison of programming languages


[edit] Notes


^ http://video.google.com/videoplay?docid=-7466310348707586940&ei=0dr7SIe6L46qrgLk7dHsDg&q=Smalltalk-80
^ http://lists.apple.com/archives/Objc-language/2006/Aug/msg00039.html
^ http://lists.apple.com/archives/Objc-language/2006/Aug/msg00018.html
^ Apple, Inc. (2007). "Fast Enumeration". http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_8_section_1.html. Retrieved on 2008-06-09. 
^ http://users.pandora.be/stes/compiler.html
^ Apple, Inc. (August 22, 2006). "Mac OS X Leopard – Xcode 3.0". http://www.apple.com/macosx/developertools/xcode.html. Retrieved on 2006-08-22. 



[edit] References

Cox, Brad J. (1991). Object Oriented Programming: An Evolutionary Approach. Addison Wesley. ISBN 0-201-54834-8. 


[edit] External links



Wikibooks has a book on the topic of
Programming:Objective-C




Introduction to The Objective-C Programming Language (Apple Developer Connection)
The Objective-C 2.0 Programming Language, PDF download from Apple
Objective-C GNUstep Base Programming Manual
Object-Oriented Programming and The Objective-C Language
Beginner’s Guide to Objective-C
ObjectiveLib: variant of a Standard Template Library
Objective-C by Brad Cox
Object Oriented Programming in Objective-C
Objective-C FAQ
comp.lang.objective-C FAQ
Objective-C: Links, Resources, Stuff
Objective-C mailing list
AST for Objective-C in C#








v • d • e

C programming language





Libraries

C standard library · glibc · Dietlibc · uClibc · Newlib · more






Features

String · Syntax · Preprocessor · Variable types and declarations · Functions






Descendants

C++ · Objective-C · D · C#






C and Other Languages

C and C++ (Compatibility · Operators) · Comparison of Pascal and C · C to Java byte-code compiler






Category








Retrieved from "http://en.wikipedia.org/wiki/Objective-C"
Categories: C programming language family | Object-oriented programming languages | Dynamically-typed programming languages | Class-based programming languages | NeXT | GNUstep | Curly bracket programming languages | Objective-CHidden categories: Wikipedia articles needing copy edit from August 2008 | All articles needing copy edit | All articles with unsourced statements | Articles with unsourced statements since February 2007 | Articles with unsourced statements since December 2008 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


বাংলা
Български
Česky
Dansk
Deutsch
Español
Esperanto
Français
Galego
한국어
Italiano
Magyar
Nederlands
日本語
‪Norsk (bokmål)‬
Polski
Português
Русский
Simple English
Slovenčina
Suomi
Svenska
ไทย
Тоҷикӣ
Türkçe
Українська
中文









 This page was last modified on 24 March 2009, at 19:38.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
