













C Sharp (programming language) - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "C_Sharp_(programming_language)";
		var wgTitle = "C Sharp (programming language)";
		var wgAction = "view";
		var wgArticleId = "2356196";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 282088004;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); C Sharp (programming language)

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article may require copy-editing for grammar, style, cohesion, tone or spelling. You can assist by editing it now. A how-to guide is available. (August 2008)



The correct title of this article is C# (programming language). The substitution or omission of a # sign is because of Wikipedia's technical restrictions for naming articles.


C#

Paradigm
structured, imperative, object-oriented, functional.


Appeared in
2001


Designed by
Microsoft Corporation


Latest release
3/ 19 November 2007


Typing discipline
static, strong, safe, nominative


Major implementations
.NET Framework, Mono, DotGNU


Influenced by
Object Pascal, C++, Modula-3, Java, Eiffel, C


Influenced
F#, Nemerle, D, Java[1], Vala, Windows PowerShell


C# (pronounced C Sharp) is a multi-paradigm programming language that encompasses functional, imperative, generic, object-oriented (class-based), and component-oriented programming disciplines. It was developed by Microsoft as part of the .NET initiative and later approved as a standard by ECMA (ECMA-334) and ISO (ISO/IEC 23270). C# is one of the programming languages supported by the .NET Framework's Common Language Runtime.
C# is intended to be a simple, modern, general-purpose, object-oriented programming language. Its development team is led by Anders Hejlsberg, the designer of Borland's Object Pascal language. It has an object-oriented syntax based on C++ and is heavily influenced by Java. It was initially named Cool, which stood for "C-like Object Oriented Language." However, in July 2000, when Microsoft made the project public, the name of the programming language was given as C#. The most recent version of the language is 3.0 which was released in conjunction with the .NET Framework 3.5 in 2007. The next proposed version, 4.0, is in development.




Contents


1 Design goals
2 History
3 Features
4 Common Type system (CTS)

4.1 Categories of datatypes
4.2 Boxing and unboxing


5 Features of C# 2.0

5.1 Partial class
5.2 Generics
5.3 Static classes
5.4 A new form of iterator providing generator functionality
5.5 Anonymous delegates
5.6 Delegate covariance and contravariance
5.7 The accessibility of property accessors can be set independently
5.8 Nullable types
5.9 Null-Coalesce operator


6 Features of C# 3.0

6.1 LINQ (Language-Integrated Query)
6.2 Object initializers
6.3 Collection initializers
6.4 Anonymous types
6.5 Local variable type inference
6.6 Lambda expressions
6.7 Automatic properties
6.8 Extension methods
6.9 Partial methods


7 Features of C# 4.0

7.1 Dynamic member lookup
7.2 Covariant and contravariant generic type parameters
7.3 Optional ref Keyword when using COM
7.4 Optional parameters and named arguments
7.5 Indexed properties


8 Preprocessor
9 Code comments
10 XML documentation system
11 Libraries
12 "Hello, world" example
13 Standardization

13.1 Criticism


14 Implementations
15 Language name
16 See also

16.1 Environments and tools
16.2 Related languages
16.3 Comparisons


17 Notes
18 References
19 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Design goals
The ECMA standard lists these design goals for C#:

C# is intended to be a simple, modern, general-purpose, object-oriented programming language.
Because software robustness, durability and programmer productivity are important, the language should include strong type checking, array bounds checking, detection of attempts to use uninitialized variables, source code portability, and automatic garbage collection.
The language is intended for use in developing software components that can take advantage of distributed environments.
Programmer portability is very important, especially for those programmers already familiar with C and C++.
Support for internationalization is very important.
C# is intended to be suitable for writing applications for both hosted and embedded systems, ranging from the very large that use sophisticated operating systems, down to the very small having dedicated functions.
Although C# applications are intended to be economical with regard to memory and processing power requirements, the language is not intended to compete directly on performance and size with C.


[edit] History
In 1996, Sun Microsystems released the Java programming language with Microsoft soon purchasing a license to implement it in their operating system. Java was originally meant to be a platform independent language, but Microsoft, in their implementation, broke their license agreement[2][3] and made a few changes that would essentially inhibit Java's platform-independent capabilities.[citation needed] Sun filed a lawsuit and Microsoft settled,[citation needed] deciding to create their own version of a partially compiled, partially interpreted object-oriented programming language with syntax closely related to that of C++.
During the development of .NET Framework, the class libraries were originally written in a language/compiler called Simple Managed C (SMC).[4][5][6] In January 1999, Anders Hejlsberg formed a team to build a new language at the time called Cool, which stood for "C like Object Oriented Language".[7] Microsoft had considered keeping the name "Cool" as the final name of the language, but chose not to do so for trademark reasons. By the time the .NET project was publicly announced at the July 2000 Professional Developers Conference, the language had been renamed C#, and the class libraries and ASP.NET runtime had been ported to C#.
C#'s principal designer and lead architect at Microsoft is Anders Hejlsberg, who was previously involved with the design of Turbo Pascal, Borland Delphi, and Visual J++. In interviews and technical papers he has stated that flaws in most major programming languages (e.g. C++, Java, Delphi, and Smalltalk) drove the fundamentals of the Common Language Runtime (CLR), which, in turn, drove the design of the C# programming language itself. Some argue that C# shares roots in other languages.[8]

[edit] Features

Note: The following description is based on the language standard and other documents listed in the external links section.

By design, C# is the programming language that most directly reflects the underlying Common Language Infrastructure (CLI). Most of its intrinsic types correspond to value-types implemented by the CLI framework. However, the language specification does not state the code generation requirements of the compiler: that is, it does not state that a C# compiler must target a Common Language Runtime, or generate Common Intermediate Language (CIL), or generate any other specific format. Theoretically, a C# compiler could generate machine code like traditional compilers of C++ or FORTRAN. However, in practice, all existing compiler implementations target CIL.
Some notable C# distinguishing features are:

There are no global variables or functions. All methods and members must be declared within classes. It is possible, however, to use static methods/variables within public classes instead of global variables/functions.
Local variables cannot shadow variables of the enclosing block, unlike C and C++. Variable shadowing is often considered confusing by C++ texts.
C# supports a strict Boolean datatype, bool. Statements that take conditions, such as while and if, require an expression of a boolean type. While C++ also has a boolean type, it can be freely converted to and from integers, and expressions such as if(a) require only that a is convertible to bool, allowing a to be an int, or a pointer. C# disallows this "integer meaning true or false" approach on the grounds that forcing programmers to use expressions that return exactly bool can prevent certain types of programming mistakes such as if (a = b) (use of = instead of ==).
In C#, memory address pointers can only be used within blocks specifically marked as unsafe, and programs with unsafe code need appropriate permissions to run. Most object access is done through safe object references, which are always either pointing to a valid, existing object, or have the well-defined null value; a reference to a garbage-collected object, or to random block of memory, is impossible to obtain. An unsafe pointer can point to an instance of a value-type, array, string, or a block of memory allocated on a stack. Code that is not marked as unsafe can still store and manipulate pointers through the System.IntPtr type, but cannot dereference them.
Managed memory cannot be explicitly freed, but is automatically garbage collected. Garbage collection addresses memory leaks. C# also provides direct support for deterministic finalization with the using statement (supporting the Resource Acquisition Is Initialization idiom).
Multiple inheritance is not supported, although a class can implement any number of interfaces. This was a design decision by the language's lead architect to avoid complication, avoid dependency hell and simplify architectural requirements throughout CLI.
C# is more typesafe than C++. The only implicit conversions by default are those which are considered safe, such as widening of integers and conversion from a derived type to a base type. This is enforced at compile-time, during JIT, and, in some cases, at runtime. There are no implicit conversions between booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default.
Enumeration members are placed in their own scope.
C# provides syntactic sugar for a common pattern of a pair of methods, accessor (getter) and mutator (setter) encapsulating operations on a single attribute of a class, in the form of properties.
Full type reflection and discovery is available.
C# currently (as of 3 June 2008) has 77 reserved words.


[edit] Common Type system (CTS)
C# has a unified type system. This unified type system is called Common Type System (CTS).[9]
A unified type system implies that all types, including primitives such as integers, are subclasses of the System.Object class. For example, every type inherits a ToString() method. For performance reasons, primitive types (and value types in general) are internally allocated on the stack.

[edit] Categories of datatypes
CTS separates datatypes into two categories[9]:

Value types
Reference types

Value types are plain aggregations of data. Instances of value types do not have referential identity nor a referential comparison semantics - equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have a default (parameterless) constructor. Examples of value types are some primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode codepoint), and System.DateTime (identifies a specific point in time with millisecond precision).
In contrast, reference types have the notion of referential identity - each instance of reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). In general, it is not always possible to create an instance of a reference type, nor to copy an existing instance, or perform a value comparison on two existing instances, though specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays).
Both type categories are extensible with user-defined types.

[edit] Boxing and unboxing
Boxing is the operation of converting a value of a value type into a value of a corresponding reference type.[9] Boxing in C# is implicit.
Example:


int foo = 42;         // Value type...
object bar = foo;     // foo is boxed to bar.

Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type.[9] Unboxing in C# requires an explicit type cast.
Example:


int foo = 42;         // Value type.
object bar = foo;     // foo is boxed to bar.
int foo2 = (int)bar;  // Unboxed back to value type.


[edit] Features of C# 2.0
New features in C# 2.0 (corresponding to the 3rd edition of the ECMA-334 standard and the .NET Framework 2.0) are:

[edit] Partial class
Partial classes allow implementation of a class to be spread between several files, with each file containing one or more class members. It is primarily useful when parts of a class are automatically generated. For example, the feature is heavily used by code-generating user interface designers in Visual Studio.
file1.cs:


public partial class MyClass
{
    public void MyMethod1()
    {
        // Manually written code
    }
}

file2.cs:


public partial class MyClass
{
    public void MyMethod2()
    {
        // Automatically generated code
    }
}


[edit] Generics
Generics, or parameterized types, or parametric polymorphism is a .NET 2.0 feature supported by C#. Unlike C++ templates, .NET parameterized types are instantiated at runtime rather than by the compiler; hence they can be cross-language whereas C++ templates cannot. They support some features not supported directly by C++ templates such as type constraints on generic parameters by use of interfaces. On the other hand, C# does not support non-type generic parameters. Unlike generics in Java, .NET generics use reification to make parameterized types first-class objects in the CLI Virtual Machine, which allows for optimizations and preservation of the type information.[10]

[edit] Static classes
Static classes are classes that cannot be instantiated or inherited from, and that only allow static members. Their purpose is similar to that of modules in many procedural languages.

[edit] A new form of iterator providing generator functionality
A new form of iterator that provides generator functionality, using a yield return construct similar to yield in Python.


// Method that takes an iterable input (possibly an array)
// and returns all even numbers.
public static IEnumerable<int> GetEven(IEnumerable<int> numbers)
{
    foreach (int i in numbers)
    {
        if (i % 2 == 0) yield return i;
    }
}


[edit] Anonymous delegates
Anonymous delegates provide closure functionality in C#.[11] Code inside the body of an anonymous delegate has full read/write access to local variables, method parameters, and class members in scope of the delegate, excepting out and ref parameters. For example:-


int SumOfArrayElements(int[] array)
{
    int sum = 0;
    Array.ForEach(
        array,
        delegate(int x)
        {
            sum += x;
        }
    );
    return sum;
}


[edit] Delegate covariance and contravariance
Conversions from method groups to delegate types are covariant and contravariant in return and parameter types, respectively. [12]

[edit] The accessibility of property accessors can be set independently
Example:


string status = string.Empty;
 
public string Status
{
    get { return status; }             // anyone can get value of this property,
    protected set { status = value; }  // but only derived classes can change it
}


[edit] Nullable types
Nullable value types (denoted by a question mark, e.g. int? i = null;) which add null to the set of allowed values for any value type. This provides improved interaction with SQL databases, which can have nullable columns of types corresponding to C# primitive types: an SQL INTEGER NULL column type directly translates to the C# int?.
Nullable types received an eleventh-hour improvement at the end of August 2005, mere weeks before the official launch, to improve their boxing characteristics: a nullable variable which is assigned null is not actually a null reference, but rather an instance of struct Nullable<T> with property HasValue equal to false. When boxed, the Nullable instance itself is boxed, and not the value stored in it, so the resulting reference would always be non-null, even for null values. The following code illustrates the corrected flaw:


int? i = null;
object o = i;
if (o == null)
    System.Console.WriteLine("Correct behaviour - runtime version from September 2005 or later");
else
    System.Console.WriteLine("Incorrect behaviour - pre-release runtime (from before September 2005)");

When copied into objects, the official release boxes values from Nullable instances, so null values and null references are considered equal. The late nature of this fix caused some controversy[13] , since it required core-CLR changes affecting not only .NET2, but all dependent technologies (including C#, VB, SQL Server 2005 and Visual Studio 2005).

[edit] Null-Coalesce operator
The ?? operator is called the null-coalescing operator and is used to define a default value for a nullable value types as well as reference types. It returns the left-hand operand if it is not null; otherwise it returns the right operand.[14]


object nullObj = null; 
object obj = new Object(); 
return nullObj ?? obj; // returns obj

The primary use of this operator is to assign a nullable type to a non-nullable type with an easy syntax:


int? i = null;
int j = i ?? 0; // If i is not null, initialize j to i. Else (if i is null), initialize j to 0.


[edit] Features of C# 3.0
C# 3.0 was released on 19 November 2007 as part of .NET Framework 3.5. It includes new features inspired by functional programming languages such as Haskell and ML, and is driven largely by the introduction of the Language Integrated Query (LINQ) pattern to the Common Language Runtime.[15] It is not currently standardized by any standards organisation.

[edit] LINQ (Language-Integrated Query)
LINQ is an extensible, general-purpose query language for many kinds of data sources (including plain object collections, XML documents, databases, and so on) which is tightly integrated with other C# language facilities. The syntax heavily borrows from SQL. An example:


int[] array = { 1, 5, 2, 10, 7 };
 
// Select squares of all odd numbers in the array sorted in descending order
IEnumerable<int> query = from x in array
                         where x % 2 == 1
                         orderby x descending
                         select x * x;
// Result: 49, 25, 1


[edit] Object initializers
Customer c = new Customer(); c.Name = "James";
can be written
Customer c = new Customer { Name="James" };

[edit] Collection initializers


MyList list = new MyList();
list.Add(1);
list.Add(2);

can be written as


MyList list = new MyList { 1, 2 };

assuming that MyList implements System.Collections.IEnumerable and has a public Add method[16]

[edit] Anonymous types
var x = new { FirstName="James", LastName="Frank" }; [17]

[edit] Local variable type inference
Local variable type inference:


var x = new Dictionary<string, List<float>>();

is interchangeable with


Dictionary<string, List<float>> x = new Dictionary<string, List<float>>();

This feature is not just a convenient syntactic sugar for shorter local variable declarations, but it is also required for the declaration of variables of anonymous types.

[edit] Lambda expressions
Lambda expressions provide a concise way to write first-class anonymous function values. Compare the following C# 2.0 snippet:


listOfFoo.Where(delegate(Foo x) { return x.Size > 10; })

with this C# 3.0 equivalent:


listOfFoo.Where(x => x.Size > 10);

In the above examples, lambda expressions are merely short-hand syntax for anonymous delegates with type inference for parameters and return type. However, depending on the context they are used in, a C# compiler can also transform lambdas into ASTs that can then be processed at run-time. In the example above, if listOfFoo is not a plain in-memory collection, but a wrapper around a database table, it could use this technique to translate the body of the lambda into the equivalent SQL expression for optimized execution. Either way, the lambda expression itself looks exactly the same in the code, so the way it is used at run-time is transparent to the client.

[edit] Automatic properties
The compiler will generate a private instance variable and the appropriate accessor and mutator given code such as: public string Name { get; private set; }

[edit] Extension methods
Extension methods are a form of syntactic sugar providing the illusion of adding new methods to the existing class outside its definition. In practice, an extension method is a static method that is callable as if it was an instance method; the receiver of the call is bound to the first parameter of the method, decorated with keyword this:


public static class StringExtensions
{
    public static string Left(this string s, int n)
    {
        return s.Substring(0, n);
    }
}
 
string s = "foo";
s.Left(3); // same as StringExtensions.Left(s, 3);


[edit] Partial methods
Partial methods allow code generators to generate method declarations as extension points that are only included in the source code compilation if someone actually implements it in another portion of a partial class.[18]

[edit] Features of C# 4.0





This article or section contains information about scheduled or expected future software.
The content may change as the software release approaches and more information becomes available.





The next version of the language, C# 4.0, is under development as of October 2008. Microsoft has announced a list of new language features in C# 4.0 on Microsoft Professional Developers Conference 2008. The major focus of the next version is interoperability with partially or fully dynamically typed languages and frameworks, such as the Dynamic Language Runtime and COM. The following new features were announced:[19]

[edit] Dynamic member lookup
A new pseudo-type dynamic is introduced into the C# type system. It is treated as System.Object, but in addition, any member access (method call, field, property, or indexer access, or a delegate invocation) or application of an operator on a value of such type is permitted without any type checking, and its resolution is postponed until run-time. For example:


  // Returns the value of Length property or field of any object
  int GetLength(dynamic obj)
  {
    return obj.Length;
  }
 
  GetLength("Hello, world");        // a string has a Length property,
  GetLength(new int[] { 1, 2, 3 }); // and so does an array,
  GetLength(42);                    // but not an integer - an exception will be thrown here at run-time

Dynamic method calls are triggered by a value of type "dynamic" as any implicit or explicit parameter (and not just a receiver). For example:


  void Print(dynamic obj)
  {
     System.Console.WriteLine(obj); // which overload of WriteLine() to call is decided at run-time
  }
 
  Print(123);   // ends up calling WriteLine(int)
  Print("abc"); // ends up calling WriteLine(string)

Dynamic lookup is performed using three distinct mechanisms: COM IDispatch for COM objects, IDynamicObject DLR interface for objects implementing that interface, and Reflection for all other objects. Any C# class can therefore intercept dynamic calls on its instances by implementing IDynamicObject.
In case of dynamic method and indexer calls, overload resolution happens at run-time according to the actual types of the values passed as arguments, but otherwise according to the usual C# overloading resolution rules. Furthermore, in cases where the receiver in a dynamic call is not itself dynamic, run-time overload resolution will only consider the methods that are exposed on the declared compile-time type of the receiver. For example:


class Base
{
  void Foo(double x);
}
 
class Derived : Base
{
  void Foo(int x);
}
 
dynamic x = 123;
Base b = new Derived();
b.Foo(x); // picks Base.Foo(double) because b is of type Base, and Derived.Foo(int) is not exposed
dynamic b1 = b;
b1.Foo(x); // picks Derived.Foo(int)

Any value returned from a dynamic member access is itself of type dynamic. Values of type dynamic are implicitly convertible both from and to any other type. In the code sample above, this permits GetLength function to treat the value returned by a call to Length as an integer without any explicit cast. At run-time, the actual value will be converted to the requested type.

[edit] Covariant and contravariant generic type parameters
Generic interfaces and delegates can have their type parameters marked as covariant or contravariant, using keywords out and in, respectively. These declarations are then respected for type conversions, both implicit and explicit, and both compile-time and run-time. For example, the existing interface IEnumerable<T> has been redefined as follows:


interface IEnumerable<out T>
{
  IEnumerator<T> GetEnumerator();
}

Therefore, any class that implements IEnumerable<Derived> for some class Derived is also considered to be compatible with IEnumerable<Base> for all classes and interfaces Base that Derived extends, directly, or indirectly. In practice, it makes it possible to write code such as:


void PrintAll(IEnumerable<object> objects)
{
  foreach (object o in objects)
  {
    System.Console.WriteLine(o);
  }
}
 
IEnumerable<string> strings = new List<string>();
PrintAll(strings); // IEnumerable<string> is implicitly converted to IEnumerable<object>

For contravariance, the existing interface IComparer<T> has been redefined as follows:


public interface IComparer<in T>
{
    int Compare(T x, T y);
}

Therefore, any class that implements IComparer<Base> for some class Base is also considered to be compatible with IComparer<Derived> for all classes and interfaces Derived that are extended from Base. It makes it possible to write code such as:


IComparer<object> objectComparer = GetComparer();
IComparer<string> stringComparer = objectComparer;


[edit] Optional ref Keyword when using COM
The ref keyword for callers of methods is now optional when calling into methods supplied by COM interfaces. Given a COM method with the signature


void Increment(ref int x);

the invocation can now be written as either


Increment(0); // no need for "ref" or a place holder variable any more

or


int x = 0;
Increment(ref x);


[edit] Optional parameters and named arguments
C# 4.0 introduces optional parameters with default values as seen in C++. For example:


void Increment(ref int x, int dx = 1)
{
  x += dx;
}
 
int x = 0;
Increment(ref x);    // dx takes the default value of 1
Increment(ref x, 2); // dx takes the value 2

In addition, to complement optional parameters, it is possible to explicitly specify parameter names in method calls, allowing to selectively pass any given subset of optional parameters for a method. The only restriction is that named parameters must be placed after the unnamed parameters. Parameter names can be specified for both optional and required parameters, and can be used to improve readability or arbitrarily reorder arguments in a call. For example:


Stream OpenFile(string name, FileMode mode = FileMode.Open, FileAccess access = FileAccess.Read) { ... }
 
OpenFile("file.txt"); // use default values for both "mode" and "access" 
OpenFile("file.txt", mode: FileMode.Create); // use default value for "access"
OpenFile("file.txt", access: FileAccess.Read); // use default value for "mode"
OpenFile(name: "file.txt", access: FileAccess.Read, mode: FileMode.Create); // name all parameters for extra readability, 
                                                                            // and use order different from method declaration

Optional parameters make interoperating with COM easier. Previously, C# had to pass in every parameter in the method of the COM component, even those that are optional. For example:


object fileName = "Test.docx";
object missing = System.Reflection.Missing.Value;
 
doc.SaveAs(ref fileName,
    ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing);

With support for optional parameters, the code can be shortened as


doc.SaveAs(ref fileName);


[edit] Indexed properties
Indexed properties (and default properties) of COM objects are now recognised, but C# objects still do not support them.


[edit] Preprocessor
C# features "preprocessor directives"[20] (though it does not have an actual preprocessor) based on the C preprocessor that allow programmers to define symbols but not macros. Conditionals such as #if, #endif, and #else are also provided. Directives such as #region give hints to editors for code folding.

[edit] Code comments
C# utilizes a double forward slash (//) to indicate the rest of the line is a comment.


public class Foo
{
    // a comment
    public static void Bar(int firstParam) {}  //Also a comment
}

Multi-line comments can be indicated by a starting forward slash/asterisk (/*) and ending asterisk/forward slash (*/).


public class Foo
{
    /* A Multi-Line
       comment  */
    public static void Bar(int firstParam) {}  
}


[edit] XML documentation system
C#'s documentation system is similar to Java's Javadoc, but based on XML. Two methods of documentation are currently supported by the C# compiler.
Single-line comments, such as those commonly found in Visual Studio generated code, are indicated on a line beginning with ///.


public class Foo
{
    /// <summary>A summary of the method.</summary>
    /// <param name="firstParam">A description of the parameter.</param>
    /// <remarks>Remarks about the method.</remarks>
    public static void Bar(int firstParam) {}
}

Multi-line comments, while defined in the version 1.0 language specification, were not supported until the .NET 1.1 release.[21] These comments are designated by a starting forward slash/asterisk/asterisk (/**) and ending asterisk/forward slash (*/)[22].


public class Foo
{
    /** <summary>A summary of the method.</summary>
     *  <param name="firstParam">A description of the parameter.</param>
     *  <remarks>Remarks about the method.</remarks> */
    public static void Bar(int firstParam) {}
}

Note there are some stringent criteria regarding white space and XML documentation when using the forward slash/asterisk/asterisk (/**) technique.
This code block:


/**
 * <summary>
 * A summary of the method.</summary>*/

produces a different XML comment than this code block[22]:


/**
 * <summary>
   A summary of the method.</summary>*/

Syntax for documentation comments and their XML markup is defined in a non-normative annex of the ECMA C# standard. The same standard also defines rules for processing of such comments, and their transformation to a plain XML document with precise rules for mapping of CLI identifiers to their related documentation elements. This allows any C# IDE or other development tool to find documentation for any symbol in the code in a certain well-defined way.

[edit] Libraries
The C# specification details a minimum set of types and class libraries that the compiler expects to have available. In practice, C# is most often used with some implementation of the Common Language Infrastructure (CLI), which is standardized as ECMA-335 Common Language Infrastructure (CLI).

[edit] "Hello, world" example
The following is a very simple C# program, a version of the classic "Hello world" example:


class ExampleClass
{
    static void Main()
    {
        System.Console.WriteLine("Hello, world!");
    }
}

The effect is to write the following text to the output console:

Hello, world!

Each line has a purpose:


class ExampleClass

Above is a class definition. Everything between the following pair of braces describes ExampleClass.


static void Main()

This declares the class member method where the program begins execution. The .NET runtime calls the Main method. (Note: Main may also be called from elsewhere, e.g. from the code Main() in another method of ExampleClass.) The static keyword makes the method accessible without an instance of ExampleClass. Each console application's Main entry point must be declared static. Otherwise, the program would require an instance, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like above) report an error if there is no static Main method. The void keyword declares that Main has no return value (see also side effect).


System.Console.WriteLine("Hello, world!");

This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input, output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string "Hello, world!".

[edit] Standardization
In August, 2000, Microsoft Corporation, Hewlett-Packard and Intel Corporation co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization ECMA International. In December 2001 , ECMA released ECMA-334 C# Language Specification. C# became an ISO standard in 2003 (ISO/IEC 23270:2006 - Information technology -- Programming languages -- C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December, 2002.
In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (similar to C++ templates).
In July 2005, ECMA submitted the standards and related TRs to ISO/IEC JTC 1 via the latter's Fast-Track process. This process usually takes 6-9 months.

[edit] Criticism
Although the C# language definition and the CLI are standardized under ISO and ECMA standards, the CLI is only a part of Microsoft's Base Class Library (BCL), which also contains non-standardized classes that are used by many C# programs (some extended IO, User Interface, Web services, etc). Furthermore, parts of the BCL have been patented by Microsoft,[23][24] which may deter independent implementations of the full framework, as only the standardized portions have RAND protection from patent claims.

[edit] Implementations
The most commonly used C# compiler is Microsoft Visual C#.
C# compilers are also provided with:

Microsoft's Rotor project (currently called Shared Source Common Language Infrastructure) (licensed for educational and research use only) provides a shared source implementation of the CLR runtime and a C# compiler, and a subset of the required Common Language Infrastructure framework libraries in the ECMA specification.


The Mono project provides an open source C# compiler, a complete open source implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and a nearly complete implementation of the Microsoft proprietary .NET class libraries up to .NET 2.0, but not specific .NET 3.0 and .NET 3.5 libraries, as of Mono 2.0.


The DotGNU project also provides an open source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification but included in Microsoft's standard .NET Framework distribution).


DotNetAnywhere [3] - Micro Framework-like Common Language Runtime, aimed on embedded systems, supports almost all C# 2.0 specifications.


[edit] Language name




C sharp typographical convention






C sharp musical note


The name "C sharp" was inspired from musical notation where a sharp indicates that the written note should be made a half-step higher in pitch.[25] This is similar to the language name of C++, where the two "+" symbols indicate that a variable should be incremented by 1. The Sharp symbol also resembles a ligature of four "+" symbols (arranged in a two-by-two grid), furthermore implying that the language is an increment of C++.
Due to technical limitations of display (fonts, browsers, etc.) and the fact that the sharp symbol (♯, U+266F, MUSIC SHARP SIGN) is not present on the standard keyboard, the number sign (#, U+0023, NUMBER SIGN) was chosen to represent the sharp symbol in the written name of the programming language.[26] This convention is reflected in the ECMA-334 C# Language Specification.[27] However, when it is practical to do so (for example, in advertising or in box art[28]), Microsoft will use the intended musical sharp symbol.
The "sharp" suffix has been used by a number of other .NET languages that are variants of existing languages, including J# (a .NET language also designed by Microsoft which is derived from Java 1.1), A# (from Ada), and the functional F#.[29] The original implementation of Eiffel for .NET was called Eiffel#,[30] a name since retired since the full Eiffel language is now supported. The suffix is also sometimes used for libraries, such as Gtk# (a .NET wrapper for GTK+ and other GNOME libraries), Cocoa# (a wrapper for Cocoa) and Qt# (a .NET language binding for the Qt toolkit).

[edit] See also

C# Syntax


[edit] Environments and tools

Microsoft Visual Studio, IDE for C#
SharpDevelop, an open-source C# IDE for Windows
MonoDevelop, an open-source C# IDE for Linux
QuickSharp 2008, a simplified development environment for C#
Morfik C#, a C# to JavaScript compiler complete with IDE and framework for Web application development.
Baltie, an educational IDE for children and students with little or no programming experience
Borland Turbo C Sharp


[edit] Related languages

Cω
Spec#
Sing#
Parallel C#


[edit] Comparisons

Alphabetical list of programming languages
Comparison of programming languages


[edit] Notes


^ In Java 5.0, several features (foreach, autoboxing, varargs, annotations and enums) were introduced, after proving themselves useful in the C# language (with only minor differences in name and implementation). [1][2]
^ "Court curbs Microsoft Java distribution - CNET News". http://news.cnet.com/2100-1007_3-1021452.html. Retrieved on 2009-03-17. 
^ "Java Lawsuit: Judge Says Microsoft Infringed On Copyright - IT Channel News". http://www.crn.com/it-channel/18805270. Retrieved on 2009-03-17. 
^ "Jason Zander on the history of .NET". http://blogs.msdn.com/jasonz/archive/2007/11/23/couple-of-historical-facts.aspx. Retrieved on 2008-02-21. 
^ "C# 3.0 New Features". http://www.learnitonweb.com/Articles/ReadArticle.aspx?contId=4&page=1. Retrieved on 2008-06-08. 
^ "Scott Guthrie on the origins of ASP.Net". http://aspadvice.com/blogs/rbirkby/commentrss.aspx?PostID=24972. Retrieved on 2008-02-21. 
^ Naomi Hamilton EDIT MODE: (October 1, 2008). "The A-Z of Programming Languages: C#". http://www.computerworld.com.au/index.php/id;1149786074;fp;;fpid;;pf;1. Retrieved on 2008-10-01. 
^ "Programming language history chart". http://www.levenez.com/lang/history.html. 
^ a b c d Archer, Part 2, Chapter 4:The Type System
^ An Introduction to C# Generics
^ Anonymous Methods (C#)
^ Covariance and Contravariance in Delegates (C#)
^ Somasegar (August 11, 2005). "Nulls not missing anymore". Somasegar's WebLog. MSDN. http://blogs.msdn.com/somasegar/archive/2005/08/11/450640.aspx. Retrieved on 2008-11-05. 
^ "?? Operator (C# Reference)". Microsoft. http://msdn.microsoft.com/en-us/library/ms173224.aspx. Retrieved on 2008-11-23. 
^ Tim Anderson (November 14, 2006). "C# pulling ahead of Java - Lead architect paints rosy C# picture". Reg Developer. The Register. http://www.regdeveloper.co.uk/2006/11/14/c-sharp_hejlsberg/. Retrieved on 2007-01-20. 
^ The Mellow Musings of Dr. T : What is a collection?
^ Anonymous Types (C# Programming Guide)
^ "Partial Methods". http://blogs.msdn.com/vbteam/archive/2007/03/27/partial-methods.aspx. Retrieved on 2007-10-06. 
^ Mads Torgersen. "New features in C# 4.0". http://code.msdn.microsoft.com/csharpfuture/Release/ProjectReleases.aspx?ReleaseId=1686. Retrieved on 2008-10-28. 
^ C# Preprocessor Directives
^ Anson Horton (2007-09-11). "C# XML documentation comments FAQ". http://blogs.msdn.com/ansonh/archive/2006/09/11/750056.aspx. Retrieved on 2007-12-11. 
^ a b http://msdn2.microsoft.com/en-us/library/5fz4y783(VS.71).aspx Delimiters for Documentation Tags
^ See .NET Framework
^ See Mono and Microsoft’s patents
^ "C#/.NET History Lesson". 2008-03-25. http://www.jameskovacs.com/blog/CNETHistoryLesson.aspx. 
^ "Microsoft C# FAQ". http://msdn.microsoft.com/vcsharp/previous/2002/FAQ/default.aspx. Retrieved on 2008-03-25. 
^ Standard ECMA-334 C# Language Specification. 4th edition (June 2006).
^ Microsoft.com
^ "Microsoft F# FAQ". http://research.microsoft.com/fsharp/faq.aspx. 
^ http://msdn.microsoft.com/en-us/library/ms973898.aspx



[edit] References

Archer, Tom (2001). Inside C#. Microsoft Press. ISBN 0-7356-1288-9. 
C# Language Pocket Reference. O' Reilly. 2002. ISBN 0-596-00429-X. 
Petzold, Charles (2002). Programming Microsoft Windows with C#. Microsoft Press. ISBN 0-7356-1370-2. 


[edit] External links





This article's external links may not follow Wikipedia's content policies or guidelines. Please improve this article by removing excessive or inappropriate external links.





Wikibooks has a book on the topic of
C Sharp Programming




C# Language (MSDN)
C# Programming Guide (MSDN)
C# Specification (MSDN)
ECMA-334 C# Language Specification - hyperlinked
ECMA-334 C# Language SpecificationPDF (5.59 MB)
ISO C# Language Specification - Purchase version or free version.
Microsoft Visual C# .NET








v • d • e

.NET Framework





Architecture

Base Class Library · Common Language Runtime · Code Access Security · Assembly · Metadata · COM Interop






Common Language
Infrastructure (CLI)

Common Language Infrastructure · Common Type System · Common Intermediate Language · Virtual Execution System






CLI Languages





Common1


C# · Visual Basic .NET · C++/CLI (Managed) · F#  · J#  · JScript .NET · Windows PowerShell







Other2


A# · Boo · M · Oxygene  · IronLisp · IronPython · IronRuby · IronScheme · Nemerle · Phalanger · P#









Components

ADO.NET (Entity Framework · Data Services) · ASP.NET (AJAX · MVC · Dynamic Data) · Language Integrated Query · CardSpace · ClickOnce · Communication Foundation · Dynamic Language Runtime · Forms · Presentation Foundation · Remoting · Workflow Foundation  · XAML






Other implementations

Mono · Compact Framework · XNA Framework · Micro Framework · Portable.NET · Silverlight · SSCLI






Comparisons

Java and C# · C# and Visual Basic .NET · Java and .NET platforms






Upcoming

"Acropolis" · "Jasper" · Parallel Extensions






1 Languages that are, will be, or have been included with Visual Studio or Microsoft Windows.
2 Non-academic or research languages with relatively large user-bases.












v • d • e

Standards of Ecma International






ANSI escape code · C++/CLI · C# · CD-ROM · CLI · DDS · E4X · ECMAScript · Eiffel · FAT · FD · HVD · Office Open XML · U3D · UDF · UDO · UMD · UWB






List of Ecma standards








Retrieved from "http://en.wikipedia.org/wiki/C_Sharp_(programming_language)"
Categories: Upcoming software | .NET programming languages | C programming language family | Class-based programming languages | Curly bracket programming languages | C sharp programming language family | Mono project | Object-oriented programming languages | Statically-typed programming languages | ISO standards | IEC standards | Ecma standardsHidden categories: Wikipedia articles needing copy edit from August 2008 | All articles needing copy edit | All articles with unsourced statements | Articles with unsourced statements since February 2009 | Wikipedia external links cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


العربية
Azərbaycan
বাংলা
Bosanski
Български
Català
Česky
Dansk
Deutsch
Español
Esperanto
Euskara
فارسی
Français
Galego
한국어
Hrvatski
Bahasa Indonesia
Íslenska
Italiano
עברית
Lietuvių
Magyar
മലയാളം
Bahasa Melayu
Nederlands
नेपाल भाषा
日本語
‪Norsk (bokmål)‬
O'zbek
Plattdüütsch
Polski
Português
Română
Русский
Simple English
Slovenčina
Српски / Srpski
Srpskohrvatski / Српскохрватски
Suomi
Svenska
ไทย
Tiếng Việt
Тоҷикӣ
Türkçe
Українська
中文









 This page was last modified on 6 April 2009, at 11:21.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
