













Threaded code - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Threaded_code";
		var wgTitle = "Threaded code";
		var wgAction = "view";
		var wgArticleId = "47767";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 280123277;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
<!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Threaded code

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
Not to be confused with multi-threaded programming.
In computer science, the term threaded code refers to a compiler implementation technique where the generated code has a form that essentially consists entirely of calls to subroutines. The code may be processed by an interpreter, or may simply be a sequence of machine code call instructions.
One of the main advantages of threaded code is that it is very compact, compared to code generated by alternative code generation techniques and alternative calling conventions. This advantage usually comes at the expense of slightly slower execution speed (usually just a single machine instruction) . However, sometimes there is a synergistic effect—sometimes more compact code is smaller and significantly faster than non-threaded code.[1] A program small enough to fit entirely in random-access memory may run faster than a less-compact program in swap space that requires constant mechanical disk drive access, even though it suffers the threaded code interpretation overhead. Similarly, a program small enough to fit entirely in a computer processor's cache may run faster than a less-compact program that suffers constant cache misses.
Threaded code is most well known as the implementation technique commonly used in the Forth programming language. It was also used in early versions of the B programming language, as well as many implementations of BASIC, and some implementations of COBOL and other languages for small minicomputers.




Contents


1 History leading to threaded code
2 Development of Threaded Code
3 Threading models

3.1 Direct threading
3.2 Indirect threading
3.3 Subroutine threading
3.4 Token threading
3.5 Huffman threading
3.6 Lesser used threading


4 Branches
5 Common amenities
6 See also
7 References
8 Further reading





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] History leading to threaded code
The common way to make computer programs is to 'translate' a computer program written in some symbolic language to machine code using a compiler. The code is typically fast but nonportable since the binary code is designed for a specific hardware platform. A different approach uses a virtual machine instruction set - that has no particular target hardware. An interpreter executes it on each new target hardware.
Early computers had relatively little memory. For example, most Data General Nova, IBM 1130, and many Apple II computers had only 4 K words of RAM installed. Consequently a lot of time was spent trying to find ways to reduce the size of programs so they would fit in the memory available. At the same time, computers were relatively slow, so simple interpretation was very noticeably slower than executing machine code.
Instead of writing out every step of an operation in every part of the program where it was needed, programmers saved memory by writing each step of such operations once (see "Don't repeat yourself") and placing it in a subroutine.
This process — code refactoring — is used today, although for different reasons. The top-level application in these programs may consist of nothing but subroutine calls. Many of these subroutines, in turn, also consist of nothing but lower level subroutine calls.
Mainframes and some early microprocessors such as the RCA 1802 required several instructions to call a subroutine. In the top-level application and in many subroutines, that sequence is constantly repeated, only the subroutine address changing from one call to the next. Using memory to store the same instructions repeatedly is wasteful.
The simple answer was a branch table (i.e. a table consisting of just contiguous addresses of the sub-routines - usually extracted using an index, general purpose register or pointer). The addresses may be direct or indirect, contiguous or non-contiguous (linked by pointers), relative or absolute, resolved at compile time or dynamically built - but the program becomes a list of entry points to the actual code to be executed. This technique has been "re-invented" as "threaded code" , Dispatch tables or Virtual method tables - all these techniques fill similar purposes.

[edit] Development of Threaded Code
To save space, programmers squeezed the lists of subroutine calls into simple lists of subroutine addresses, and used a small loop to call each subroutine in turn. For example:

start:             thread:         pushA:  *sp++ = A
  tp = &thread       &pushA                jump top
top:                 &pushB        pushB:  *sp++ = B
  jump *tp++         &add                  jump top
                     ...           add:    *sp++ = *--sp + *--sp
                                           jump top

In this case, decoding the bytecodes is performed once, during program compilation or program load, so it not repeated each time an instruction is executed. This can save much time and space when decode and dispatch overhead is large compared to the execution cost.
Note, however, addresses in thread for &pushA, &pushB, etc., are two or more bytes, compared to one byte, typically, for the decode and dispatch interpreter described above. In general, instructions for a decode and dispatch interpreter may be any size. As example, a decode and dispatch interpreter to simulate an Intel Pentium decodes instructions that range from 1 to 16 bytes. However, bytecoded systems typically choose 1-byte codes for the most-common operations. Thus, the thread often has a higher space cost than bytecodes. In most uses, the reduction in decode cost outweighs the increase in space cost.
Note also that while bytecodes are nominally machine-independent, the format and value of the pointers in threads generally depend on the target machine which is executing the interpreter. Thus, an interpreter might load a portable bytecode program, decode the bytecodes to generate platform-dependent threaded code, then execute threaded code without further reference to the bytecodes.
The loop is simple, so is duplicated in each handler, removing jump top from the list of machine instructions needed to execute each interpreter instruction. As example:

start:             thread:         pushA:  *sp++ = A
  tp = thread        &pushA                jump *tp++
  jump *tp++         &pushB        pushB:  *sp++ = B
                     &add                  jump *tp++
                     ...           add:    *sp++ = *--sp + *--sp
                                           jump *tp++

This is called direct threaded code (DTC). Although the technique is older, the first widely circulated use of the term "threaded code" is probably Bell's article "Threaded Code" from 1973.[2]
Charles H. Moore invented a more compact notation in 1970 for his Forth virtual machine: indirect threaded code (ITC). Originally, Moore invented this because it was easy and fast on NOVA minicomputers, which have an indirection bit in every address. He said (in published remarks, Byte Magazine's Forth Issue) that he found it so convenient that he propagated it into all later Forth designs.
Some Forth compilers compile Forth programs into direct-threaded code, while others make indirect-threaded code. The programs act the same either way.

[edit] Threading models
Practically all executable threaded code uses one or another of these methods for invoking subroutines (each method is called a "threading model").

[edit] Direct threading
Addresses in the thread are the addresses of machine language. This form is simple, but may have overheads because the thread consists only of machine addresses, so all further parameters must be loaded indirectly from memory. Some Forth systems produce direct-threaded code. On many machines direct-threading is faster than subroutine threading (see reference below).
As example, a stack machine might execute the sequence "push A, push B, add". That might be translated to the following thread and routines, where tp is initialized to the address &thread.

thread:      pushA: *sp++ = A          pushB: *sp++ = B         add:  *sp++ = *--sp + *--sp
  &pushA            jump *tp++                jump *tp++              jump *tp++
  &pushB
  &add
  ...

Alternatively, operands may be included in the thread. This can remove some indirection needed above, but makes the thread larger:

thread:      push: *sp++ = *tp++      add: *sp++ = *--sp + *--sp
  &push            jump *tp++              jump *tp++
  &A
  &push
  &B
  &add


[edit] Indirect threading
Indirect threading uses pointers to locations that in turn point to machine code. The indirect pointer may be followed by operands which are stored in the indirect "block" rather than storing them repeatedly in the thread. Thus, indirect code is often more compact than direct-threaded code, but the indirection also typically makes it slower, though still usually faster than bytecode interpreters. Where the handler operands include both values and types, the space savings over direct-threaded code may be significant. Older FORTH systems typically produce indirect-threaded code.
As example, if the goal is to execute "push A, push B, add", the following might be used. Here, tp is initialized to address &thread, each code fragment (push, add) is found by double-indirecting through tp; and operands to each code fragment are found in the first-level indirection following the address of the fragment.

thread:      i_pushA:   push:                   add:
  &i_pushA     &push      *sp++ = *(*tp + 1)      *sp++ = *--sp + *--sp
  &i_pushB     &A         jump *(*tp++)           jump *(*tp++)
  &i_add     i_pushB:
               &push
               &B
             i_add:
               &add


[edit] Subroutine threading
So-called "subroutine-threaded code" (also "call-threaded code") consists of a series of machine-language "call" instructions (or addresses of functions to "call", as opposed to direct threading's use of "jump"). Early compilers for ALGOL, Fortran, Cobol and some Forth systems often produced subroutine-threaded code. The code in many of these systems operated on a last-in-first-out (LIFO) stack of operands, which had well-developed compiler theory. Most modern processors have special hardware support for subroutine "call" and "return" instructions, so the overhead of one extra machine instruction per dispatch is somewhat diminished; but according to measurements by Anton Ertl, "in contrast to popular myths, subroutine threading is usually slower than direct threading."[3] Ertl's most recent tests show that direct threading is the fastest threading model on Xeon, Opteron, and Athlon processors; indirect threading is the fastest threading model on Pentium M processors; and subroutine threading is the fastest threading model on Pentium 4, Pentium III, and PPC processors.
As an example of call threading "push A, push B, add":

thread:           pushA:            pushB:         add:
  call pushA        *sp++ = A         *sp++ = B      *sp++ = *--sp + *--sp
  call pushB        ret               ret            ret
  call add


[edit] Token threading
Token threaded code uses lists of 8 or 12-bit indexes to a table of pointers. Token threaded code is notably compact, without much special effort by a programmer. It is usually half to three-fourths the size of other threaded-codes, which are themselves a quarter to an eighth the size of compiled code. The table's pointers can either be indirect or direct. Some Forth compilers produce token threaded code. Some programmers consider the "p-code" generated by some Pascal compilers, as well as the byte codes used by .NET, Java, Basic and some C compilers to be token-threading.
A common approach historically is bytecode, which uses 8-bit opcodes and, often, a stack-based virtual machine. A typical interpreter is known as a "decode and dispatch interpreter", and follows the form

bytecode:         top:                   pushA:         pushB:          add:
  0 /*pushA*/       i = decode(vpc++)      *sp++ = A      *sp++ = B       *sp++ = *--sp + *--sp
  1 /*pushB*/       addr = table[i]        jump top       jump top        jump top
  2 /*add*/         jump *addr

If the virtual machine uses only byte-size instructions, decode() is simply a fetch from bytecode, but often there are commonly-used 1-byte instructions plus some less-common multibyte instructions, in which case decode() is more complex. The decoding of single byte opcodes can be very simply and efficiently handled by a branch table using the opcode directly as an index.
For instructions where the individual operations are simple, such as "push" and "add", the overhead involved in deciding what to execute is larger than the cost of actually executing it, such interpreters are often much slower than machine code. However for more complex ("compound") instructions, the overhead percentage is proportionally less significant.


[edit] Huffman threading
Huffman threaded code consists of lists of Huffman codes. A Huffman code is a variable length bit string used to identify a unique item. A Huffman-threaded interpreter locates subroutines using an index table or tree of pointers that can be navigated by the Huffman code. Huffman threaded code is one of the most compact representations known for a computer program. Basically the index and codes are organized by measuring the frequency that each subroutine occurs in the code. Frequent calls are given the shortest codes. Operations with approximately equal frequencies are given codes with nearly equal bit-lengths. Most Huffman-threaded systems have been implemented as direct-threaded Forth systems, and used to pack large amounts of slow-running code into small, cheap microcontrollers. Most published uses have been in toys, calculators or watches.

[edit] Lesser used threading

String threading, where operations are identified by strings, usually looked-up by a hash table. This was used in Charles H. Moore's earliest Forth implementations and in the University of Illinois's experimental hardware-interpreted computer language. It is also used in Bashforth.


[edit] Branches
Examples above show no branches. For all interpreters, a branch changes the thread pointer (tp above). As example, a conditional branch when the top-of-stack value is zero might be encoded as follows. Note that &thread[123] is the location to jump to, not the address of a handler, and so must be skipped (tp++) whether or not the branch is taken.

thread:              brz:
  ...                  tmp = *tp++
  &brz                 if (*sp++ == 0)
  &thread[123]           tp = tmp
  ...                  jump *tp++


[edit] Common amenities
Separating the data and return stacks in a machine eliminates a great deal of stack management code, substantially reducing the size of the threaded code. The dual-stack principle was originated three times independently: for Burroughs large systems, Forth and PostScript, and is used in some Java virtual machines.
Three registers are often present in a threaded virtual machine. Another one exists for passing data between subroutines ('words'). These are:

ip or i (instruction pointer); examples above call it tp
w (work pointer)
rp or r (return stack pointer)
sp or s (parameter stack pointer for passing parameters between words)

Often, threaded virtual machines such as implementations of Forth have a simple virtual machine at heart, consisting of three primitives. Those are:

nest, also called docol
unnest, or semi_s (;s)
next

In an indirect-threaded virtual machine, the one given here, the operations are:

next:   (ip)+ ->   w    ;  jmp (w)+
nest:    ip   -> -(rp)  ;  w -> ip  ;  next
unnest: (rp)+ ->   ip   ;  next

This is perhaps the simplest and fastest interpreter or virtual machine.

[edit] See also

Continuation-passing style, which replaces the global variable tp with a function parameter
Tail recursion
Just-in-time compilation
Branch table


[edit] References


^ Speed of various interpreter dispatch techniques V2
^ James R. Bell, "Threaded Code", CACM, 1973, 16, 6, pp 370–372
^ "What is Threaded Code?" by Anton Ertl



[edit] Further reading

Anton Ertl's explanatory page What is Threaded Code? describes different threading techniques and provides further references.
The Development of the C Language by Dennis M. Ritchie describes B (a precursor of C) as implemented using "threaded code".
Thinking Forth Project includes the seminal (but out of print) book Thinking Forth by Leo Brodie published in 1984.
Starting FORTH online verion of the book Starting FORTH by Leo Brodie published in 1981.
Brad Rodriguez's Moving FORTH: Part 1: Design Decisions in the Forth Kernel covers threading techniques in depth.
history of general purpose CPUs
GCC extensions. Labels as Values




Retrieved from "http://en.wikipedia.org/wiki/Threaded_code"
Categories: Compilers | Programming language implementation 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Русский









 This page was last modified on 28 March 2009, at 01:04 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
