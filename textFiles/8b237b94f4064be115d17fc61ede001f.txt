













Java syntax - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Java_syntax";
		var wgTitle = "Java syntax";
		var wgAction = "view";
		var wgArticleId = "1079500";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 285684208;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java5 .de1, .source-java5 .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java5  {}
.source-java5 .head {}
.source-java5 .foot {}
.source-java5 .imp {font-weight: bold; color: red;}
.source-java5 .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java5 li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java5 li.li2 {font-weight: bold;}
.source-java5 .kw1 {color: #b1b100;}
.source-java5 .kw2 {color: #000000; font-weight: bold;}
.source-java5 .kw3 {color: #993333;}
.source-java5 .kw4 {color: #b13366;}
.source-java5 .kw5 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw6 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw7 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw8 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw9 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw10 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw11 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw12 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw13 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw14 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw15 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw16 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw17 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw18 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw19 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw20 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw21 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw22 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw23 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw24 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw25 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw26 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw27 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw28 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw29 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw30 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw31 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw32 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw33 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw34 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw35 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw36 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw37 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw38 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw39 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw40 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw41 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw42 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw43 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw44 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw45 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw46 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw47 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw48 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw49 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw50 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw51 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw52 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw53 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw54 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw55 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw56 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw57 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw58 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw59 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw60 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw61 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw62 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw63 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw64 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw65 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw66 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw67 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw68 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw69 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw70 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw71 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw72 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw73 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw74 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw75 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw76 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw77 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw78 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw79 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw80 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw81 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw82 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw83 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw84 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw85 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw86 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw87 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw88 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw89 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw90 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw91 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw92 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw93 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw94 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw95 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw96 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw97 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw98 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw99 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw100 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw101 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw102 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw103 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw104 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw105 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw106 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw107 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw108 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw109 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw110 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw111 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw112 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw113 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw114 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw115 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw116 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw117 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw118 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw119 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw120 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw121 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw122 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw123 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw124 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw125 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw126 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw127 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw128 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw129 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw130 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw131 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw132 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw133 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw134 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw135 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw136 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw137 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw138 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw139 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw140 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw141 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw142 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw143 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw144 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw145 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw146 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw147 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw148 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw149 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw150 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw151 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw152 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw153 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw154 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw155 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw156 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw157 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw158 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw159 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw160 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw161 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw162 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw163 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw164 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw165 {color: #aaaadd; font-weight: bold;}
.source-java5 .kw166 {color: #aaaadd; font-weight: bold;}
.source-java5 .co1 {color: #808080; font-style: italic;}
.source-java5 .coMULTI {color: #808080; font-style: italic;}
.source-java5 .es0 {color: #000099; font-weight: bold;}
.source-java5 .br0 {color: #66cc66;}
.source-java5 .st0 {color: #ff0000;}
.source-java5 .nu0 {color: #cc66cc;}
.source-java5 .me1 {color: #006600;}
.source-java5 .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-xml {line-height: normal;}
.source-xml li, .source-xml pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for xml
 * CSS class: source-xml, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-xml .de1, .source-xml .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-xml  {}
.source-xml .head {}
.source-xml .foot {}
.source-xml .imp {font-weight: bold; color: red;}
.source-xml .ln-xtra {color: #cc0; background-color: #ffc;}
.source-xml li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-xml li.li2 {font-weight: bold;}
.source-xml .coMULTI {color: #808080; font-style: italic;}
.source-xml .es0 {color: #000099; font-weight: bold;}
.source-xml .br0 {color: #66cc66;}
.source-xml .st0 {color: #ff0000;}
.source-xml .nu0 {color: #cc66cc;}
.source-xml .sc0 {color: #00bbdd;}
.source-xml .sc1 {color: #ddbb00;}
.source-xml .sc2 {color: #339933;}
.source-xml .sc3 {color: #009900;}
.source-xml .re0 {color: #000066;}
.source-xml .re1 {font-weight: bold; color: black;}
.source-xml .re2 {font-weight: bold; color: black;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Java syntax

From Wikipedia, the free encyclopedia

Jump to: navigation, search 





This article may require cleanup to meet Wikipedia's quality standards. Please improve this article if you can. (April 2009)



Main article: Java (programming language)

The syntax of the Java programming language is a set of rules that defines how a Java program is written and interpreted.







Contents


1 Data structures

1.1 Primitive data types
1.2 Literals
1.3 Strings
1.4 Arrays
1.5 International language support


2 Operators

2.1 Arithmetic
2.2 Assignment
2.3 Comparison
2.4 Conditional expressions
2.5 Boolean
2.6 Bitwise operations
2.7 String operators


3 Control structures

3.1 If ... else
3.2 Switch statement
3.3 For loop

3.3.1 For-each loop


3.4 While loop
3.5 Do ... while
3.6 Control flow statements

3.6.1 Example:


3.7 Labels
3.8 Note about the "goto" statement


4 Objects

4.1 Classes

4.1.1 Inheritance
4.1.2 Scope


4.2 Interfaces

4.2.1 Implementing interfaces
4.2.2 Extending interfaces


4.3 Access modifiers

4.3.1 Top level class access
4.3.2 Class member access


4.4 Fields

4.4.1 Constants


4.5 Initializers

4.5.1 Static initializers
4.5.2 Instance initializers


4.6 Methods

4.6.1 Varargs


4.7 Constructors
4.8 Methods in the Object class

4.8.1 The clone method
4.8.2 The equals method
4.8.3 The finalize method
4.8.4 The getClass method
4.8.5 The hashCode method
4.8.6 The toString method
4.8.7 The wait and notify thread signaling methods

4.8.7.1 The wait methods
4.8.7.2 The notify and notifyAll methods






5 Input / Output
6 Running code

6.1 Apps
6.2 Applets

6.2.1 Embedding the applet tag


6.3 Servlets
6.4 JSP (JavaServer Pages)

6.4.1 JSP tags




7 Miscellaneous

7.1 Case sensitivity
7.2 Comments


8 Java keywords and reserved terms
9 See also
10 References
11 External links

11.1 Sun







//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>




[edit] Data structures
Although the language has special syntax for them, arrays and strings are not primitive types: they are reference types that can be assigned to java.lang.Object.

[edit] Primitive data types


Integer types


byte
8-bit signed


short
16-bit signed


int
32-bit signed


long
64-bit signed



Notes


Integer primitive types silently overflow. For example, adding one to Integer.MAX_VALUE, 231 − 1, will result in Integer.MIN_VALUE, − 231.



Floating-point types


float
32-bit signed


double
64-bit signed



Notes


Floating-point math never throws exceptions
Dividing a non-zero value by 0 equals infinity
Dividing a non-infinite value by infinity equals 0



Characters


char
16-bit unsigned Unicode




Boolean


boolean
true or false



Notes


Unlike C, C++, and similar languages, Java can't represent false as 0 or null
Can't represent true as non-zero
Can't cast from boolean to a non-boolean primitive data type, or vice versa


Primitive wrapper classes


Byte
Short
Integer
Long
Float
Double
Boolean
Character


Uses


Can be used to convert values from one type to another
Can be used to pass simple data types by reference


Misc


Passed by value to methods.
Non-boolean primitive data types have an initial value of 0; booleans have an initial value of false. Wrapper classes (and all subtypes of Object) have an initial value of null.


[edit] Literals


Integers


octal
0365, 0[0..7]*


hexadecimal
0xF5, 0x[0..9, A..F, a..f]*


decimal
245, [1..9][0..9]*


Floating-point values


float
23.5F, 23.5f; 1.72E3F, 1.72E3f, 1.72e3F, 1.72e3f


double
23.5, 23.5D, 23.5d; 1.72E3, 1.72E3D, ...


Character literals


char
'a', 'Z', '\u0231'


String literals


String
"Hello, world"


Characters escapes in strings


Unicode character
\u followed by the hexadecimal unicode code point


Tab
\t


Backspace
\b


Carriage return
\r


Form feed
\f


Backslash
\\


Single quote
\'


Double quote
\"


Line feed
\n



[edit] Strings
String

String objects are immutable
String objects must be initialized when created
When the compiler encounters a string literal (a series of characters enclosed in double quotes), it creates a String object
The "+" and "+=" operators are overloaded for use in string concatenation



String str1 = "alpha";
String str2 = new String("alpha");

StringBuffer and StringBuilder

Because StringBuffer and StringBuilder objects are mutable, they are more flexible for building and modifying strings without object creation overhead. The difference between StringBuffer and StringBuilder is that StringBuffer is thread-safe; StringBuilder is not.
Neither String nor StringBuffer are a descendant of one another



StringBuffer str1 = new StringBuffer("alpha");
str1.append("-meta"); // str1 is now "alpha-meta"
str1.setCharAt(str1.indexOf("m"), 'b'); // "m" is changed to "b"
System.out.println(str1); //calls str1.toString() and prints "alpha-beta"


[edit] Arrays

Java has array types for each type, including arrays of primitive types, class and interface types, as well as higher-dimensional arrays of array types.
All elements of an array must descend from the same type.
All array classes descend from the class java.lang.Object, and mirror the hierarchy of the types they contain.
Array objects have a read-only length attribute that contains the number of elements in the array.
Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C).
Java arrays have a single dimension. Multi-dimensional arrays are supported by the language, but are treated as arrays of arrays.



// Declare the array - name is "myArray", element type is references to "SomeClass"
SomeClass[] myArray = null;
 
// Allocate the array
myArray = new SomeClass[10];
 
// Or Combine the declaration and array creation
SomeClass[] myArray = new SomeClass[10];
 
// Allocate the elements of the array (not needed for simple data types)
for (int i = 0; i < myArray.length; i++)
    myArray[i] = new SomeClass();
 
// Allocate an array and initialize it
myArray = new SomeClass[]{new SomeClass(), new SomeClass(), new SomeClass()};


[edit] International language support
The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.
The following is thus perfectly valid Java code; it contains Chinese characters in the class and variable names as well as in a string literal:


 public class 哈嘍世界 
 {
     private String 文本 = "哈嘍世界";
 }


[edit] Operators

[edit] Arithmetic


Binary operators


Syntax
Meaning


+
Addition


-
Subtraction


*
Multiplication


/
Division


%
Remainder (not a normal modulo operation[1])


Unary operators


Syntax
Meaning


-
Unary negation (reverses the sign)


++
Increment (can be prefix or postfix)


--
Decrement (can be prefix or postfix)


!
Boolean complement operator


~
Bitwise inversion


(type)
Casting



[edit] Assignment


Syntax
Meaning


=
Assign


+=
Add and assign


-=
Subtract and assign


*=
Multiply and assign


/=
Divide and assign


%=
Modulus and assign


&=
Bitwise AND and assign


|=
Bitwise OR and assign


^=
Bitwise XOR and assign


<<=
Left shift (zero fill) and assign


>>=
Right shift (sign-propagating) and assign


>>>=
Right shift (zero fill) and assign



[edit] Comparison


Syntax
Meaning


==
Equals


!=
Not equal


>
Greater than


>=
Greater than or equal to


<
Less than


<=
Less than or equal to


instanceof
Instance of


When used with reference types, the equality operators (== and !=) compare the reference values, not the contents of the referenced objects—the comparison tests whether the two references refer to the same object (or null), not whether the two objects have equivalent value. The .equals(Object) method is used to compare the contents of objects. The instanceof operator is used to determine if an object is an instance of a class.

[edit] Conditional expressions
Conditional expressions use the compound ?: operator. Syntax:


condition ? expression1 : expression2

This evaluates condition, and if it is true then the conditional expression has the value of expression1; otherwise the conditional expression has the value of expression2.
Example:


String answer = (p < 0.05)? "reject" : "keep";

This is equivalent to the following code fragment:


 String answer;
 if (p < 0.05) 
 {
     answer = "reject";
 }
 else 
 {
     answer = "keep";
 }


[edit] Boolean

Short-circuit logical operations (evaluate operands from left-to-right until result can be determined)
Evaluates the minimal number of expressions necessary
Partial evaluation (rather than full evaluation)



Syntax
Meaning


&&
AND (if the first operand is false, then the result of the expression is false and the second operand is not evaluated)


||
OR (if the first operand is true, then the result of the expression is true and the second operand is not evaluated)


^
XOR (exclusive or: exactly one operand must be true)


!
NOT (logical negation)



[edit] Bitwise operations


Binary operators


&
AND (can also be used as a boolean operator for full evaluation)


|
OR (can also be used as a boolean operator for full evaluation)


^
XOR


<<
Left shift (zero fill)


>>
Right shift (sign-propagating)


>>>
Right shift (zero fill)


Unary operators


~
NOT (inverts the bits)



[edit] String operators


Syntax
Meaning


+
Concatenation


+=
Concatenation and assignment



[edit] Control structures

[edit] If ... else


 if (expr) 
 {
     statements;
 }
 else if (expr) 
 {
     statements;
 }
 else 
 {
     statements;
 }


The expr value must evaluate to a boolean value so for example "if(String a1 == String a2)" will not evaluate to true even if they are equal, but instead it will compare values, not its boolean equivalent.

Instead use "if(String a1.equals(String a2))" or an instance of comparison.
And also a shortcut for assignment:


result = (boolean condition) ? (if boolean is true) : (if boolean is false);

eg.


 int m1 = 5;
 int m2 = 10;
 ...
 int max = (m1 > m2) ? m1 : m2;

[2] 
[edit] Switch statement


 switch (expr) 
 {
 case VALUE1: 
     statements;
     break;
 case VALUE2: 
     statements;
     break;
 default:
     statements;
     break;
 }


The expr value must be a byte, short, int, or char.
Each case value must be a unique literal value; variables cannot be used.


[edit] For loop


 for (initial-expr; cond-expr; incr-expr) 
 {
     statements;
 }


[edit] For-each loop
J2SE 5.0 added a new feature called the for-each loop, which greatly simplifies the task of iterating through every element in a collection. Without the loop, iterating over a collection would require explicitly declaring an iterator:


 int sumLength(Set<String> stringSet) 
{
     int sum = 0;
     Iterator<String> itr = stringSet.iterator();
     while (itr.hasNext())
         sum += itr.next().length();
     return sum;
 }

The for-each loop greatly simplifies this method:


 int sumLength(Set<String> stringSet) 
{
     int sum = 0;
     for (String s : stringSet)
         sum += s.length();
     return sum;
 }

This loop is read as, for each String in stringSet, add the length to sum.

[edit] While loop


 while (expr) {
     statements;
 }


[edit] Do ... while


 do {
     statements;
 } while (expr);


[edit] Control flow statements


Syntax
Meaning


break;
Break from the innermost enclosing loop immediately.


continue;
Continue on to the next iteration of the loop.


break LABEL
Jump to the statement immediately after the labeled statement (terminate the labeled statement).


continue LABEL
Jump to the labeled statement (restart a labeled statement or continue execution of a labeled loop)



[edit] Example:


 int sum = 0;
 int i = 0;
 while (i < 10) {
     i++;
     if (i == 3) {
         continue;  // Skip the rest of this loop iteration.
     }
     sum += i;
 
     if (sum > 15) {
         break;  // Exit the loop.
     }
 }


[edit] Labels

Consists of an identifier followed by a colon
Used to identify the statement or block of code that the jump statements refer to
If the label is omitted, the jump statements refer to the innermost enclosing loop

Examples

LABEL1: statement;



public void twoNum( int num, int val )
{
OUTER_LOOP: // OUTER_LOOP is a label
  for ( int i = 0 ; i < num ; i++ )
  {
      for ( int j = 0 ; j < num ; j++ )
      {
         if ( i + j >= 2 * val )
            break OUTER_LOOP ;
         val = val / 2 ;
      }
  }
  // break comes here if it runs
}


[edit] Note about the "goto" statement
Although the "goto" statement is a reserved keyword in Java it does not, however, have any function in the Java Programming Language.

[edit] Objects

[edit] Classes
Java has nested classes that are declared within the body of another class or interface. A class that is not a nested class is called a top level class. An inner class is a non-static nested class.
Classes can be declared with the following modifiers:

abstract – cannot be instantiated. Only interfaces and abstract classes may contain abstract methods. A concrete (non-abstract) subclass that extends an abstract class must override any inherited abstract methods with non-abstract methods. Cannot be final.
final – cannot be subclassed. All methods in a final class are implicitly final. Cannot be abstract.
strictfp – all floating-point operations within the class and any enclosed nested classes use strict floating-point semantics. Strict floating-point semantics guarantee that floating-point operations produce the same results on all platforms.

Note that Java classes do not need to be terminated by a semicolon (";"), which is required in C++ syntax.

[edit] Inheritance

// ChildClass inherits from ParentClass
class ChildClass extends ParentClass { ... }  


The default parent of a class is the Object class.
A class can only extend a single parent class (no multiple inheritance of implementation).


[edit] Scope

this – Reference to the current subclass (assumed by default) (i.e. this.someMethod()).
super – Reference to the parent class (i.e. super.someMethod()). Can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.


[edit] Interfaces
An interface is an abstract class with no implementation details. Its purpose is to define how a set of classes will be used. Classes that implement a common interface can be used interchangeably within the context of the interface type. Interfaces also help to enforce the concept of abstraction—hiding the details of how a class is implemented.
An interface can only contain abstract methods and static final fields. Interface methods are public and abstract by default (unimplemented), and interface fields are public, static and final by default.
Java does not support full orthogonal multiple inheritance. Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types inherited multiple times. By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity. The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited.
Java interfaces behave much like the concept of the Objective-C protocol.

[edit] Implementing interfaces
A class can implement one or more interfaces using the implements keyword, in addition to extending another class.


 interface MyInterface 
 {
     void foo();
 }



 interface Interface2 
 {
     void bar();
 }



 class MyClass implements MyInterface 
 {
     void foo() {...}
     ...
 }



 class ChildClass extends ParentClass implements MyInterface, Interface2 
 {
     void foo() {...}
     void bar();
     ...
 }

In the following example,


 public interface Deleteable 
 {
     void delete();
 }

any non-abstract class that implements the Deleteable interface must define a non-abstract method named delete that has no parameters and a void return type. The implementation and function of the method are determined by each class. There are many uses for this concept, for example:


 public class Fred implements Deleteable 
 {
     // This method satisfies the Deleteable interface
     public void delete() 
     {
         // Code implementation goes here
     }
     public void someOtherMethod() 
     {
         //Code not shown
     }
 }



 public void deleteAll(Deleteable[] list) 
 {
     for (int i = 0; i < list.length; i++) 
     {
         list[i].delete();
     }
 }

Because any objects in the above array are guaranteed to have the delete() method, the deleteAll() method needn't differentiate between the Fred objects or any other Deleteable objects.

[edit] Extending interfaces
An interface can extend one or more interfaces using the extends keyword.


 interface ChildInterface extends ParentInterface, AnotherInterface {
     ...
 }

A class that implements the resulting interface must define the combined set of methods.


 public interface MyInterface 
 {
     foo();
 }



 public interface Interface2 extends MyInterface 
 {
     bar();
 }



 public class MyClass implements Interface2 
 {
     void foo() {...}
     void bar() {...}
     ...
 }


[edit] Access modifiers
Access modifiers determine which code may access classes and class members.

[edit] Top level class access
By default, Java classes are accessible only within their own Java package. This enables a package of classes to provide an API which performs functions behind the scenes. Hidden classes support the work of publicly accessible classes.

default – accessible only within the package in which it's defined.
public – extends access to classes outside the package


[edit] Class member access
Class members are fields, methods, constructors and nested classes declared within the body of a class. In order of increasing scope of access, the access modifiers for class members are:

private – accessible only within the class
package-private (no modifier) – accessible to other classes in the same package
protected – extends access to subclasses outside the package
public – accessible by any class.

When overriding a method, the method access modifier can't be made more restrictive—to do so would break the interface contract of the parent class. Thus when overridden, a public method must be declared public and a protected method cannot be given default access. However, it is permissible to override a method to make it more accessible. Thus when overriding, a default (package) access method can be declared as protected or public and a protected method can be declared as public.

[edit] Fields
In addition to the access modifiers, data fields may be declared with the following modifiers:

final – the value cannot be changed. Must be initialized exactly once. A final field declared without an initializer is a blank final field—a static blank final field must be definitively initialized by a static initializer; a non-static blank final field must be initialized during the execution of each and every constructor. Cannot be volatile.
static – belongs to the class, rather than to an instance of the class.
transient – not a part of the persistent state of an object. The value should not be saved and later restored.
volatile – informs the compiler that it may be accessed by separate threads asynchronously. Cannot be final.


[edit] Constants
Fields that are declared as both static and final are effectively constants; static means there is one occurrence of the field associated with the class, and final means that the field is assigned a value exactly once.

[edit] Initializers
Initializers are blocks of code that are executed at the same time as initializers for fields.

[edit] Static initializers
Static initializers are blocks of code that are executed at the same time as initializers for static fields. Static field initializers and static initializers are executed in the order declared. The static initialization is executed after the class is loaded.


 static int count = 20;
 static int[] squares;
 static {  // a static initializer
     squares = new int[count];
     for (int i = 0; i < count; i++)
         squares[i] = i * i;
 }
 static int x = squares[5];  // x is assigned the value 25


[edit] Instance initializers
Instance initializers are blocks of code that are executed at the same time as initializers for instance (non-static) fields. Instance field initializers and instance initializers are executed in the order declared.
Both instance initializers and instance field initializers are executed during the invocation of a constructor. The initializers are executed immediately after the superclass constructor and before the body of the constructor.

[edit] Methods
In addition to the access modifiers, methods may be declared with the following modifiers:

abstract – the method is undefined in the class, and must be defined by any concrete (non-abstract) subclass. Cannot be static, final or native.
final – the method cannot be redefined in a subclass. For instance (non-static) methods, this allows the compiler to expand the method (similar to an inline function) if the method is small enough. Cannot be abstract.
native – the method links to native machine-dependent code. Declared without a body. Cannot be abstract.
static – belongs to the class, rather than to an instance of the class. Cannot be abstract.
strictfp – all floating-point operations in the method and enclosed inner classes use strict floating-point semantics. Strict floating-point semantics guarantee that floating-point operations produce the same results on all platforms.
synchronized – causes the current thread to acquire the lock for the associated object before executing the body of the method. If the lock is currently held by another thread, the current thread will block until the lock is released and the thread is able to obtain the lock. The associated object is the Class object for static methods and the object instance for non-static methods. While it is allowed to declare an abstract method as synchronized, it is meaningless to do so since synchronization is an aspect of the implementation, not the declaration, and abstract methods do not have an implementation.

Note that a private method can't be abstract and is implicitly final.

[edit] Varargs
Java SE 5.0 added syntactic support for methods with a variable number of arguments (varargs) [1], which simplifies the typesafe usage of methods requiring a variable number of arguments. The last parameter can be followed with ..., and Java will box all the arguments into an array:

public void drawPolygon (Point... points) {…}

When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0], points[1], etc. If no points are passed, the array has a length of zero. To require the programmer to use a minimum number of parameters, those parameters can be specified before the variable argument:

// A polygon needs at least 3 points.
public void drawPolygon (Point p1, Point p2, Point p3, Point... otherPoints) {…}


[edit] Constructors
A constructor is called to initialize an object immediately after the object has been allocated. Typically, a constructor is invoked using the new keyword, although constructors can also be invoked using reflection provided by the java.lang.reflect package.

The access modifiers are the only modifiers that may be used for declaring constructors.
When possible, the object should be a valid, meaningful object once it is constructed, as opposed to relying on a separate initialization method.
By convention, a copy constructor is a constructor that accepts an object of its own type as a parameter and copies the data members.
If no explicit constructor is defined, then the compiler provides an implicit empty default constructor that takes no parameters.
Constructors can be overloaded.
The first statement in a constructor may invoke a superclass constructor: super(...); or another constructor in the same class: this(...);
If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed.


[edit] Methods in the Object class
Methods in the Object class are inherited, and thus shared in common by all classes.

[edit] The clone method
Main article: Clone (Java method)
The Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface Cloneable to indicate that they can be cloned.

[edit] The equals method
The Object.equals(Object) method compares the object to another object and returns a boolean result indicating if the two objects are equal. Semantically, this method compares the contents of the objects whereas the equality comparison operator "==" compares the object references. The equals method is used by many of the data structure classes in the java.util package. Some of these data structure classes also rely on the Object.hashCode method—see the hashCode method for details on the contract between equals and hashCode. Implementing equals() isn't always as easy as it seems, see 'Secrets of equals()' for more information.

[edit] The finalize method
Main article: Finalizer
The Object.finalize() method is called exactly once before the garbage collector frees the memory for object. A class overrides finalize to perform any clean up that must be performed before an object is reclaimed. Most objects do not need to override finalize.
There is no guarantee when the finalize method will be called, or the order in which the finalize method will be called for multiple objects. If the JVM exits without performing garbage collection, the OS may free the objects, in which case the finalize method doesn't get called.
The finalize method should always be declared protected to prevent other classes from calling the finalize method.

protected void finalize() throws Throwable { ... }


[edit] The getClass method
The Object.getClass() method returns the Class object for the class that was used to instantiate the object. The class object is the base class of reflection in Java. Additional reflection support is provided in the java.lang.reflect package.

[edit] The hashCode method
The Object.hashCode() method returns an integer (int) that is used as a hash code for storing the object in an associative array. Classes that implement the java.util.Map interface provide associative arrays and rely on the hashCode method. A good hashCode implementation will return a hash code that is stable (does not change) and evenly distributed (the hash codes of unequal objects tend to be unequal and the hash codes are evenly distributed across integer values).
Because associative arrays depend on both the equals and hashCode methods, there is an important contract between these two methods that must be maintained if the objects are to be inserted into a Map:

For two objects a and b

a.equals(b) == b.equals(a)
if a.equals(b) then a.hashCode() == b.hashCode()



In order to maintain this contract, a class that overrides the equals method must also override the hashCode method, and vice versa, so that hashCode is based on the same properties (or a subset of the properties) as equals.
A further contract that the map has with the object is that the results of the hashCode and equals methods will not change once the object has been inserted into the map. For this reason, it is generally a good practice to base the hash function on immutable properties of the object.
Two equal objects must have the same hashcode. However, 2 different objects are NOT required to have different hashcodes.

[edit] The toString method
The Object.toString() method returns a String that contains a text representation of the object. The toString method is implicitly called by the compiler when an object operand is used with the string concatenation operators (+ and +=).

[edit] The wait and notify thread signaling methods
Every object has two wait lists for threads associated with it. One wait list is used by the synchronized keyword to acquire the mutex lock associated with the object. If the mutex lock is currently held by another thread, the current thread is added to the list of blocked threads waiting on the mutex lock. The other wait list is used for signaling between threads accomplished through the wait and notify and notifyAll methods.
Use of wait/notify allows efficient coordination of tasks between threads. When one thread needs to wait for another thread to complete an operation, or needs to wait until an event occurs, the thread can suspend its execution and wait to be notified when the event occurs. This is in contrast to polling, where the thread repeatedly sleeps for a short period of time and then checks a flag or other condition indicator. Polling is both more computationally expensive, as the thread has to continue checking, and less responsive since the thread won't notice the condition has changed until the next time to check.

[edit] The wait methods
There are three overloaded versions of the wait method to support different ways to specify the timeout value: wait(), wait(long timeout) and wait(long timeout, int nanos). The first method uses a timeout value of zero (0), which means that the wait does not timeout; the second method takes the number of milliseconds as a timeout; the third method takes the number of nanoseconds as a timeout, calculated as 1000000 * timeout + nanos.
The thread calling wait is blocked (removed from the set of executable threads) and added to the object's wait list. The thread remains in the object's wait list until one of three events occurs:

another thread calls the object's notify or notifyAll method (see the notify methods below for details);
another thread calls the thread's interrupt() method; or
a non-zero timeout that was specified in the call to wait expires.

The wait method must be called inside of a block or method synchronized on the object. This ensures that there are no race conditions between wait and notify. When the thread is placed in the wait list, the thread releases the object's mutex lock. After the thread is removed from the wait list and added to the set of executable threads, it must acquire the object's mutex lock before continuing execution.

[edit] The notify and notifyAll methods
The Object.notify() and Object.notifyAll() methods remove one or more threads from an object's wait list and add them to the set of executable threads. notify removes a single thread from the wait list, while notifyAll removes all threads from the wait list. Which thread is removed by notify is unspecified and dependent on the JVM implementation.
The notify methods must be called inside of a block or method synchronized on the object. This insures that there are no race conditions between wait and notify.

[edit] Input / Output

See also: Java Platform, Standard Edition#java.io and New I/O

Versions of Java prior to J2SE 1.4 only supported stream-based blocking I/O. This required a thread per stream being handled, as no other processing could take place while the active thread blocked waiting for input or output. This was a major scalability and performance issue for anyone needing to implement any Java network service. Since the introduction of NIO (New I/O) in J2SE 1.4, this scalability problem has been rectified by the introduction of a non-blocking I/O framework (though there are a number of open issues in the NIO API as implemented by Sun).
The non-blocking IO framework, though considerably more complex than the original blocking IO framework, allows any number of "channels" to be handled by a single thread. The framework is based on the Reactor pattern.

[edit] Running code

[edit] Apps

Java code that runs in a stand-alone virtual machine (not in a Web browser)
A main method must be defined as follows:



public class MyClass 
{
    public static void main(String[] args) {...}
    ...
}

It could also be declared using varargs:


public class MyClass 
{
    public static void main(String... args) {...}
    ...
}


[edit] Applets
Main article: Java applet

Java code that runs in a web browser, in a designated display area
init and destroy are only called once, but start and stop are called as many times as the user visits the web page.



 // MyApplet.java
 
 import java.applet.*;
 
 public class MyApplet extends Applet 
{
     init() {...}     // Called when the browser first loads the applet.
     destroy() {...}  // Called when the user quits the browser.
     start(){...}     // Called when the applet starts running.
     stop() {...}     // Called when the user leaves the web page,
                      // reloads it, or quits the browser.
 }



 <!-- MyApplet.html -->
 <applet code="MyApplet" width=200 height=200>
 </applet>


[edit] Embedding the applet tag

The HTML applet tag can be embedded in the applet source code.
Inclusion of the applet tag allows the applet to be run directly by a simple applet viewer, without the need for an .html file.
Typically, the applet tag immediately follows the import statements.
It must be enclosed by /* */ comments.



 // MyApplet.java
 ...
 /*
 <applet code="MyApplet.class"> </applet> 
 */
 ...


[edit] Servlets
Main article: Java servlet

Java code that runs on a Web server, with the output (generally HTML or XML) typically sent to a Web browser.
Servlets are the Java equivalent to CGI applications.


[edit] JSP (JavaServer Pages)
Main article: JavaServer Pages

Java code that's embedded in a Web page
JSP tags are processed on a Web server; the resulting output (generally HTML or XML) is sent to the client.
JSP code is compiled into a Java Servlet before it's run.
JSP is an extension of Java Servlets.
The usage of JSP tags is comparable to the usage of PHP or ASP tags.


[edit] JSP tags


Syntax
Meaning


<% java-expressions %>
Scriptlet


<%= single-java-expression-to-output %>
Expression


<%! java-declaration-expressions %>
Declaration


<%@ [page, include, taglib] jsp-directive %>
Directive



[edit] Miscellaneous

[edit] Case sensitivity
Java is case sensitive.

[edit] Comments

// Single-line comment


/* Multiple-line
   comment */


/**
 * These lines are used before the declaration of a class, interface, method,
 * or data member.   This type of comment can be extracted by a utility
 * to automatically create the documentation for a class.
 */


[edit] Java keywords and reserved terms



abstract
assert (JDK 1.4)
break
case
catch
class
const (not used)
continue
default
do


else
enum (JDK 1.5)
extends
final
finally
for
goto (not used)
if
implements
import


instanceof
interface
native
new
package
private
protected
public
return
static


strictfp
super
switch
synchronized
this
throw
throws
transient
try
volatile


while
boolean
byte
char
double
float
int
long
short
void


false
null
true











[edit] See also

Java programming language
Java keywords
Java Platform, Standard Edition


[edit] References

^ http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#24956
^ Adapted from Re: the Question Mark in Java Syntax


James Gosling, Bill Joy, Guy Steele, and Gilad Bracha, The Java language specification, third edition. Addison-Wesley, 2005. ISBN 0-321-24678-0.
Patrick Naughton, Herbert Schildt. Java 2: The Complete Reference, third edition. The McGraw-Hill Companies, 1999. ISBN 0-07-211976-4
Vermeulen, Ambler, Bumgardner, Metz, Misfeldt, Shur, Thompson. The Elements of Java Style. Cambridge University Press, 2000. ISBN 0-521-77768-2


[edit] External links

[edit] Sun

Official Java home site
The Java Language Specification, Third edition Authoritative description of the Java language
Java SE 6 API Javadocs
The Java Tutorial
New features in J2SE 1.5.0








v • d • e

Java





Java platform

Java ME · Java SE · Java EE · Java Card







Sun technologies

Java programming language · Squawk · Java Development Kit · OpenJDK · Java Virtual Machine · JavaFX






Major third-party technologies

JRockit · GNU Classpath · Kaffe · TopLink · Apache Harmony · Apache Struts · Spring framework · Hibernate · JBoss application server · Processing · Tapestry · Thinwire






History

Java version history · Criticism of Java · Java Community Process · Sun Microsystems · Free Java implementations






Language features

Bytecode · Syntax · Applets · Servlets · MIDlets · jsp · Web Start (jnlp)






Scripting languages

Java Tcl · Jython · JRuby · BeanShell · Groovy · Judoscript · Sleep · Bean Scripting Framework · Yoix · Rhino






Java conferences

JavaOne









Retrieved from "http://en.wikipedia.org/wiki/Java_syntax"
Categories: Java programming languageHidden categories: Cleanup from April 2009 | All pages needing cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Deutsch
ქართული
日本語









 This page was last modified on 23 April 2009, at 17:10 (UTC).
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
