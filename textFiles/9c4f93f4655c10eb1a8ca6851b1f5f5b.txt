













Virtual function - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Virtual_function";
		var wgTitle = "Virtual function";
		var wgAction = "view";
		var wgArticleId = "374664";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 282233163;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-vb {line-height: normal;}
.source-vb li, .source-vb pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for vb
 * CSS class: source-vb, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-vb .de1, .source-vb .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-vb  {}
.source-vb .head {}
.source-vb .foot {}
.source-vb .imp {font-weight: bold; color: red;}
.source-vb .ln-xtra {color: #cc0; background-color: #ffc;}
.source-vb li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-vb li.li2 {font-weight: bold;}
.source-vb .kw1 {color: #b1b100;}
.source-vb .co1 {color: #808080;}
.source-vb .es0 {color: #000099;}
.source-vb .br0 {color: #66cc66;}
.source-vb .st0 {color: #ff0000;}
.source-vb .nu0 {color: #cc66cc;}
.source-vb .me1 {color: #66cc66;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Virtual function

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
In object-oriented programming, a virtual function or virtual method is one whose behavior can be overridden within an inheriting class by a function with the same signature. This concept is a very important part of the polymorphism portion of object-oriented programming (OOP).




Contents


1 Purpose
2 Example

2.1 C++
2.2 Java
2.3 C#
2.4 VB.NET


3 Abstract classes and pure virtual functions

3.1 C++
3.2 Java (and C#)


4 Behavior During Construction and Destruction

4.1 C++
4.2 Java


5 Virtual destructors
6 See also
7 References





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Purpose
Further information: Dynamic dispatch
The concept of the virtual function solves the following problem:
In OOP when a derived class inherits from a base class, an object of the derived class may be referred to (or cast) as either being the base class type or the derived class type. If there are base class functions overridden by the derived class, a problem then arises when a derived object has been cast as the base class type. When a derived object is referred to as being of the base's type, the desired function call behavior is ambiguous.
The distinction between virtual and not virtual resolves this ambiguity. If the function in question is designated "virtual" in the base class then the derived class's function would be called (if it exists). If it is not virtual, the base class's function would be called.
Virtual functions overcome the problems with the type-field solution by allowing the programmer to declare functions in a base class that can be redefined in each derived class.

[edit] Example
For example, a base class Animal could have a virtual function eat. Subclass Fish would implement eat() differently than subclass Wolf, but you can invoke eat() on any class instance referred to as Animal, and get the eat() behavior of the specific subclass.
This allows a programmer to process a list of objects of class Animal, telling each in turn to eat (by calling eat()), with no knowledge of what kind of animal may be in the list. You also do not need to have knowledge of how each animal eats, or what the complete set of possible animal types might be.

[edit] C++
The following is an example in C++. Note that this example is not exception-safe. In particular, it may leak resources if new or vector::push_back throws an exception.


#include <iostream>
#include <vector>
 
using namespace std;
class Animal
{
public:
    virtual void eat() const { cout << "I eat like a generic Animal." << endl; }
    virtual ~Animal() {}
};
 
class Wolf : public Animal
{
public:
    void eat() const { cout << "I eat like a wolf!" << endl; }
};
 
class Fish : public Animal
{
public:
    void eat() const { cout << "I eat like a fish!" << endl; }
};
 
class GoldFish : public Fish
{
public:
    void eat() const { cout << "I eat like a goldfish!" << endl; }
};
 
 
class OtherAnimal : public Animal
{
};
 
int main()
{
    std::vector<Animal*> animals;
    animals.push_back( new Animal() );
    animals.push_back( new Wolf() );
    animals.push_back( new Fish() );
    animals.push_back( new GoldFish() );
    animals.push_back( new OtherAnimal() );
 
    for( std::vector<Animal*>::const_iterator it = animals.begin();
       it != animals.end(); ++it) 
    {
        (*it)->eat();
        delete *it;
    }
 
   return 0;
}

Output with the virtual function Animal::eat():

I eat like a generic Animal.
I eat like a wolf!
I eat like a fish!
I eat like a goldfish!
I eat like a generic Animal.

Output if Animal::eat() were not declared as virtual:

I eat like a generic Animal.
I eat like a generic Animal.
I eat like a generic Animal.
I eat like a generic Animal.
I eat like a generic Animal.


[edit] Java
In Java, all methods are by default "virtual functions". The following is an example in Java:


import java.util.*;
 
public class Animal {
   public void eat() { System.out.println("I eat like a generic Animal."); }
 
   public static void main(String[] args) {
      List<Animal> animals = new LinkedList<Animal>();
 
      animals.add(new Animal());
      animals.add(new Wolf());
      animals.add(new Fish());
      animals.add(new OtherAnimal());
 
      for (Animal currentAnimal : animals) {
         currentAnimal.eat();
      }
   }
}
 
public class Wolf extends Animal {
   public void eat() { System.out.println("I eat like a wolf!"); }
}
 
public class Fish extends Animal {
   public void eat() { System.out.println("I eat like a fish!"); }
}
 
public class OtherAnimal extends Animal {}

Output:

I eat like a generic Animal.
I eat like a wolf!
I eat like a fish!
I eat like a generic Animal.


[edit] C#
In C#, a base class must provide the virtual modifier for any virtual method, and derived classes must provide the override modifier for any overriden method inherited from a base class. The following is an example in C#:


using System;
using System.Collections.Generic;
 
namespace ConsoleApplication1
{
  public class Animal
  {
    public virtual void eat()
    {
      Console.WriteLine("I eat like a generic Animal.");
    }
  }
 
  public class Wolf : Animal
  {
    public override void eat()
    {
      Console.WriteLine("I eat like a wolf!");
    }
  }
 
  public class Fish : Animal
  {
    public override void eat()
    {
      Console.WriteLine("I eat like a fish!");
    }
  }
 
  public class GoldFish : Fish
  {
    public override void eat()
    {
      Console.WriteLine("I eat like a goldfish!");
    }
  }
 
  public class OtherAnimal : Animal
  {
    // eat() method is not overridden, so the base class method will be used.
  }
 
  class Program
  {
    static void Main(string[] args)
    {
      List<Animal> animals = new List<Animal>();
 
      animals.Add(new Animal());
      animals.Add(new Wolf());
      animals.Add(new Fish());
      animals.Add(new GoldFish());
      animals.Add(new OtherAnimal());
 
      foreach (Animal currentAnimal in animals)
      {
        currentAnimal.eat();
      }
    }
  }
}

Output:

I eat like a generic Animal.
I eat like a wolf!
I eat like a fish!
I eat like a goldfish!
I eat like a generic Animal.


[edit] VB.NET
In VB.NET, a base class must provide the Overridable modifier for any virtual method, and derived classes may provide the optional Overrides modifier for any overriden method inherited from a base class (this prevents a warning from being issued). The following is an example in VB.NET:


Imports System
Imports System.Collections.Generic
 
Namespace ConsoleApplication1
 
    Public Class Animal
        Public Overridable Sub eat()
            Console.WriteLine("I eat like a generic Animal.")
        End Sub
    End Class
 
    Public Class Wolf
        Inherits Animal
        Public Overrides Sub eat()
            Console.WriteLine("I eat like a wolf!")
        End Sub
    End Class
 
    Public Class Fish
        Inherits Animal
        Public Overrides Sub eat()
            Console.WriteLine("I eat like a fish!")
        End Sub
    End Class
 
    Public Class Goldfish
        Inherits Fish
        Public Overrides Sub eat()
            Console.WriteLine("I eat like a goldfish!")
        End Sub
    End Class
 
    Public Class OtherAnimal
        Inherits Animal
        'eat() method is not overridden, so the base class method will be used.
    End Class
 
    Public Class Program
        Shared Sub Main()
            Dim animals As New List(Of Animal)
            animals.Add(New Animal())
            animals.Add(New Wolf())
            animals.Add(New Fish())
            animals.Add(New Goldfish())
            animals.Add(New OtherAnimal())
 
            For Each currentAnimal As Animal In animals
                currentAnimal.eat()
            Next
        End Sub
    End Class
 
End Namespace

Output:

I eat like a generic Animal.
I eat like a wolf!
I eat like a fish!
I eat like a goldfish!
I eat like a generic Animal.



[edit] Abstract classes and pure virtual functions
A pure virtual function or pure virtual method is a virtual function that is required to be implemented by a derived class that is not abstract. Classes containing pure virtual methods are termed "abstract;" they cannot be instantiated directly, and a subclass of an abstract class can only be instantiated directly if all inherited pure virtual methods have been implemented by that class or a parent class. Pure virtual methods typically have a declaration (signature) and no definition (implementation).
As an example, an abstract base class "MathSymbol" may provide a pure virtual function doOperation(), and derived classes "Plus" and "Minus" implement doOperation() to provide concrete implementations. Implementing doOperation() would not make sense in the "MathSymbol" class as "MathSymbol" is an abstract concept whose behaviour is defined solely for each given kind (subclass) of "MathSymbol". Similarly, a given subclass of "MathSymbol" would not be complete without an implementation of doOperation().
Although pure virtual methods typically have no implementation in the class that declares them, pure virtual methods in C++ are permitted to contain an implementation in their declaring class, providing fallback or default behaviour that a derived class can delegate to if appropriate.
Pure virtual functions are also used where the method declarations are being used to define an interface for which derived classes will supply all implementations. An abstract class serving as an interface contains only pure virtual functions, and no data members or ordinary methods. Use of purely abstract classes as interfaces works in C++ as it supports multiple inheritance. Because many OO languages do not support multiple inheritance they often provide a separate interface mechanism. This is seen in Java for example.

[edit] C++
In C++, pure virtual functions are declared using a special syntax [ = 0 ] as demonstrated below.


class Abstract {
public:
   virtual void pure_virtual() = 0;
};

The pure virtual function declaration provides only the prototype of the method. Although an implementation of the pure virtual function is typically not provided in an abstract class, it may be included, although the definition may not be included at the point of declaration [1]. Every non-abstract child class is still required to override the method, but the implementation provided by the abstract class may be called in this way:


 void Abstract::pure_virtual() {
   // do something
 }
 
 class Child : public Abstract {
   virtual void pure_virtual(); // no longer abstract, this class may be
                                // instantiated.
 };
 
 void Child::pure_virtual() {
   Abstract::pure_virtual(); // the implementation in the abstract class 
                             // is executed
 }


[edit] Java (and C#)
In Java (and C#), pure virtual methods are declared using the abstract keyword. Such a method cannot have a body. A class containing abstract methods (either directly, or inherited and not overridden) must itself be declared abstract. (But the converse is not true - an abstract class is not required to have any abstract methods.) An abstract class cannot be instantiated.


abstract class B {
    abstract void a_pure_virtual_function();
}

Java also uses interfaces. All of the methods declared in an interface are implicitly abstract:


interface C {
    void a_pure_virtual_function();
}


[edit] Behavior During Construction and Destruction
Languages differ in their behaviour while the constructor or destructor of an object is running. For some languages, notably C++, the virtual dispatching mechanism has different semantics during construction and destruction of an object. While it is recommended that virtual function calls in constructors should be avoided for C++ [2], in some other languages, for example Java and C#, the derived implementation can be called during construction and design patterns such as the Abstract Factory Pattern actively promote this usage in languages supporting the ability.

[edit] C++


#include <iostream>
#include <string>
 
using namespace std;
 
struct A
{
  virtual string name() const { return "A"; } 
  virtual ~A() { cout << "Destructing " << name(); }   
};
 
struct B : A
{
  B() { cout << "Constructing " << name() << endl; }
  virtual string name() const { return "B"; }
};
 
struct C : B
{
  virtual string name() const { return "C"; }
};
 
int main()
{
  C c; // Output: "Constructing B"
 
} // Output: "Destructing A"


[edit] Java


public class Base {
  public int length()  { return 0; }
  public Base()
  {
    System.out.println("Constructing " + length());
  }
 
  static class Derived extends Base {
    String name_;
    public Derived(String name) 
    {
      name_ = name != null ? name : ""; // Class invariant name_ is not null
    }
    public int length() { return name_.length(); } // Assume name_ is not null 
  }
 
  public static void  main(String[] args) 
  {
    new Derived("Ooops");    // NullPointerException, Derived.name_ has not been assigned to yet
  }
}

This is because the constructor of Base is executed before the constructor of Derived. As the constructor of Base calls length(), a null pointer exception is thrown.

[edit] Virtual destructors
Object-oriented languages typically manage memory allocation and deallocation automatically when objects are created and destroyed, however some object-oriented languages allow a custom destructor method to be implemented if desired. One such language is C++, and as illustrated in the following example, it is important for a C++ base class to have a virtual destructor to ensure that the destructor from the most derived class will always be called.
In the example below having no virtual destructor, while deleting an instance of class B will correctly call destructors for both B and A if the object is deleted as an instance of B, an instance of B deleted via a pointer to its base class A will produce undefined behaviour.[3] On many implementations, the destructor for B will not be called in this situation.


 #include <iostream>
 using namespace std;
 
 class A
 {
 public:
 
   A() { }
   ~A() { cout << "Destroy A" << endl; }
 };
 
 class B : public A
 {
 public:
 
   B() { }
   ~B() { cout << "Destroy B" << endl; }
 };
 
 int main()
 {
   A* b1 = new B;
   B* b2 = new B;
 
   delete b1; // According to the C++ standard,
              // the behaviour of this is undefined.
              // Usually, only ~A() is called though b1 is an instance
              // of class B because ~A() is not declared virtual. 
   delete b2; // Calls destructors ~B() and ~A()
 
   return 0;
 }

Possible output:

Destroy A
Destroy B
Destroy A

Correctly declaring the destructor for class A as virtual ~A() will ensure that the destructor for class B is called in both cases with the example above.

[edit] See also

Inheritance (computer science)
Superclass (computer science)
Virtual inheritance


[edit] References

^ Standard C++ 98 - 10.4/2
^ Meyers, Scott (June 6, 2005). "Never Call Virtual Functions during Construction or Destruction". http://www.artima.com/cppsource/nevercall.html. 
^ ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ §5.3.5 Delete [expr.delete] para. 3


C++ FAQ Lite Copyright © 1991-2006, Marshall Cline.




Retrieved from "http://en.wikipedia.org/wiki/Virtual_function"
Categories: Object-oriented programming | C++ | Articles with example C++ code 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Česky
Deutsch
Español
Français
Italiano
Polski
Română
Русский
Svenska
中文









 This page was last modified on 7 April 2009, at 00:20.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
